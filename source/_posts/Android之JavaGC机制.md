---

title: Android之 Java垃圾回收机制
categories: "android 总结"
tags: 
	- 垃圾回收机制

---
# Java垃圾回收机制 #

	参考：
		1. http://www.cnblogs.com/laoyangHJ/articles/java_gc.html
		2. https://www.jianshu.com/p/c4b283848970

- 垃圾回收机制的目的在于清理不再使用的对象；
- 通过确定对象是否被活动对象引用来确定是否收集；
- 通过引用计数和对象引用遍历来进行收集。

使用垃圾收集器必要的知识：

- 每个对象只能调用finalize( )方法一次。如果在finalize( )方法执行时产生异常（exception），则该对象仍可以被垃圾收集器收集。

- 垃圾收集器跟踪每一个对象，收集那些不可触及的对象（即该对象不再被程序引用了），回收其占有的内存空间。但在进行垃圾收集的时候，垃圾收集器会调用该对象的finalize( )方法（如果有）。如果在finalize()方法中，又使得该对象被程序引用(俗称复活了)，则该对象就变成了可触及的对象，暂时不会被垃圾收集了。但是由于每个对象只能调用一次finalize( )方法，所以每个对象也只可能 "复活 "一次。

- Java语言允许程序员为任何方法添加finalize( )方法，该方法会在垃圾收集器交换回收对象之前被调用。但不要过分依赖该方法对系统资源进行回收和再利用，因为该方法调用后的执行结果是不可预知的。

- 垃圾收集器不可以被强制执行，但程序员可以通过调研System.gc方法来建议执行垃圾收集。记住，只是建议。一般不建议自己写System.gc，因为会加大垃圾收集工作量。

---
### 引用计数法 ###
垃圾回收机制早期策略。堆内部的<font color="red">**每个对象**</font>都有引用计数。任何引用计数为0的对象可以被当作垃圾收集。

- 引用计数+1的情况：
	- 对象创建；
	- 给对象被引用给其他变量；
- 引用计数 -1的情况：
	- 引用该对象的变量超出生命周期；
	- 引用该对象的变量赋值其他对象的引用；


优点：

		引用计数收集器可以很快的执行，交织在程序运行中。对程序不
	被长时间打断的实时环境比较有利。

缺点：

		循环引用无法检测回收。
---
### 跟踪收集法 ###
垃圾回收机制早期策略。使用对象引用进行遍历。GC可使用单、多线程增加效率。

过程：
- 从一组对象开始，沿对象的每个属性链接，递归确定可到达的对象；
- 如果某对象不能被任何递归到达，GC将会记住可以到达的对象；
- GC要删除不可到达的对象后，释放内存生成新的对象，多个小段对象组合，组织内存中的对象，进行压缩，形成可利用的空间；
- GC停止其他的活动，所有与应用程序相关的工作停止。
	

常用的垃圾收集器

- 标记清除收集器: 大部分Davik采取的都是标记-清理回收算法，而且具体使用什么算法是在编译期决定的，无法在运行的时候动态更换。标记-清理回收算法无法对Heap中空闲内存区域做碎片整理。**系统仅仅会在新的内存分配之前判断Heap的尾端剩余空间是否足够，如果空间不够会触发gc操作，从而腾出更多空闲的内存空间；这样内存空洞就产生了。**

		单进程工作并停止其他工作。
		清除未被标记的对象而不压缩导致大量内存碎片，造成浪费。
	![标记清除收集器](https://upload-images.jianshu.io/upload_images/4056837-af944b516c7953ca?imageMogr2/auto-orient/strip%7CimageView2/2/w/350)
- 标记压缩收集器

		将标记对象复制到堆栈新域以便压缩堆栈，同时停止其他操作。
	![标记压缩收集器](https://upload-images.jianshu.io/upload_images/4056837-f11bc1f2c7da2ee6?imageMogr2/auto-orient/strip%7CimageView2/2/w/350)
- 复制收集器

		- 堆栈分为两个域，每次只使用一半空间。
		- gc运行时复制到另一个域，压缩堆栈。
		- 持续复制长生存期的对象将导致效率降低，要求内存大。
	![复制收集器](https://upload-images.jianshu.io/upload_images/4056837-bd4a3ddcd015d6e9?imageMogr2/auto-orient/strip%7CimageView2/2/w/350)
- <font color="red">增量收集器</font>

		- 将堆栈分为多个块儿，每次gc对其中一个块儿进行垃圾收集。
		- 用户一般不会察觉到gc的工作。

- <font color="red">分代收集器</font>
	分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。

	目前大部分垃圾收集器对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少，但是实际中并不是按照1：1的比例来划分新生代的空间的，**一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。如果在清理的过程中，To Space无法足够来存储某个对象，就会将该对象移动到老年代中。当对象在Survivor区躲过一次GC的话，其对象年龄便会加1，默认情况下，如果对象年龄达到15岁，就会移动到老年代中。**
	![新生代](https://images0.cnblogs.com/i/288799/201406/181512325519249.jpg)
	而由于老年代的特点是每次回收都只回收少量对象，一般使用的是Mark-Compact算法。
	![分代收集器](https://segmentfault.com/img/bVkZav)
	注意，在堆区之外还有一个代就是永久代（Permanet Generation），它用来存储class类、常量、方法描述等。**对永久代的回收主要回收两部分内容：废弃常量和无用的类。**

		- 长生命周期对象拷贝造成事件内存浪费；
		- 堆栈分为多个块儿，存放不同寿命的对象；
		- 一段时间间隔，将继续存在的对象转入生命周期长的域内；
		- 不同域有不同算法。


---
### <font color="Blue">JVM GC工作原理</font>

#### JVM结构 ####
JVM内存结构由堆、栈、本地方法栈、方法区等部分组成。

1. 方法区

2. 本地方法栈

3. 栈

4. 堆


#### 原理 ####
















---

	参考:
	http://blog.csdn.net/u012152619/article/details/46968883
	http://www.jianshu.com/p/c9ac99b87d56
	http://www.cnblogs.com/laoyangHJ/articles/java_gc.html
	https://juejin.im/entry/581198675bbb50005b84f2bb
	http://www.jianshu.com/p/c9ac99b87d56
	http://www.jianshu.com/p/380fa5c92dcc	