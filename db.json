{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1515072990000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1515072990000},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1515072990000},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1515072990000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1515072990000},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1515072990000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1515072990000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1515072990000},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1515072990000},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1515072990000},{"_id":"themes/next/README.cn.md","hash":"5d8af3d8de8d3926126a738519e97c8442b0effe","modified":1515072990000},{"_id":"themes/next/README.md","hash":"44b28d995681a7c48bfe3d0577d6203812d07e59","modified":1515072990000},{"_id":"themes/next/_config.yml","hash":"5ff37e90e4d6812c8fc40c03fa6e1d903d743470","modified":1515072990000},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1515072990000},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1515072990000},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1515072990000},{"_id":"source/_posts/Android之显示——文字适配.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之DataBinding.md","hash":"123935f7fc289966921c8b957ac17c0b881204d0","modified":1520818072285},{"_id":"source/_posts/Android与C,C++,JNI,NDK.md","hash":"8c79814c9c4da0d63aa6324e0c6ea59ddff1e2cb","modified":1516269333750},{"_id":"source/_posts/Android之Drawable.md","hash":"b3d58d6525c0caadbc127bb9e06f1afd6905912c","modified":1514280781220},{"_id":"source/_posts/Android之JavaGC机制.md","hash":"9d48b2c4073c6f832893d6169944e49518fc13c2","modified":1521188817244},{"_id":"source/_posts/Android之Handler,Looper,MessageQueue和HandlerThread.md","hash":"ab4a86df2542920b3efbac549cee740d2084372d","modified":1520823665463},{"_id":"source/_posts/Android之adb.md","hash":"86139cdc0f8b46891b20c9d80830cad471435086","modified":1506505234613},{"_id":"source/_posts/Android之发布优化——多渠道打包.md","hash":"f703e09a93fc5f4c5f26818feeb533aa2c2b6e84","modified":1506506751450},{"_id":"source/_posts/Android之前端交互与WebView.md","hash":"14a5afef18ddb84709137ddf9ac19eed3ba14303","modified":1516610750879},{"_id":"source/_posts/Android之发布优化——动画.md","hash":"35095113c20a8db443a2ac343fbee2a4d218e011","modified":1516697730141},{"_id":"source/_posts/Android之发布优化——性能优化.md","hash":"72edc859f803062bc741f87ed37a853911e26d1b","modified":1521107811666},{"_id":"source/_posts/Android之发布优化——更新.md","hash":"f9b579449ed591f671f4539b3c6c2bcc2ddc5d1a","modified":1507620389682},{"_id":"source/_posts/Android之发布优化——混淆.md","hash":"139daa63d50db3e26b55c8388b2418902b974be6","modified":1516763683970},{"_id":"source/_posts/Android之发布优化——硬件加速.md","hash":"7f9bffa6abb8fb5ccf771bb4f3b8c6019d8ddb82","modified":1508299276375},{"_id":"source/_posts/Android之四大组件——Activity.md","hash":"21fe7af5dcf0a7a42311c9c6f11d644c5e88bcd2","modified":1513224106284},{"_id":"source/_posts/Android之四大组件——Application.md","hash":"aabf1c51e457554111c87e62e37e3e1546c08c93","modified":1508296479956},{"_id":"source/_posts/Android之四大组件——ContentProvider.md","hash":"027d6d18b55744fabe0dd23d150530502493a173","modified":1511496455804},{"_id":"source/_posts/Android之四大组件——Intent.md","hash":"2bb31fc5e53e97843e249c0b5811b8001e1a071a","modified":1513051876803},{"_id":"source/_posts/Android之四大组件——广播.md","hash":"6bf8734dc1337d7e36134527da87e3799671c0f8","modified":1521424786870},{"_id":"source/_posts/Android之四大组件——Service.md","hash":"a409a5e7b9bfcfd9b2bd42e091101547baea4eec","modified":1521184118469},{"_id":"source/_posts/Android之多媒体——Bitmap及图层叠加,裁剪,适配,显示.md","hash":"3d1792cd43d5fee5984bb1ee42571ad0fc248a82","modified":1515656878626},{"_id":"source/_posts/Android之多线程.md","hash":"baaeb5ad1fab93ed28b0154b9e3d8ce4ae04899b","modified":1512977877556},{"_id":"source/_posts/Android之存储——SQLite与其他数据库.md","hash":"84d20302036030444b0524b4ffaa43fd1fe4d456","modified":1517388085157},{"_id":"source/_posts/Android之多进程.md","hash":"d5193a1ceda1e06ccbe8382613f23bc1b26da03e","modified":1521194145317},{"_id":"source/_posts/Android之存储——SharedPreferences.md","hash":"ce15cd197236e32550e15553dad11bc65a537471","modified":1520823082718},{"_id":"source/_posts/Android之存储——其他数据库存储.md","hash":"a2ec086abf4a279bb63530d4b329797f773e4d6f","modified":1517388074621},{"_id":"source/_posts/Android之存储——内存&内存机制.md","hash":"b462e3b4230b08683b13e72c7ec71efad484c7cb","modified":1521106419195},{"_id":"source/_posts/Android之存储——内部存储.md","hash":"f1a6a3f772e1643d7e977227a6f1b6ccfbc50bfd","modified":1517387413574},{"_id":"source/_posts/Android之存储——外部存储.md","hash":"5218a69bc10e6974383fe11191a7ed2aea1a8379","modified":1517387412672},{"_id":"source/_posts/Android之存储——缓存与LruCache.md","hash":"cafbe87ab1a498caf983aebd7705ac065eed5b0d","modified":1516262523816},{"_id":"source/_posts/Android之显示——Fragment,RecyclerView.md","hash":"5534b37efa67aa941bb3298df8257c12955801f4","modified":1521100524717},{"_id":"source/_posts/Android之显示——Menu.md","hash":"d1fab37dd0a8fcb4ff265e9715416cd201976ec4","modified":1507866776873},{"_id":"source/_posts/Android之显示——PopupWindow.md","hash":"83959b6a34cffb4980fcb6e1e80c1453ef0518b4","modified":1506500365085},{"_id":"source/_posts/Android之显示——Notification.md","hash":"fb8f3a4edecfca6a4cc61df843f0cecb621d04a1","modified":1512357538036},{"_id":"source/_posts/Android之显示——Surface,SurfaceView.md","hash":"7ebde797a91d5bfaaec6086cf4a5ee03daeb3441","modified":1516949803968},{"_id":"source/_posts/Android之显示——WindowManager.md","hash":"c74e8d3400458ede5694b77f529d3238d0b47945","modified":1515380276829},{"_id":"source/_posts/Android之权限.md","hash":"bb43fa671508c7e3cd023d1123ad980e415abd27","modified":1503902273844},{"_id":"source/_posts/Android之源码——框架源码分析.md","hash":"74795f0d34ce2771f83c0f5021c9a47d29fc2a13","modified":1521081867502},{"_id":"source/_posts/Android之自定义控件——0.自定义过程.md","hash":"1430620f33fadf2d939628c7052b3f97853b8390","modified":1515569185548},{"_id":"source/_posts/Android之自定义控件——View测量,布局,绘制.md","hash":"35b44ce2547e0e9774ddae9bf904cda2eaf8af7f","modified":1515558050282},{"_id":"source/_posts/Android之自定义控件——Canvas绘制参考.md","hash":"df28033d3d4cdddfa5c733eb50c2ff46934eca40","modified":1520041909217},{"_id":"source/_posts/Android之自定义控件——事件之MotionEvent.md","hash":"fa7318bf93ab3a8d854303a1b47c69f9b80820f4","modified":1521609831729},{"_id":"source/_posts/Android之自定义控件——事件分发,拦截,处理.md","hash":"952b03958387256fdebb06f07cf6508113c927bd","modified":1521609886984},{"_id":"source/_posts/Android之自定义控件——坐标.md","hash":"709ecdfe13afc978cf4d29a2185c66a729da6453","modified":1521609788600},{"_id":"source/_posts/Android之自定义控件——滑动,滚动.md","hash":"574a546be1de7b6055e0ea3e52836b59bbeaea6f","modified":1521609911279},{"_id":"source/_posts/Android之辅助——gradle.md","hash":"5bd2657ac5f3abeb6e25e5ef3c01f9624a851877","modified":1514442871222},{"_id":"source/_posts/Android之虚拟机.md","hash":"8cb6a3ad855789f7041f5c9c8efa37cbdeb5a596","modified":1521190459051},{"_id":"source/_posts/Android之通信——HTTP,HTTPS.md","hash":"b4a5a5ace65becaa7ef977a851b80f156ae5140a","modified":1513131237260},{"_id":"source/_posts/Android之通信——Socket通信.md","hash":"33e44c0e9d0a5dd87358caf55634728c04ec881e","modified":1521186355924},{"_id":"source/_posts/Android之通信——TCP,IP.md","hash":"ddcdf7523824fbdea01f42d17a844f436940d450","modified":1513131315716},{"_id":"source/_posts/Android之通信——UDP.md","hash":"881fb7b2a2219b1eca95ee4aaedd1d1dbdc696ca","modified":1503999849528},{"_id":"source/_posts/Framework 速记2.md","hash":"8eee570368fbeaef0f8ad124eef71db75b4e196b","modified":1503630213638},{"_id":"source/_posts/Framework 速记1.md","hash":"3f0eacbc829a9ad635e0f0c6fd59682677a20c32","modified":1521424786870},{"_id":"source/_posts/错误集锦及更正记录.md","hash":"18756bbf85a9f5ed11f52457d620d68fb2451bbf","modified":1521609727144},{"_id":"source/_posts/代码规范&屏幕适配.md","hash":"4705067202b9b510de12eb8a46e2f18ee86a38d5","modified":1521609693609},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1515072990000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"352093a1b210c72136687fd2eee649244cee402c","modified":1515072990000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1515072990000},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1515072990000},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1515072990000},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1515072990000},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1515072990000},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1515072990000},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1515072990000},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1515072990000},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1515072990000},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1515072990000},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1515072990000},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1515072990000},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1515072990000},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1515072990000},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1515072990000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1515072990000},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1515072990000},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1515072990000},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1515072990000},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1515072990000},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1515072990000},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1515072990000},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1515072990000},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1515072990000},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1515072990000},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1515072990000},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1515072990000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1515072990000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1515072990000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1515072990000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1515072990000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1515072990000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1515072990000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1515072990000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1515072990000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1515072990000},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1515072990000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1515072990000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1515072990000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1515072990000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1515072990000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1515072990000},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1515072990000},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1515072990000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1515072990000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1515072990000},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1515072990000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1515072990000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1515072990000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1515072990000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1515072990000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1515072990000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1515072990000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1515072990000},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1515072990000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1515072990000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1515072990000},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1515072990000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1515072990000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1515072990000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1515072990000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1515072990000},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1515072990000},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1515072990000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1515072990000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1515072990000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1515072990000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1515072990000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1515072990000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1515072990000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1515072990000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1515072990000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1515072990000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1515072990000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1515072990000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1515072990000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1515072990000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1515072990000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1515072990000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1515072990000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1515072990000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1515072990000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1515072990000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1515072990000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1515072990000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1515072990000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1515072990000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1515072990000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1515072990000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1515072990000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1515072990000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1515072990000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1515072990000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1515072990000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1515072990000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1515072990000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1515072990000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1515072990000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1515072990000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1515072990000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1515072990000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1515072990000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1515072990000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1515072990000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1515072990000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1515072990000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1515072990000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1515072990000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1515072990000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1515072990000},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1515072990000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1515072990000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1515072990000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1515072990000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1515072990000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1515072990000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1515072990000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1515072990000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1515072990000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1515072990000},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1515072990000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1515072990000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1515072990000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1515072990000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1515072990000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1515072990000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1515072990000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1515072990000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1515072990000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1515072990000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1515072990000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1515072990000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1515072990000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1515072990000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1515072990000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1515072990000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1515072990000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1515072990000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1515072990000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1515072990000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1515072990000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1515072990000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1515072990000},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1515072990000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1515072990000},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1515072990000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1515072990000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1515072990000},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1515072990000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1515072990000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1515072990000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1515072990000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1515072990000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1515072990000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1515072990000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1515072990000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1515072990000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1515072990000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1515072990000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1515072990000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1515072990000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1515072990000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1515072990000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1515072990000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1515072990000},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1515072990000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1515072990000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1515072990000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1515072990000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1515072990000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1515072990000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1515072990000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1515072990000},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1515072990000},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1515072990000},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1515072990000},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1515072990000},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1515072990000},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1515072990000},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1515072990000},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1515072990000},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1515072990000},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1515072990000},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1515072990000},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1515072990000},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1515072990000},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1515072990000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1515072990000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1515072990000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1515072990000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1515072990000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1515072990000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1515072990000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1515072990000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1515072990000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1515072990000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1515072990000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1515072990000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1515072990000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1515072990000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1515072990000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1515072990000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1515072990000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1515072990000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1515072990000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1515072990000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1515072990000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1515072990000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1515072990000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1515072990000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1515072990000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1515072990000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1515072990000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1515072990000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1515072990000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1515072990000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1515072990000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1515072990000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1515072990000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1515072990000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1515072990000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1515072990000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1515072990000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1515072990000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1515072990000},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1515072990000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1515072990000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1515072990000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1515072990000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1515072990000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1515072990000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1515072990000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1515072990000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1515072990000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1515072990000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1515072990000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1515072990000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1515072990000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1515072990000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1515072990000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1515072990000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1515072990000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1515072990000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1515072990000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1515072990000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1515072990000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1515072990000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1515072990000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1515072990000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1515072990000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1515072990000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1515072990000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1515072990000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1515072990000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1515072990000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1515072990000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1515072990000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1515072990000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1515072990000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1515072990000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1515072990000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1515072990000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1515072990000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1515072990000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1515072990000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1515072990000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1515072990000},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1515072990000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1515072990000},{"_id":"source/_posts/Android之Java基础.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之Kotlin.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之Linux.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之代码框架——MVC,MVP,MVVM.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之发布优化——修复健壮.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之发布优化——加固.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之发布优化——适配.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之多媒体——图像.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之多媒体——VR,AR.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之多媒体——文件.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之多媒体——文档.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之多媒体——直播.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之多媒体——视频.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之多媒体——语音.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之多媒体——音频.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之插件化.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之显示——Dialog.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之显示——Material Design.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之显示——NavigationView.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之显示——StatusBar,ActionBar,Toolbar.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之显示——Theme&Style.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之显示——输入法键盘.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之桌面插件.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之模块——Camera.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之模块——HIFI.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之模块——录音.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之模块——NFC.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之模块——电源.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之模块——系统信息.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之模块——蓝牙.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之模块——闪光灯&通知指示灯.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之模块——震动.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之源码——Framework分析.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213622},{"_id":"source/_posts/Android之源码——三方View源码分析.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213638},{"_id":"source/_posts/Android之源码——原生View源码分析.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1515060415989},{"_id":"source/_posts/Android之算法.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213638},{"_id":"source/_posts/Android之辅助——插件及操作.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213638},{"_id":"source/_posts/Android之通信——文件下载.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213638},{"_id":"source/_posts/Android之通信——断续上传.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213638},{"_id":"source/_posts/Android之通信——网络框架.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503630213638}],"Category":[{"name":"android 总结","_id":"cjf0n0uc50015to4ld5pnrgyo"}],"Data":[],"Page":[],"Post":[{"_content":"","source":"_posts/Android之显示——文字适配.md","raw":"","slug":"Android之显示——文字适配","published":1,"date":"2018-03-21T03:22:18.430Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0kjqe400000s4l5wdcp8s5","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"# DataBinding #\n\n友情链接:\n- [**完全掌握Android Data Binding**](http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0603/2992.html)\n- [**Android官方数据绑定框架DataBinding**](http://blog.csdn.net/jdsjlzx/article/details/48133293)\n- [**Data Binding 用户指南（Android）**](https://segmentfault.com/a/1190000002876984#articleHeader21)\n- [**Android Data Binding（数据绑定）用户指南**](https://www.jianshu.com/p/b1df61a4df77)\n\n\n### 未完全/未理解的内容关键字 ###\n\n1. [ViewStub的使用](https://segmentfault.com/a/1190000002876984#articleHeader22)\n2. [自定义Setter](https://segmentfault.com/a/1190000002876984#articleHeader27)","source":"_posts/Android之DataBinding.md","raw":"# DataBinding #\n\n友情链接:\n- [**完全掌握Android Data Binding**](http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0603/2992.html)\n- [**Android官方数据绑定框架DataBinding**](http://blog.csdn.net/jdsjlzx/article/details/48133293)\n- [**Data Binding 用户指南（Android）**](https://segmentfault.com/a/1190000002876984#articleHeader21)\n- [**Android Data Binding（数据绑定）用户指南**](https://www.jianshu.com/p/b1df61a4df77)\n\n\n### 未完全/未理解的内容关键字 ###\n\n1. [ViewStub的使用](https://segmentfault.com/a/1190000002876984#articleHeader22)\n2. [自定义Setter](https://segmentfault.com/a/1190000002876984#articleHeader27)","slug":"Android之DataBinding","published":1,"date":"2018-03-21T03:22:18.349Z","updated":"2018-03-12T01:27:52.285Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0kjqim00010s4lzn8ngxt3","content":"<h1 id=\"DataBinding\"><a href=\"#DataBinding\" class=\"headerlink\" title=\"DataBinding\"></a>DataBinding</h1><p>友情链接:</p>\n<ul>\n<li><a href=\"http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0603/2992.html\" target=\"_blank\" rel=\"noopener\"><strong>完全掌握Android Data Binding</strong></a></li>\n<li><a href=\"http://blog.csdn.net/jdsjlzx/article/details/48133293\" target=\"_blank\" rel=\"noopener\"><strong>Android官方数据绑定框架DataBinding</strong></a></li>\n<li><a href=\"https://segmentfault.com/a/1190000002876984#articleHeader21\" target=\"_blank\" rel=\"noopener\"><strong>Data Binding 用户指南（Android）</strong></a></li>\n<li><a href=\"https://www.jianshu.com/p/b1df61a4df77\" target=\"_blank\" rel=\"noopener\"><strong>Android Data Binding（数据绑定）用户指南</strong></a></li>\n</ul>\n<h3 id=\"未完全-未理解的内容关键字\"><a href=\"#未完全-未理解的内容关键字\" class=\"headerlink\" title=\"未完全/未理解的内容关键字\"></a>未完全/未理解的内容关键字</h3><ol>\n<li><a href=\"https://segmentfault.com/a/1190000002876984#articleHeader22\" target=\"_blank\" rel=\"noopener\">ViewStub的使用</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000002876984#articleHeader27\" target=\"_blank\" rel=\"noopener\">自定义Setter</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"DataBinding\"><a href=\"#DataBinding\" class=\"headerlink\" title=\"DataBinding\"></a>DataBinding</h1><p>友情链接:</p>\n<ul>\n<li><a href=\"http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0603/2992.html\" target=\"_blank\" rel=\"noopener\"><strong>完全掌握Android Data Binding</strong></a></li>\n<li><a href=\"http://blog.csdn.net/jdsjlzx/article/details/48133293\" target=\"_blank\" rel=\"noopener\"><strong>Android官方数据绑定框架DataBinding</strong></a></li>\n<li><a href=\"https://segmentfault.com/a/1190000002876984#articleHeader21\" target=\"_blank\" rel=\"noopener\"><strong>Data Binding 用户指南（Android）</strong></a></li>\n<li><a href=\"https://www.jianshu.com/p/b1df61a4df77\" target=\"_blank\" rel=\"noopener\"><strong>Android Data Binding（数据绑定）用户指南</strong></a></li>\n</ul>\n<h3 id=\"未完全-未理解的内容关键字\"><a href=\"#未完全-未理解的内容关键字\" class=\"headerlink\" title=\"未完全/未理解的内容关键字\"></a>未完全/未理解的内容关键字</h3><ol>\n<li><a href=\"https://segmentfault.com/a/1190000002876984#articleHeader22\" target=\"_blank\" rel=\"noopener\">ViewStub的使用</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000002876984#articleHeader27\" target=\"_blank\" rel=\"noopener\">自定义Setter</a></li>\n</ol>\n"},{"分类":"1. BitmapDrawable 2. ShapeDrawable 3. LayerDrawable 4. StateListDrawable 5. LevelListDrawable 6. TransitionDrawable 7. InsetDrawable 8. ScaleDrawable 9. ClipDrawabe","_content":"### BitmapDrawable\n表示的就是一张图片，可以直接引用最原始的图片，也可以通过XML来描述，对应的是 `<bitmap>` 标签。\n\n\t<bitmap xmlns:android=\"http://schemas.android.com/apk/res/android\"  \n\t    android:antialias=\"true\"  \n\t    android:dither=\"true\"  \n\t    android:filter=\"true\"  \n\t    android:gravity=\"fill\"  \n\t    android:mipMap=\"true\"  \n\t    android:tileMode=\"clamp\"  \n\t    android:src=\"@mipmap/ic_launcher\"/>  \n\n属性|描述\n-|:-\n`android:src`|resId\n`android:antialias`|开启抗锯齿功能，让图片变平滑，一定程度降低图片清晰度，但是可以忽略不计，一般都开启。\n`android:dither`|是否开启抖动效果。当图片的像素配置和手机屏幕的像素配置不一致的时候，开启选项可以让高质量的图片在低质量的屏幕上保持较好的效果，图片不会过于失真。                                       在Android中创建BitMap一般会选择ARGB_8888模式，即ARGB 4个通道各占8位，这种色彩模式下，一个像素所占的大小为4个字节，一个像素的位数总和越高，图像也就越逼真。一般都开启\n`android:filter`|是否开启过滤效果，当图片尺寸被拉伸或者被压缩时，开启过滤效果可以保持较好的显示效果。\n`android:mipMap`|图片相关处理技术，纹理映射，使用不多。\n`android:gravity`|当图片小于容器的尺寸时，此选项对图片进行定位，不同的选项可以用分隔符组合使用。<br>= \" `top / bottom / left / right` \"： \t图片放在容器顶/底/左/右部，不改变图大小<br>= \" `center / center_vertical / center_horizontal` \"：\t图片在水平和垂直 / 竖直 / 水平 方向居中，不改变大小<br>= \" `fill` \"：  \t图片在水平和竖直方向填充容器，这就是默认值 <br>= \" `fill_vertical / fill_horizontal`\t \"：  \t图片竖直 / 水平方向填充容器 <br>= \" `clip_vertical / clip_horizontal` \"：  \t竖直 / 水平方向的裁剪，较少使用\n`android:tileMode`|平铺模式，默认disable关闭状态<br>=\"`disable`\": 关闭平铺<br>=\"`clamp`\": 将图片四周的像素扩展到周围区域<br>=\"`repeat`\": 重复平铺<br>=\"`mirror`\": 镜像平铺\n\n---\n### ShapeDrawable\n实体类对应的是`GradientDrawable`。\n\n\n---\n### LayerDrawable\n`LayerDrawable`对应的XML标签是`<layer-list>`，表示一种把不同的`Drawable`摆放在不同层次显示一种叠加效果。一个`layer-list`可以包含多个`<item>`标签，每一个`<item>`代表显示一层`Drawable`。一个`<item>`的结构比较简单，常用的属性有`android:top/left/right/bottom `,分别表示在该位置的偏移量，单位为像素。\n还可以通过`Drawable`来引用一个已经存在的`Drawable`资源或者图片。也可以自定义`Drawable`。默认情况，`layer-list`中所有的`Drawable`都会被缩放至`View`的大小，对于`bitmap`来说，通过`gravity`来控制图片的显示效果。\n\n---\n### StateListDrawable\n`StateListDrawable`对应的是`<selector>`标签。**默认的item一般放在最后并且不添加任何状态**，这样当系统在之前的item无法选择的时候，就会匹配默认的item，因为item的默认状态不附带任何状态，所以它可以适配任何状态。\n\n```\n\t<selector xmlns:android=\"http://schemas.android.com/apk/res/android\" \n\t    android:constantSize=\"true\" \n\t    android:dither=\"true\" \n\t    android:variablePadding=\"true\">\n\t    <item android:drawable=\"@drawable/bitmapdrawable\"\n\t        android:state_pressed=\"true\"\n\t        android:state_focused=\"true\"\n\t        android:state_hovered=\"true\"\n\t        android:state_selected=\"true\"\n\t        android:state_checkable=\"true\"\n\t        android:state_checked=\"true\"\n\t        android:state_enabled=\"true\"\n\t        android:state_activated=\"true\"\n\t        android:state_window_focused=\"true\"/>\n\t</selector>\n\n```\n属性|define\n-|:-\n`android:constantSize`|  `StateListDrawable`的固有大小是否不随着其状态的改变而改变。<br>不同的`drawable`存在不同的大小，true表示固有大小不变，false则会随着状态的改变而改变。\n`android:dither`| 是否开启抖动效果，为了获取最好的显示效果。默认值为true。\n`android:variablePadding`| `StateListDrawable`的`padding`表示是否随着其状态的改变而改变，true表示会随着状态改变而改变，false表示内部所有`Drawable`的`padding`的最大值。默认值false，不建议修改此选项。\n\n---\n### LevelListDrawable\n用于多种情况设置不同图片，对应于xml文件中的`<level-list>`标签。通过`minLevel`和`maxLevel`来设置等级，0~10000之间 \n\n```\n\t<level-list xmlns:Android=\"http://schemas.android.com/apk/res/android\">\n\t    <item android:maxLevel=\"0\" android:drawable=\"@drawable/battery_0\" />\n\t    <item android:maxLevel=\"1\" android:drawable=\"@drawable/battery_1\" />\n\t    <item android:maxLevel=\"2\" android:drawable=\"@drawable/battery_2\" />\n\t    <item android:maxLevel=\"3\" android:drawable=\"@drawable/battery_3\" />\n\t    <item android:maxLevel=\"4\" android:drawable=\"@drawable/battery_4\" />\n\t</level-list>\n```\n\n使用方法:\n\n\timageView.getDrawable().setImageLevel(1);\n\n---\n### TransitionDrawable\n![Image](http://img.blog.csdn.net/20170315144111644?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzI3Nzc0MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\nTransitionDrawable对应标签，transition是过渡，转变的意思， 对应于andnorid中的淡入淡出效果 \n\n```\n\n\t<!-- 定义 -->\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<transition xmlns:android=\"http://schemas.android.com/apk/res/android\" >\n\t    <item android:drawable=\"@drawable/shape_drawable_gradient_linear\"/>\n\t    <item android:drawable=\"@drawable/shape_drawable_gradient_radius\"/>\n\t</transition>\n\t\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<shape xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    android:shape=\"rectangle\" >\n\t\n\t    <gradient\n\t        android:centerColor=\"#00ff00\"\n\t        android:endColor=\"#0000ff\"\n\t        android:startColor=\"#ff0000\"\n\t        android:centerX=\"0.5\"\n\t        android:centerY=\"0.5\"\n\t        android:angle=\"0\"\n\t        android:type=\"linear\" />\n\t\n\t</shape>\n\t\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<shape xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    android:shape=\"rectangle\" >\n\t\n\t    <gradient\n\t        android:centerColor=\"#00ff00\"\n\t        android:endColor=\"#0000ff\"\n\t        android:startColor=\"#ff0000\"\n\t        android:gradientRadius=\"60\"\n\t        android:type=\"radial\" />\n\t\n\t</shape>\n\n\t<!-- 使用 -->\n\t<TextView\n\t    android:id=\"@+id/test_transition\"\n\t    android:layout_width=\"100dp\"\n\t    android:layout_height=\"100dp\"\n\t    android:background=\"@drawable/transition_drawable\"\n\t    android:gravity=\"center\"\n\t    android:text=\"\" />\n\n\tView v = findViewById(R.id.test_transition);\n\tTransitionDrawable drawable = (TransitionDrawable) v.getBackground();\n\tdrawable.startTransition(1000);\n\n```\n\n\t拓展： \n\tAndroid Transition Framwork 主要用来做三件事： \n\t1. Activity间的转场动画； \n\t2. 不同Activity或Fragment间元素共享，让交互更连贯； \n\t3. 同一个Activity之间一些View的变换动画。 \n\t参见：http://www.jianshu.com/p/0af52be90ae6\n\n\n---\n### InsetDrawable\n`insetDrawable`对应标签`<inset>`，它可将其他Drawable内嵌到自己当中，适用于当一个view希望自己的背景比自己小的情况.4个属性分别代表上下左右内凹的间距.\n\n\n```\n\n\t<inset xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    android:insetBottom=\"15dp\"\n\t    android:insetLeft=\"15dp\"\n\t    android:insetRight=\"15dp\"\n\t    android:insetTop=\"15dp\" >\n\t\n\t    <shape android:shape=\"rectangle\" >\n\t        <solid android:color=\"#ff0000\" />\n\t    </shape>\n\t</inset>\n\n\n```\n\n---\n### ScaleDrawable \nScaleDrawable对应于xml文件中的`<scale>`标签，可以根据自己的level将指定的drawable缩放到一定比例。\n\n```\n\t<scale xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    android:drawable=\"@color/blue\"\n\t    android:level=\"1\"\n\t    android:scaleGravity=\"center\"\n\t    android:scaleHeight=\"20%\"\n\t    android:scaleWidth=\"20%\" />\n```\n属性|define\n-|:-\n`android:scaleGravity`|相当于gravity属性，缩放之后的效果。\n`android:scaleHeight/scaleWidth`|表示Drawable的缩放比例，20%就是缩放为原来的80%\n` android:level`|**0 < level <= 10000,级别越大,drawable 显示越大,10000时没有缩放效果**\n\n---\n### ClipDrawabe\n`ClipDrawabe`对应于`<clip>`标签，他可以根据自己当前的等级(`level`)来裁剪一个`Drawable`，裁剪方向可以通过`android:clipOrientation`和`android:gravity`两个属性共同控制。\n\n```\n\t<clip xmlns:android=\"http://schemas.android.com/apk/res/android\" \n\tandroid:clipOrientation=\"vertical\\horizontal\" \n\tandroid:drawable=\"@drawable/bitmapdrawable\" \n\tandroid:gravity=\"bottom|top|left|right|center|fill|center_vertical|center_horizontal|fill_vertical|fill_horizontal|clip_vertical|clip_horizontal\" />\n\n```\n- top：将内部的Drawable放在容器的顶部，不改变大小，如果为竖直裁剪，就从底部开始裁剪。\n- bottom：将内部的Drawable放在容器的底部，不改变大小，如果为竖直裁剪，就从顶部开始裁剪。\n- left：默认值。内部Drawable放在容器左边，不改变大小，如果为水平裁剪，就从右边开始裁剪。\n- right：内部Drawable放在容器右边，不改变大小，如果为水平裁剪，就从左边开始裁剪。\n- center_vertical：Drawable在容器中竖直居中，不改变大小，竖直裁剪的时候上下同时开始裁剪。\n- center_horizontal：Drawable水平居中，不改变大小，水平裁剪的时候从左右两边开始裁剪。\n- center：Drawable在水平和竖直方向居中，不改变大小，水平裁剪的时候从左右开始裁剪，竖直裁剪的时候从上下开始裁剪。\n- fill：Drawable在竖直和水平方向填充容器，仅当level=0的时候才有裁剪行为。\n- clip_vertical：附加选项，竖直方向的裁剪，少使用。\n- clip_horizontal：附加选项，水平方向的裁剪，少使用。\n- fill_vertical：Drawable在竖直方向填充，如果为竖直裁剪，仅当ClipDrawable的等级为0时（level=0，完全不可见），才会有裁剪行为。\n- fill_horizontal：Drawable在水平方向填充，如果为水平裁剪，仅当ClipDrawable等级为0时，才能有裁剪行为。\n\n---","source":"_posts/Android之Drawable.md","raw":"# Drawable #\n\n\t分类:\n\t\t1. BitmapDrawable\n\t\t2. ShapeDrawable\n\t\t3. LayerDrawable\n\t\t4. StateListDrawable\n\t\t5. LevelListDrawable\n\t\t6. TransitionDrawable\n\t\t7. InsetDrawable\n\t\t8. ScaleDrawable\n\t\t9. ClipDrawabe\n\t\t\n\n\n---\n### BitmapDrawable\n表示的就是一张图片，可以直接引用最原始的图片，也可以通过XML来描述，对应的是 `<bitmap>` 标签。\n\n\t<bitmap xmlns:android=\"http://schemas.android.com/apk/res/android\"  \n\t    android:antialias=\"true\"  \n\t    android:dither=\"true\"  \n\t    android:filter=\"true\"  \n\t    android:gravity=\"fill\"  \n\t    android:mipMap=\"true\"  \n\t    android:tileMode=\"clamp\"  \n\t    android:src=\"@mipmap/ic_launcher\"/>  \n\n属性|描述\n-|:-\n`android:src`|resId\n`android:antialias`|开启抗锯齿功能，让图片变平滑，一定程度降低图片清晰度，但是可以忽略不计，一般都开启。\n`android:dither`|是否开启抖动效果。当图片的像素配置和手机屏幕的像素配置不一致的时候，开启选项可以让高质量的图片在低质量的屏幕上保持较好的效果，图片不会过于失真。                                       在Android中创建BitMap一般会选择ARGB_8888模式，即ARGB 4个通道各占8位，这种色彩模式下，一个像素所占的大小为4个字节，一个像素的位数总和越高，图像也就越逼真。一般都开启\n`android:filter`|是否开启过滤效果，当图片尺寸被拉伸或者被压缩时，开启过滤效果可以保持较好的显示效果。\n`android:mipMap`|图片相关处理技术，纹理映射，使用不多。\n`android:gravity`|当图片小于容器的尺寸时，此选项对图片进行定位，不同的选项可以用分隔符组合使用。<br>= \" `top / bottom / left / right` \"： \t图片放在容器顶/底/左/右部，不改变图大小<br>= \" `center / center_vertical / center_horizontal` \"：\t图片在水平和垂直 / 竖直 / 水平 方向居中，不改变大小<br>= \" `fill` \"：  \t图片在水平和竖直方向填充容器，这就是默认值 <br>= \" `fill_vertical / fill_horizontal`\t \"：  \t图片竖直 / 水平方向填充容器 <br>= \" `clip_vertical / clip_horizontal` \"：  \t竖直 / 水平方向的裁剪，较少使用\n`android:tileMode`|平铺模式，默认disable关闭状态<br>=\"`disable`\": 关闭平铺<br>=\"`clamp`\": 将图片四周的像素扩展到周围区域<br>=\"`repeat`\": 重复平铺<br>=\"`mirror`\": 镜像平铺\n\n---\n### ShapeDrawable\n实体类对应的是`GradientDrawable`。\n\n\n---\n### LayerDrawable\n`LayerDrawable`对应的XML标签是`<layer-list>`，表示一种把不同的`Drawable`摆放在不同层次显示一种叠加效果。一个`layer-list`可以包含多个`<item>`标签，每一个`<item>`代表显示一层`Drawable`。一个`<item>`的结构比较简单，常用的属性有`android:top/left/right/bottom `,分别表示在该位置的偏移量，单位为像素。\n还可以通过`Drawable`来引用一个已经存在的`Drawable`资源或者图片。也可以自定义`Drawable`。默认情况，`layer-list`中所有的`Drawable`都会被缩放至`View`的大小，对于`bitmap`来说，通过`gravity`来控制图片的显示效果。\n\n---\n### StateListDrawable\n`StateListDrawable`对应的是`<selector>`标签。**默认的item一般放在最后并且不添加任何状态**，这样当系统在之前的item无法选择的时候，就会匹配默认的item，因为item的默认状态不附带任何状态，所以它可以适配任何状态。\n\n```\n\t<selector xmlns:android=\"http://schemas.android.com/apk/res/android\" \n\t    android:constantSize=\"true\" \n\t    android:dither=\"true\" \n\t    android:variablePadding=\"true\">\n\t    <item android:drawable=\"@drawable/bitmapdrawable\"\n\t        android:state_pressed=\"true\"\n\t        android:state_focused=\"true\"\n\t        android:state_hovered=\"true\"\n\t        android:state_selected=\"true\"\n\t        android:state_checkable=\"true\"\n\t        android:state_checked=\"true\"\n\t        android:state_enabled=\"true\"\n\t        android:state_activated=\"true\"\n\t        android:state_window_focused=\"true\"/>\n\t</selector>\n\n```\n属性|define\n-|:-\n`android:constantSize`|  `StateListDrawable`的固有大小是否不随着其状态的改变而改变。<br>不同的`drawable`存在不同的大小，true表示固有大小不变，false则会随着状态的改变而改变。\n`android:dither`| 是否开启抖动效果，为了获取最好的显示效果。默认值为true。\n`android:variablePadding`| `StateListDrawable`的`padding`表示是否随着其状态的改变而改变，true表示会随着状态改变而改变，false表示内部所有`Drawable`的`padding`的最大值。默认值false，不建议修改此选项。\n\n---\n### LevelListDrawable\n用于多种情况设置不同图片，对应于xml文件中的`<level-list>`标签。通过`minLevel`和`maxLevel`来设置等级，0~10000之间 \n\n```\n\t<level-list xmlns:Android=\"http://schemas.android.com/apk/res/android\">\n\t    <item android:maxLevel=\"0\" android:drawable=\"@drawable/battery_0\" />\n\t    <item android:maxLevel=\"1\" android:drawable=\"@drawable/battery_1\" />\n\t    <item android:maxLevel=\"2\" android:drawable=\"@drawable/battery_2\" />\n\t    <item android:maxLevel=\"3\" android:drawable=\"@drawable/battery_3\" />\n\t    <item android:maxLevel=\"4\" android:drawable=\"@drawable/battery_4\" />\n\t</level-list>\n```\n\n使用方法:\n\n\timageView.getDrawable().setImageLevel(1);\n\n---\n### TransitionDrawable\n![Image](http://img.blog.csdn.net/20170315144111644?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzI3Nzc0MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\nTransitionDrawable对应标签，transition是过渡，转变的意思， 对应于andnorid中的淡入淡出效果 \n\n```\n\n\t<!-- 定义 -->\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<transition xmlns:android=\"http://schemas.android.com/apk/res/android\" >\n\t    <item android:drawable=\"@drawable/shape_drawable_gradient_linear\"/>\n\t    <item android:drawable=\"@drawable/shape_drawable_gradient_radius\"/>\n\t</transition>\n\t\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<shape xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    android:shape=\"rectangle\" >\n\t\n\t    <gradient\n\t        android:centerColor=\"#00ff00\"\n\t        android:endColor=\"#0000ff\"\n\t        android:startColor=\"#ff0000\"\n\t        android:centerX=\"0.5\"\n\t        android:centerY=\"0.5\"\n\t        android:angle=\"0\"\n\t        android:type=\"linear\" />\n\t\n\t</shape>\n\t\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<shape xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    android:shape=\"rectangle\" >\n\t\n\t    <gradient\n\t        android:centerColor=\"#00ff00\"\n\t        android:endColor=\"#0000ff\"\n\t        android:startColor=\"#ff0000\"\n\t        android:gradientRadius=\"60\"\n\t        android:type=\"radial\" />\n\t\n\t</shape>\n\n\t<!-- 使用 -->\n\t<TextView\n\t    android:id=\"@+id/test_transition\"\n\t    android:layout_width=\"100dp\"\n\t    android:layout_height=\"100dp\"\n\t    android:background=\"@drawable/transition_drawable\"\n\t    android:gravity=\"center\"\n\t    android:text=\"\" />\n\n\tView v = findViewById(R.id.test_transition);\n\tTransitionDrawable drawable = (TransitionDrawable) v.getBackground();\n\tdrawable.startTransition(1000);\n\n```\n\n\t拓展： \n\tAndroid Transition Framwork 主要用来做三件事： \n\t1. Activity间的转场动画； \n\t2. 不同Activity或Fragment间元素共享，让交互更连贯； \n\t3. 同一个Activity之间一些View的变换动画。 \n\t参见：http://www.jianshu.com/p/0af52be90ae6\n\n\n---\n### InsetDrawable\n`insetDrawable`对应标签`<inset>`，它可将其他Drawable内嵌到自己当中，适用于当一个view希望自己的背景比自己小的情况.4个属性分别代表上下左右内凹的间距.\n\n\n```\n\n\t<inset xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    android:insetBottom=\"15dp\"\n\t    android:insetLeft=\"15dp\"\n\t    android:insetRight=\"15dp\"\n\t    android:insetTop=\"15dp\" >\n\t\n\t    <shape android:shape=\"rectangle\" >\n\t        <solid android:color=\"#ff0000\" />\n\t    </shape>\n\t</inset>\n\n\n```\n\n---\n### ScaleDrawable \nScaleDrawable对应于xml文件中的`<scale>`标签，可以根据自己的level将指定的drawable缩放到一定比例。\n\n```\n\t<scale xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    android:drawable=\"@color/blue\"\n\t    android:level=\"1\"\n\t    android:scaleGravity=\"center\"\n\t    android:scaleHeight=\"20%\"\n\t    android:scaleWidth=\"20%\" />\n```\n属性|define\n-|:-\n`android:scaleGravity`|相当于gravity属性，缩放之后的效果。\n`android:scaleHeight/scaleWidth`|表示Drawable的缩放比例，20%就是缩放为原来的80%\n` android:level`|**0 < level <= 10000,级别越大,drawable 显示越大,10000时没有缩放效果**\n\n---\n### ClipDrawabe\n`ClipDrawabe`对应于`<clip>`标签，他可以根据自己当前的等级(`level`)来裁剪一个`Drawable`，裁剪方向可以通过`android:clipOrientation`和`android:gravity`两个属性共同控制。\n\n```\n\t<clip xmlns:android=\"http://schemas.android.com/apk/res/android\" \n\tandroid:clipOrientation=\"vertical\\horizontal\" \n\tandroid:drawable=\"@drawable/bitmapdrawable\" \n\tandroid:gravity=\"bottom|top|left|right|center|fill|center_vertical|center_horizontal|fill_vertical|fill_horizontal|clip_vertical|clip_horizontal\" />\n\n```\n- top：将内部的Drawable放在容器的顶部，不改变大小，如果为竖直裁剪，就从底部开始裁剪。\n- bottom：将内部的Drawable放在容器的底部，不改变大小，如果为竖直裁剪，就从顶部开始裁剪。\n- left：默认值。内部Drawable放在容器左边，不改变大小，如果为水平裁剪，就从右边开始裁剪。\n- right：内部Drawable放在容器右边，不改变大小，如果为水平裁剪，就从左边开始裁剪。\n- center_vertical：Drawable在容器中竖直居中，不改变大小，竖直裁剪的时候上下同时开始裁剪。\n- center_horizontal：Drawable水平居中，不改变大小，水平裁剪的时候从左右两边开始裁剪。\n- center：Drawable在水平和竖直方向居中，不改变大小，水平裁剪的时候从左右开始裁剪，竖直裁剪的时候从上下开始裁剪。\n- fill：Drawable在竖直和水平方向填充容器，仅当level=0的时候才有裁剪行为。\n- clip_vertical：附加选项，竖直方向的裁剪，少使用。\n- clip_horizontal：附加选项，水平方向的裁剪，少使用。\n- fill_vertical：Drawable在竖直方向填充，如果为竖直裁剪，仅当ClipDrawable的等级为0时（level=0，完全不可见），才会有裁剪行为。\n- fill_horizontal：Drawable在水平方向填充，如果为水平裁剪，仅当ClipDrawable等级为0时，才能有裁剪行为。\n\n---","slug":"Android之Drawable","published":1,"date":"2018-03-21T03:22:18.350Z","updated":"2017-12-26T09:33:01.220Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0kjqit00020s4le60x54ko","content":"<h3 id=\"BitmapDrawable\"><a href=\"#BitmapDrawable\" class=\"headerlink\" title=\"BitmapDrawable\"></a>BitmapDrawable</h3><p>表示的就是一张图片，可以直接引用最原始的图片，也可以通过XML来描述，对应的是 <code>&lt;bitmap&gt;</code> 标签。</p>\n<pre><code>&lt;bitmap xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  \n    android:antialias=&quot;true&quot;  \n    android:dither=&quot;true&quot;  \n    android:filter=&quot;true&quot;  \n    android:gravity=&quot;fill&quot;  \n    android:mipMap=&quot;true&quot;  \n    android:tileMode=&quot;clamp&quot;  \n    android:src=&quot;@mipmap/ic_launcher&quot;/&gt;  \n</code></pre><table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>android:src</code></td>\n<td style=\"text-align:left\">resId</td>\n</tr>\n<tr>\n<td><code>android:antialias</code></td>\n<td style=\"text-align:left\">开启抗锯齿功能，让图片变平滑，一定程度降低图片清晰度，但是可以忽略不计，一般都开启。</td>\n</tr>\n<tr>\n<td><code>android:dither</code></td>\n<td style=\"text-align:left\">是否开启抖动效果。当图片的像素配置和手机屏幕的像素配置不一致的时候，开启选项可以让高质量的图片在低质量的屏幕上保持较好的效果，图片不会过于失真。                                       在Android中创建BitMap一般会选择ARGB_8888模式，即ARGB 4个通道各占8位，这种色彩模式下，一个像素所占的大小为4个字节，一个像素的位数总和越高，图像也就越逼真。一般都开启</td>\n</tr>\n<tr>\n<td><code>android:filter</code></td>\n<td style=\"text-align:left\">是否开启过滤效果，当图片尺寸被拉伸或者被压缩时，开启过滤效果可以保持较好的显示效果。</td>\n</tr>\n<tr>\n<td><code>android:mipMap</code></td>\n<td style=\"text-align:left\">图片相关处理技术，纹理映射，使用不多。</td>\n</tr>\n<tr>\n<td><code>android:gravity</code></td>\n<td style=\"text-align:left\">当图片小于容器的尺寸时，此选项对图片进行定位，不同的选项可以用分隔符组合使用。<br>= “ <code>top / bottom / left / right</code> “：     图片放在容器顶/底/左/右部，不改变图大小<br>= “ <code>center / center_vertical / center_horizontal</code> “：    图片在水平和垂直 / 竖直 / 水平 方向居中，不改变大小<br>= “ <code>fill</code> “：      图片在水平和竖直方向填充容器，这就是默认值 <br>= “ <code>fill_vertical / fill_horizontal</code>     “：      图片竖直 / 水平方向填充容器 <br>= “ <code>clip_vertical / clip_horizontal</code> “：      竖直 / 水平方向的裁剪，较少使用</td>\n</tr>\n<tr>\n<td><code>android:tileMode</code></td>\n<td style=\"text-align:left\">平铺模式，默认disable关闭状态<br>=”<code>disable</code>“: 关闭平铺<br>=”<code>clamp</code>“: 将图片四周的像素扩展到周围区域<br>=”<code>repeat</code>“: 重复平铺<br>=”<code>mirror</code>“: 镜像平铺</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"ShapeDrawable\"><a href=\"#ShapeDrawable\" class=\"headerlink\" title=\"ShapeDrawable\"></a>ShapeDrawable</h3><p>实体类对应的是<code>GradientDrawable</code>。</p>\n<hr>\n<h3 id=\"LayerDrawable\"><a href=\"#LayerDrawable\" class=\"headerlink\" title=\"LayerDrawable\"></a>LayerDrawable</h3><p><code>LayerDrawable</code>对应的XML标签是<code>&lt;layer-list&gt;</code>，表示一种把不同的<code>Drawable</code>摆放在不同层次显示一种叠加效果。一个<code>layer-list</code>可以包含多个<code>&lt;item&gt;</code>标签，每一个<code>&lt;item&gt;</code>代表显示一层<code>Drawable</code>。一个<code>&lt;item&gt;</code>的结构比较简单，常用的属性有<code>android:top/left/right/bottom</code>,分别表示在该位置的偏移量，单位为像素。<br>还可以通过<code>Drawable</code>来引用一个已经存在的<code>Drawable</code>资源或者图片。也可以自定义<code>Drawable</code>。默认情况，<code>layer-list</code>中所有的<code>Drawable</code>都会被缩放至<code>View</code>的大小，对于<code>bitmap</code>来说，通过<code>gravity</code>来控制图片的显示效果。</p>\n<hr>\n<h3 id=\"StateListDrawable\"><a href=\"#StateListDrawable\" class=\"headerlink\" title=\"StateListDrawable\"></a>StateListDrawable</h3><p><code>StateListDrawable</code>对应的是<code>&lt;selector&gt;</code>标签。<strong>默认的item一般放在最后并且不添加任何状态</strong>，这样当系统在之前的item无法选择的时候，就会匹配默认的item，因为item的默认状态不附带任何状态，所以它可以适配任何状态。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; </span><br><span class=\"line\">    android:constantSize=&quot;true&quot; </span><br><span class=\"line\">    android:dither=&quot;true&quot; </span><br><span class=\"line\">    android:variablePadding=&quot;true&quot;&gt;</span><br><span class=\"line\">    &lt;item android:drawable=&quot;@drawable/bitmapdrawable&quot;</span><br><span class=\"line\">        android:state_pressed=&quot;true&quot;</span><br><span class=\"line\">        android:state_focused=&quot;true&quot;</span><br><span class=\"line\">        android:state_hovered=&quot;true&quot;</span><br><span class=\"line\">        android:state_selected=&quot;true&quot;</span><br><span class=\"line\">        android:state_checkable=&quot;true&quot;</span><br><span class=\"line\">        android:state_checked=&quot;true&quot;</span><br><span class=\"line\">        android:state_enabled=&quot;true&quot;</span><br><span class=\"line\">        android:state_activated=&quot;true&quot;</span><br><span class=\"line\">        android:state_window_focused=&quot;true&quot;/&gt;</span><br><span class=\"line\">&lt;/selector&gt;</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:left\">define</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>android:constantSize</code></td>\n<td style=\"text-align:left\"><code>StateListDrawable</code>的固有大小是否不随着其状态的改变而改变。<br>不同的<code>drawable</code>存在不同的大小，true表示固有大小不变，false则会随着状态的改变而改变。</td>\n</tr>\n<tr>\n<td><code>android:dither</code></td>\n<td style=\"text-align:left\">是否开启抖动效果，为了获取最好的显示效果。默认值为true。</td>\n</tr>\n<tr>\n<td><code>android:variablePadding</code></td>\n<td style=\"text-align:left\"><code>StateListDrawable</code>的<code>padding</code>表示是否随着其状态的改变而改变，true表示会随着状态改变而改变，false表示内部所有<code>Drawable</code>的<code>padding</code>的最大值。默认值false，不建议修改此选项。</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"LevelListDrawable\"><a href=\"#LevelListDrawable\" class=\"headerlink\" title=\"LevelListDrawable\"></a>LevelListDrawable</h3><p>用于多种情况设置不同图片，对应于xml文件中的<code>&lt;level-list&gt;</code>标签。通过<code>minLevel</code>和<code>maxLevel</code>来设置等级，0~10000之间 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;level-list xmlns:Android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class=\"line\">    &lt;item android:maxLevel=&quot;0&quot; android:drawable=&quot;@drawable/battery_0&quot; /&gt;</span><br><span class=\"line\">    &lt;item android:maxLevel=&quot;1&quot; android:drawable=&quot;@drawable/battery_1&quot; /&gt;</span><br><span class=\"line\">    &lt;item android:maxLevel=&quot;2&quot; android:drawable=&quot;@drawable/battery_2&quot; /&gt;</span><br><span class=\"line\">    &lt;item android:maxLevel=&quot;3&quot; android:drawable=&quot;@drawable/battery_3&quot; /&gt;</span><br><span class=\"line\">    &lt;item android:maxLevel=&quot;4&quot; android:drawable=&quot;@drawable/battery_4&quot; /&gt;</span><br><span class=\"line\">&lt;/level-list&gt;</span><br></pre></td></tr></table></figure>\n<p>使用方法:</p>\n<pre><code>imageView.getDrawable().setImageLevel(1);\n</code></pre><hr>\n<h3 id=\"TransitionDrawable\"><a href=\"#TransitionDrawable\" class=\"headerlink\" title=\"TransitionDrawable\"></a>TransitionDrawable</h3><p><img src=\"http://img.blog.csdn.net/20170315144111644?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzI3Nzc0MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"Image\"><br>TransitionDrawable对应标签，transition是过渡，转变的意思， 对应于andnorid中的淡入淡出效果 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 定义 --&gt;</span><br><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;transition xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;</span><br><span class=\"line\">    &lt;item android:drawable=&quot;@drawable/shape_drawable_gradient_linear&quot;/&gt;</span><br><span class=\"line\">    &lt;item android:drawable=&quot;@drawable/shape_drawable_gradient_radius&quot;/&gt;</span><br><span class=\"line\">&lt;/transition&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    android:shape=&quot;rectangle&quot; &gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;gradient</span><br><span class=\"line\">        android:centerColor=&quot;#00ff00&quot;</span><br><span class=\"line\">        android:endColor=&quot;#0000ff&quot;</span><br><span class=\"line\">        android:startColor=&quot;#ff0000&quot;</span><br><span class=\"line\">        android:centerX=&quot;0.5&quot;</span><br><span class=\"line\">        android:centerY=&quot;0.5&quot;</span><br><span class=\"line\">        android:angle=&quot;0&quot;</span><br><span class=\"line\">        android:type=&quot;linear&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/shape&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    android:shape=&quot;rectangle&quot; &gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;gradient</span><br><span class=\"line\">        android:centerColor=&quot;#00ff00&quot;</span><br><span class=\"line\">        android:endColor=&quot;#0000ff&quot;</span><br><span class=\"line\">        android:startColor=&quot;#ff0000&quot;</span><br><span class=\"line\">        android:gradientRadius=&quot;60&quot;</span><br><span class=\"line\">        android:type=&quot;radial&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/shape&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 使用 --&gt;</span><br><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:id=&quot;@+id/test_transition&quot;</span><br><span class=\"line\">    android:layout_width=&quot;100dp&quot;</span><br><span class=\"line\">    android:layout_height=&quot;100dp&quot;</span><br><span class=\"line\">    android:background=&quot;@drawable/transition_drawable&quot;</span><br><span class=\"line\">    android:gravity=&quot;center&quot;</span><br><span class=\"line\">    android:text=&quot;&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">View v = findViewById(R.id.test_transition);</span><br><span class=\"line\">TransitionDrawable drawable = (TransitionDrawable) v.getBackground();</span><br><span class=\"line\">drawable.startTransition(1000);</span><br></pre></td></tr></table></figure>\n<pre><code>拓展： \nAndroid Transition Framwork 主要用来做三件事： \n1. Activity间的转场动画； \n2. 不同Activity或Fragment间元素共享，让交互更连贯； \n3. 同一个Activity之间一些View的变换动画。 \n参见：http://www.jianshu.com/p/0af52be90ae6\n</code></pre><hr>\n<h3 id=\"InsetDrawable\"><a href=\"#InsetDrawable\" class=\"headerlink\" title=\"InsetDrawable\"></a>InsetDrawable</h3><p><code>insetDrawable</code>对应标签<code>&lt;inset&gt;</code>，它可将其他Drawable内嵌到自己当中，适用于当一个view希望自己的背景比自己小的情况.4个属性分别代表上下左右内凹的间距.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;inset xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    android:insetBottom=&quot;15dp&quot;</span><br><span class=\"line\">    android:insetLeft=&quot;15dp&quot;</span><br><span class=\"line\">    android:insetRight=&quot;15dp&quot;</span><br><span class=\"line\">    android:insetTop=&quot;15dp&quot; &gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;shape android:shape=&quot;rectangle&quot; &gt;</span><br><span class=\"line\">        &lt;solid android:color=&quot;#ff0000&quot; /&gt;</span><br><span class=\"line\">    &lt;/shape&gt;</span><br><span class=\"line\">&lt;/inset&gt;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"ScaleDrawable\"><a href=\"#ScaleDrawable\" class=\"headerlink\" title=\"ScaleDrawable\"></a>ScaleDrawable</h3><p>ScaleDrawable对应于xml文件中的<code>&lt;scale&gt;</code>标签，可以根据自己的level将指定的drawable缩放到一定比例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    android:drawable=&quot;@color/blue&quot;</span><br><span class=\"line\">    android:level=&quot;1&quot;</span><br><span class=\"line\">    android:scaleGravity=&quot;center&quot;</span><br><span class=\"line\">    android:scaleHeight=&quot;20%&quot;</span><br><span class=\"line\">    android:scaleWidth=&quot;20%&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:left\">define</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>android:scaleGravity</code></td>\n<td style=\"text-align:left\">相当于gravity属性，缩放之后的效果。</td>\n</tr>\n<tr>\n<td><code>android:scaleHeight/scaleWidth</code></td>\n<td style=\"text-align:left\">表示Drawable的缩放比例，20%就是缩放为原来的80%</td>\n</tr>\n<tr>\n<td><code>android:level</code></td>\n<td style=\"text-align:left\"><strong>0 &lt; level &lt;= 10000,级别越大,drawable 显示越大,10000时没有缩放效果</strong></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"ClipDrawabe\"><a href=\"#ClipDrawabe\" class=\"headerlink\" title=\"ClipDrawabe\"></a>ClipDrawabe</h3><p><code>ClipDrawabe</code>对应于<code>&lt;clip&gt;</code>标签，他可以根据自己当前的等级(<code>level</code>)来裁剪一个<code>Drawable</code>，裁剪方向可以通过<code>android:clipOrientation</code>和<code>android:gravity</code>两个属性共同控制。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;clip xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; </span><br><span class=\"line\">android:clipOrientation=&quot;vertical\\horizontal&quot; </span><br><span class=\"line\">android:drawable=&quot;@drawable/bitmapdrawable&quot; </span><br><span class=\"line\">android:gravity=&quot;bottom|top|left|right|center|fill|center_vertical|center_horizontal|fill_vertical|fill_horizontal|clip_vertical|clip_horizontal&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>top：将内部的Drawable放在容器的顶部，不改变大小，如果为竖直裁剪，就从底部开始裁剪。</li>\n<li>bottom：将内部的Drawable放在容器的底部，不改变大小，如果为竖直裁剪，就从顶部开始裁剪。</li>\n<li>left：默认值。内部Drawable放在容器左边，不改变大小，如果为水平裁剪，就从右边开始裁剪。</li>\n<li>right：内部Drawable放在容器右边，不改变大小，如果为水平裁剪，就从左边开始裁剪。</li>\n<li>center_vertical：Drawable在容器中竖直居中，不改变大小，竖直裁剪的时候上下同时开始裁剪。</li>\n<li>center_horizontal：Drawable水平居中，不改变大小，水平裁剪的时候从左右两边开始裁剪。</li>\n<li>center：Drawable在水平和竖直方向居中，不改变大小，水平裁剪的时候从左右开始裁剪，竖直裁剪的时候从上下开始裁剪。</li>\n<li>fill：Drawable在竖直和水平方向填充容器，仅当level=0的时候才有裁剪行为。</li>\n<li>clip_vertical：附加选项，竖直方向的裁剪，少使用。</li>\n<li>clip_horizontal：附加选项，水平方向的裁剪，少使用。</li>\n<li>fill_vertical：Drawable在竖直方向填充，如果为竖直裁剪，仅当ClipDrawable的等级为0时（level=0，完全不可见），才会有裁剪行为。</li>\n<li>fill_horizontal：Drawable在水平方向填充，如果为水平裁剪，仅当ClipDrawable等级为0时，才能有裁剪行为。</li>\n</ul>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"BitmapDrawable\"><a href=\"#BitmapDrawable\" class=\"headerlink\" title=\"BitmapDrawable\"></a>BitmapDrawable</h3><p>表示的就是一张图片，可以直接引用最原始的图片，也可以通过XML来描述，对应的是 <code>&lt;bitmap&gt;</code> 标签。</p>\n<pre><code>&lt;bitmap xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  \n    android:antialias=&quot;true&quot;  \n    android:dither=&quot;true&quot;  \n    android:filter=&quot;true&quot;  \n    android:gravity=&quot;fill&quot;  \n    android:mipMap=&quot;true&quot;  \n    android:tileMode=&quot;clamp&quot;  \n    android:src=&quot;@mipmap/ic_launcher&quot;/&gt;  \n</code></pre><table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>android:src</code></td>\n<td style=\"text-align:left\">resId</td>\n</tr>\n<tr>\n<td><code>android:antialias</code></td>\n<td style=\"text-align:left\">开启抗锯齿功能，让图片变平滑，一定程度降低图片清晰度，但是可以忽略不计，一般都开启。</td>\n</tr>\n<tr>\n<td><code>android:dither</code></td>\n<td style=\"text-align:left\">是否开启抖动效果。当图片的像素配置和手机屏幕的像素配置不一致的时候，开启选项可以让高质量的图片在低质量的屏幕上保持较好的效果，图片不会过于失真。                                       在Android中创建BitMap一般会选择ARGB_8888模式，即ARGB 4个通道各占8位，这种色彩模式下，一个像素所占的大小为4个字节，一个像素的位数总和越高，图像也就越逼真。一般都开启</td>\n</tr>\n<tr>\n<td><code>android:filter</code></td>\n<td style=\"text-align:left\">是否开启过滤效果，当图片尺寸被拉伸或者被压缩时，开启过滤效果可以保持较好的显示效果。</td>\n</tr>\n<tr>\n<td><code>android:mipMap</code></td>\n<td style=\"text-align:left\">图片相关处理技术，纹理映射，使用不多。</td>\n</tr>\n<tr>\n<td><code>android:gravity</code></td>\n<td style=\"text-align:left\">当图片小于容器的尺寸时，此选项对图片进行定位，不同的选项可以用分隔符组合使用。<br>= “ <code>top / bottom / left / right</code> “：     图片放在容器顶/底/左/右部，不改变图大小<br>= “ <code>center / center_vertical / center_horizontal</code> “：    图片在水平和垂直 / 竖直 / 水平 方向居中，不改变大小<br>= “ <code>fill</code> “：      图片在水平和竖直方向填充容器，这就是默认值 <br>= “ <code>fill_vertical / fill_horizontal</code>     “：      图片竖直 / 水平方向填充容器 <br>= “ <code>clip_vertical / clip_horizontal</code> “：      竖直 / 水平方向的裁剪，较少使用</td>\n</tr>\n<tr>\n<td><code>android:tileMode</code></td>\n<td style=\"text-align:left\">平铺模式，默认disable关闭状态<br>=”<code>disable</code>“: 关闭平铺<br>=”<code>clamp</code>“: 将图片四周的像素扩展到周围区域<br>=”<code>repeat</code>“: 重复平铺<br>=”<code>mirror</code>“: 镜像平铺</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"ShapeDrawable\"><a href=\"#ShapeDrawable\" class=\"headerlink\" title=\"ShapeDrawable\"></a>ShapeDrawable</h3><p>实体类对应的是<code>GradientDrawable</code>。</p>\n<hr>\n<h3 id=\"LayerDrawable\"><a href=\"#LayerDrawable\" class=\"headerlink\" title=\"LayerDrawable\"></a>LayerDrawable</h3><p><code>LayerDrawable</code>对应的XML标签是<code>&lt;layer-list&gt;</code>，表示一种把不同的<code>Drawable</code>摆放在不同层次显示一种叠加效果。一个<code>layer-list</code>可以包含多个<code>&lt;item&gt;</code>标签，每一个<code>&lt;item&gt;</code>代表显示一层<code>Drawable</code>。一个<code>&lt;item&gt;</code>的结构比较简单，常用的属性有<code>android:top/left/right/bottom</code>,分别表示在该位置的偏移量，单位为像素。<br>还可以通过<code>Drawable</code>来引用一个已经存在的<code>Drawable</code>资源或者图片。也可以自定义<code>Drawable</code>。默认情况，<code>layer-list</code>中所有的<code>Drawable</code>都会被缩放至<code>View</code>的大小，对于<code>bitmap</code>来说，通过<code>gravity</code>来控制图片的显示效果。</p>\n<hr>\n<h3 id=\"StateListDrawable\"><a href=\"#StateListDrawable\" class=\"headerlink\" title=\"StateListDrawable\"></a>StateListDrawable</h3><p><code>StateListDrawable</code>对应的是<code>&lt;selector&gt;</code>标签。<strong>默认的item一般放在最后并且不添加任何状态</strong>，这样当系统在之前的item无法选择的时候，就会匹配默认的item，因为item的默认状态不附带任何状态，所以它可以适配任何状态。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; </span><br><span class=\"line\">    android:constantSize=&quot;true&quot; </span><br><span class=\"line\">    android:dither=&quot;true&quot; </span><br><span class=\"line\">    android:variablePadding=&quot;true&quot;&gt;</span><br><span class=\"line\">    &lt;item android:drawable=&quot;@drawable/bitmapdrawable&quot;</span><br><span class=\"line\">        android:state_pressed=&quot;true&quot;</span><br><span class=\"line\">        android:state_focused=&quot;true&quot;</span><br><span class=\"line\">        android:state_hovered=&quot;true&quot;</span><br><span class=\"line\">        android:state_selected=&quot;true&quot;</span><br><span class=\"line\">        android:state_checkable=&quot;true&quot;</span><br><span class=\"line\">        android:state_checked=&quot;true&quot;</span><br><span class=\"line\">        android:state_enabled=&quot;true&quot;</span><br><span class=\"line\">        android:state_activated=&quot;true&quot;</span><br><span class=\"line\">        android:state_window_focused=&quot;true&quot;/&gt;</span><br><span class=\"line\">&lt;/selector&gt;</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:left\">define</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>android:constantSize</code></td>\n<td style=\"text-align:left\"><code>StateListDrawable</code>的固有大小是否不随着其状态的改变而改变。<br>不同的<code>drawable</code>存在不同的大小，true表示固有大小不变，false则会随着状态的改变而改变。</td>\n</tr>\n<tr>\n<td><code>android:dither</code></td>\n<td style=\"text-align:left\">是否开启抖动效果，为了获取最好的显示效果。默认值为true。</td>\n</tr>\n<tr>\n<td><code>android:variablePadding</code></td>\n<td style=\"text-align:left\"><code>StateListDrawable</code>的<code>padding</code>表示是否随着其状态的改变而改变，true表示会随着状态改变而改变，false表示内部所有<code>Drawable</code>的<code>padding</code>的最大值。默认值false，不建议修改此选项。</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"LevelListDrawable\"><a href=\"#LevelListDrawable\" class=\"headerlink\" title=\"LevelListDrawable\"></a>LevelListDrawable</h3><p>用于多种情况设置不同图片，对应于xml文件中的<code>&lt;level-list&gt;</code>标签。通过<code>minLevel</code>和<code>maxLevel</code>来设置等级，0~10000之间 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;level-list xmlns:Android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class=\"line\">    &lt;item android:maxLevel=&quot;0&quot; android:drawable=&quot;@drawable/battery_0&quot; /&gt;</span><br><span class=\"line\">    &lt;item android:maxLevel=&quot;1&quot; android:drawable=&quot;@drawable/battery_1&quot; /&gt;</span><br><span class=\"line\">    &lt;item android:maxLevel=&quot;2&quot; android:drawable=&quot;@drawable/battery_2&quot; /&gt;</span><br><span class=\"line\">    &lt;item android:maxLevel=&quot;3&quot; android:drawable=&quot;@drawable/battery_3&quot; /&gt;</span><br><span class=\"line\">    &lt;item android:maxLevel=&quot;4&quot; android:drawable=&quot;@drawable/battery_4&quot; /&gt;</span><br><span class=\"line\">&lt;/level-list&gt;</span><br></pre></td></tr></table></figure>\n<p>使用方法:</p>\n<pre><code>imageView.getDrawable().setImageLevel(1);\n</code></pre><hr>\n<h3 id=\"TransitionDrawable\"><a href=\"#TransitionDrawable\" class=\"headerlink\" title=\"TransitionDrawable\"></a>TransitionDrawable</h3><p><img src=\"http://img.blog.csdn.net/20170315144111644?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzI3Nzc0MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"Image\"><br>TransitionDrawable对应标签，transition是过渡，转变的意思， 对应于andnorid中的淡入淡出效果 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 定义 --&gt;</span><br><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;transition xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;</span><br><span class=\"line\">    &lt;item android:drawable=&quot;@drawable/shape_drawable_gradient_linear&quot;/&gt;</span><br><span class=\"line\">    &lt;item android:drawable=&quot;@drawable/shape_drawable_gradient_radius&quot;/&gt;</span><br><span class=\"line\">&lt;/transition&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    android:shape=&quot;rectangle&quot; &gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;gradient</span><br><span class=\"line\">        android:centerColor=&quot;#00ff00&quot;</span><br><span class=\"line\">        android:endColor=&quot;#0000ff&quot;</span><br><span class=\"line\">        android:startColor=&quot;#ff0000&quot;</span><br><span class=\"line\">        android:centerX=&quot;0.5&quot;</span><br><span class=\"line\">        android:centerY=&quot;0.5&quot;</span><br><span class=\"line\">        android:angle=&quot;0&quot;</span><br><span class=\"line\">        android:type=&quot;linear&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/shape&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    android:shape=&quot;rectangle&quot; &gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;gradient</span><br><span class=\"line\">        android:centerColor=&quot;#00ff00&quot;</span><br><span class=\"line\">        android:endColor=&quot;#0000ff&quot;</span><br><span class=\"line\">        android:startColor=&quot;#ff0000&quot;</span><br><span class=\"line\">        android:gradientRadius=&quot;60&quot;</span><br><span class=\"line\">        android:type=&quot;radial&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/shape&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 使用 --&gt;</span><br><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:id=&quot;@+id/test_transition&quot;</span><br><span class=\"line\">    android:layout_width=&quot;100dp&quot;</span><br><span class=\"line\">    android:layout_height=&quot;100dp&quot;</span><br><span class=\"line\">    android:background=&quot;@drawable/transition_drawable&quot;</span><br><span class=\"line\">    android:gravity=&quot;center&quot;</span><br><span class=\"line\">    android:text=&quot;&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">View v = findViewById(R.id.test_transition);</span><br><span class=\"line\">TransitionDrawable drawable = (TransitionDrawable) v.getBackground();</span><br><span class=\"line\">drawable.startTransition(1000);</span><br></pre></td></tr></table></figure>\n<pre><code>拓展： \nAndroid Transition Framwork 主要用来做三件事： \n1. Activity间的转场动画； \n2. 不同Activity或Fragment间元素共享，让交互更连贯； \n3. 同一个Activity之间一些View的变换动画。 \n参见：http://www.jianshu.com/p/0af52be90ae6\n</code></pre><hr>\n<h3 id=\"InsetDrawable\"><a href=\"#InsetDrawable\" class=\"headerlink\" title=\"InsetDrawable\"></a>InsetDrawable</h3><p><code>insetDrawable</code>对应标签<code>&lt;inset&gt;</code>，它可将其他Drawable内嵌到自己当中，适用于当一个view希望自己的背景比自己小的情况.4个属性分别代表上下左右内凹的间距.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;inset xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    android:insetBottom=&quot;15dp&quot;</span><br><span class=\"line\">    android:insetLeft=&quot;15dp&quot;</span><br><span class=\"line\">    android:insetRight=&quot;15dp&quot;</span><br><span class=\"line\">    android:insetTop=&quot;15dp&quot; &gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;shape android:shape=&quot;rectangle&quot; &gt;</span><br><span class=\"line\">        &lt;solid android:color=&quot;#ff0000&quot; /&gt;</span><br><span class=\"line\">    &lt;/shape&gt;</span><br><span class=\"line\">&lt;/inset&gt;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"ScaleDrawable\"><a href=\"#ScaleDrawable\" class=\"headerlink\" title=\"ScaleDrawable\"></a>ScaleDrawable</h3><p>ScaleDrawable对应于xml文件中的<code>&lt;scale&gt;</code>标签，可以根据自己的level将指定的drawable缩放到一定比例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    android:drawable=&quot;@color/blue&quot;</span><br><span class=\"line\">    android:level=&quot;1&quot;</span><br><span class=\"line\">    android:scaleGravity=&quot;center&quot;</span><br><span class=\"line\">    android:scaleHeight=&quot;20%&quot;</span><br><span class=\"line\">    android:scaleWidth=&quot;20%&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:left\">define</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>android:scaleGravity</code></td>\n<td style=\"text-align:left\">相当于gravity属性，缩放之后的效果。</td>\n</tr>\n<tr>\n<td><code>android:scaleHeight/scaleWidth</code></td>\n<td style=\"text-align:left\">表示Drawable的缩放比例，20%就是缩放为原来的80%</td>\n</tr>\n<tr>\n<td><code>android:level</code></td>\n<td style=\"text-align:left\"><strong>0 &lt; level &lt;= 10000,级别越大,drawable 显示越大,10000时没有缩放效果</strong></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"ClipDrawabe\"><a href=\"#ClipDrawabe\" class=\"headerlink\" title=\"ClipDrawabe\"></a>ClipDrawabe</h3><p><code>ClipDrawabe</code>对应于<code>&lt;clip&gt;</code>标签，他可以根据自己当前的等级(<code>level</code>)来裁剪一个<code>Drawable</code>，裁剪方向可以通过<code>android:clipOrientation</code>和<code>android:gravity</code>两个属性共同控制。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;clip xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; </span><br><span class=\"line\">android:clipOrientation=&quot;vertical\\horizontal&quot; </span><br><span class=\"line\">android:drawable=&quot;@drawable/bitmapdrawable&quot; </span><br><span class=\"line\">android:gravity=&quot;bottom|top|left|right|center|fill|center_vertical|center_horizontal|fill_vertical|fill_horizontal|clip_vertical|clip_horizontal&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>top：将内部的Drawable放在容器的顶部，不改变大小，如果为竖直裁剪，就从底部开始裁剪。</li>\n<li>bottom：将内部的Drawable放在容器的底部，不改变大小，如果为竖直裁剪，就从顶部开始裁剪。</li>\n<li>left：默认值。内部Drawable放在容器左边，不改变大小，如果为水平裁剪，就从右边开始裁剪。</li>\n<li>right：内部Drawable放在容器右边，不改变大小，如果为水平裁剪，就从左边开始裁剪。</li>\n<li>center_vertical：Drawable在容器中竖直居中，不改变大小，竖直裁剪的时候上下同时开始裁剪。</li>\n<li>center_horizontal：Drawable水平居中，不改变大小，水平裁剪的时候从左右两边开始裁剪。</li>\n<li>center：Drawable在水平和竖直方向居中，不改变大小，水平裁剪的时候从左右开始裁剪，竖直裁剪的时候从上下开始裁剪。</li>\n<li>fill：Drawable在竖直和水平方向填充容器，仅当level=0的时候才有裁剪行为。</li>\n<li>clip_vertical：附加选项，竖直方向的裁剪，少使用。</li>\n<li>clip_horizontal：附加选项，水平方向的裁剪，少使用。</li>\n<li>fill_vertical：Drawable在竖直方向填充，如果为竖直裁剪，仅当ClipDrawable的等级为0时（level=0，完全不可见），才会有裁剪行为。</li>\n<li>fill_horizontal：Drawable在水平方向填充，如果为水平裁剪，仅当ClipDrawable等级为0时，才能有裁剪行为。</li>\n</ul>\n<hr>\n"},{"_content":"# adb命令[Android Debug Bridge]\n\n---\nadb是一个标准的CS结构的工具, 连接开发电脑和调试手机.包含如下几个部分:\n\n- Client端, 运行在PC机. 用来发送adb命令.\n- Deamon守护进程, 运行在调试手机或模拟器中.\n- Server端, 后台进程,运行在开发PC机. 用来管理PC中的Client端和手机的Deamon之间的通信.\n\n\t\t其他命令参考:http://www.jianshu.com/p/5980c8c282ef\n---\n### 基础 ###\n\n\t- adb start-server\n\t\t启动adb服务,如果它没启动的话\n\t- adb kill-server\n\t\t关闭服务\n\t- adb devices\n\t\t查看所连接的设备以及设备所对应的序列号\n\t- adb reboot\n\t\t重启\n\t- adb install xxxx.apk\n\t\t安装apk\n\t\t- adb install -s demo.apk  安装到SD卡\n\t\t- adb install -r xxxx.apk  保留数据和缓存文件，重新安装apk,如果连接了两台设备,\n\t\t则会报错,此时可以添加-s <serialNumber>来处理\n\t- adb uninstall <packagename>\n\t\t卸载app,有时候在手机上卸载App会出现数据清理不干净,导致App再也装不上了,这个时候可以敲命令来卸载\n\t\t- adb uninstall -k <packagename> 保留数据\n\t- adb connect <device-ip-address>\n\t\t连接到指定的ip,这个通常配合wifidebug\n\t- adb pull <remote> <local>\n\t\t从手机复制文件出来,比如把Crash日志写在SD卡上,再pull到电脑上 或者 pull ANR的trace日志\n\t- adb push <local> <remote>\n\t\t向手机发送文件,比如测试热修复补丁~\n\t\teg. adb push foo.txt /sdcard/foo.txt\n\n---\n### 设备信息 ###\n\n\t- adb get-serialno\n\t\t查看序列号\n\t- adb shell  cat /sys/class/net/wlan0/address\n\t\t查看MAC地址\n\t- adb shell getprop ro.product.model\n\t\t查看设备型号\n\t- adb shell getprop ro.build.version.release\n\t\t查看Android系统版本\n\t- adb shell wm size\n\t\t查看屏幕分辨率\n\t- adb shell wm density\n\t\t查看屏幕密度\n---\n### 包管理 \n\n\t- adb shell pm list packages\n\t\t列出手机所有app的包名\n\t\t- adb shell pm list packages -s\t\n\t\t\t系统应用\n\t\t- adb shell pm list packages -3\n\t\t\t系统应用外的其他应用\n\t\t- adb shell pm list packages | grep **\n\t\t\tgrep筛选出包括**的包名\n\n\t- adb shell pm clear <packagename>\n\t\t清除应用的数据\n\n\n\t- adb shell am start -n <packagename>/<packagename>.<activityname>\n\t\t启动某个应用的某个Activity\n\t- adb shell am force-stop <packagename>\n\t\t强制停止某应用\n\n\n---\n### 其他 ###\n\t- adb shell\n\t\t进入shell环境\n\t- adb shell dumpsys activity top\n\t\t查看栈顶Activity,可以用来获取包名,可以用来查看其它app的包名\n\t- adb shell ps\n\t\t查看进程信息\n\t- adb shell pm list packages -f\n\t\t查看所有已安装的应用的包名\n\t- adb shell dumpsys activity\n\t\tdumpsys系列命令可以帮助我们查看各种信息\n\t\tam的状态 Activity Manager State\n\t- adb shell dumpsys package\n\t\t包信息 Package Information\n\t- adb shell dumpsys meminfo\n\t\t内存使用情况Memory Usage\n\t- adb shell cat /proc/cpuinfo\n\t\t查看手机CPU,可以看到手机架构(eg.ARMv7) 和几核处理器\n\t\t可以帮助我们选择so库,排查手机cpu架构相关的问题\n\n---\n### 附录:adb命令英文选项 ###\n\n\n\tglobal options:\n\t -a         listen on all network interfaces, not just localhost\n\t -d         use USB device (error if multiple devices connected)\n\t -e         use TCP/IP device (error if multiple TCP/IP devices available)\n\t -s SERIAL\n\t     use device with given serial number (overrides $ANDROID_SERIAL)\n\t -p PRODUCT\n\t     name or path ('angler'/'out/target/product/angler');\n\t     default $ANDROID_PRODUCT_OUT\n\t -H         name of adb server host [default=localhost]\n\t -P         port of adb server [default=5037]\n\t -L SOCKET  listen on given socket for adb server [default=tcp:localhost:5037]\n\t\n\tgeneral commands:\n\t devices [-l]             list connected devices (-l for long output)\n\t help                     show this help message\n\t version                  show version num\n\t\n\tnetworking:\n\t connect HOST[:PORT]      connect to a device via TCP/IP [default port=5555]\n\t disconnect [HOST[:PORT]]\n\t     disconnect from given TCP/IP device [default port=5555], or all\n\t forward --list           list all forward socket connections\n\t forward [--no-rebind] LOCAL REMOTE\n\t     forward socket connection using:\n\t       tcp:<port> (<local> may be \"tcp:0\" to pick any open port)\n\t       localabstract:<unix domain socket name>\n\t       localreserved:<unix domain socket name>\n\t       localfilesystem:<unix domain socket name>\n\t       dev:<character device name>\n\t       jdwp:<process pid> (remote only)\n\t forward --remove LOCAL   remove specific forward socket connection\n\t forward --remove-all     remove all forward socket connections\n\t ppp TTY [PARAMETER...]   run PPP over USB\n\t reverse --list           list all reverse socket connections from device\n\t reverse [--no-rebind] REMOTE LOCAL\n\t     reverse socket connection using:\n\t       tcp:<port> (<remote> may be \"tcp:0\" to pick any open port)\n\t       localabstract:<unix domain socket name>\n\t       localreserved:<unix domain socket name>\n\t       localfilesystem:<unix domain socket name>\n\t reverse --remove REMOTE  remove specific reverse socket connection\n\t reverse --remove-all     remove all reverse socket connections from device\n\t\n\tfile transfer:\n\t push LOCAL... REMOTE\n\t     copy local files/directories to device\n\t pull [-a] REMOTE... LOCAL\n\t     copy files/dirs from device\n\t     -a: preserve file timestamp and mode\n\t sync [DIR]\n\t     copy all changed files to device; if DIR is \"system\", \"vendor\", \"oem\",\n\t     or \"data\", only sync that partition (default all)\n\t     -l: list but don't copy\n\t\n\tshell:\n\t shell [-e ESCAPE] [-n] [-Tt] [-x] [COMMAND...]\n\t     run remote shell command (interactive shell if no command given)\n\t     -e: choose escape character, or \"none\"; default '~'\n\t     -n: don't read from stdin\n\t     -T: disable PTY allocation\n\t     -t: force PTY allocation\n\t     -x: disable remote exit codes and stdout/stderr separation\n\t emu COMMAND              run emulator console command\n\t\n\tapp installation:\n\t install [-lrtsdg] PACKAGE\n\t install-multiple [-lrtsdpg] PACKAGE...\n\t     push package(s) to the device and install them\n\t     -l: forward lock application\n\t     -r: replace existing application\n\t     -t: allow test packages\n\t     -s: install application on sdcard\n\t     -d: allow version code downgrade (debuggable packages only)\n\t     -p: partial application install (install-multiple only)\n\t     -g: grant all runtime permissions\n\t uninstall [-k] PACKAGE\n\t     remove this app package from the device\n\t     '-k': keep the data and cache directories\n\t\n\tbackup/restore:\n\t backup [-f FILE] [-apk|-noapk] [-obb|-noobb] [-shared|-noshared] [-all] [-system|-nosystem] [PACKAGE...]\n\t     write an archive of the device's data to FILE [default=backup.adb]\n\t     package list optional if -all/-shared are supplied\n\t     -apk/-noapk: do/don't back up .apk files (default -noapk)\n\t     -obb/-noobb: do/don't back up .obb files (default -noobb)\n\t     -shared|-noshared: do/don't back up shared storage (default -noshared)\n\t     -all: back up all installed applications\n\t     -system|-nosystem: include system apps in -all (default -system)\n\t restore FILE             restore device contents from FILE\n\t\n\tdebugging:\n\t bugreport [PATH]\n\t     write bugreport to given PATH [default=bugreport.zip];\n\t     if PATH is a directory, the bug report is saved in that directory.\n\t     devices that don't support zipped bug reports output to stdout.\n\t jdwp                     list pids of processes hosting a JDWP transport\n\t logcat                   show device log (logcat --help for more)\n\t\n\tsecurity:\n\t disable-verity           disable dm-verity checking on userdebug builds\n\t enable-verity            re-enable dm-verity checking on userdebug builds\n\t keygen FILE\n\t     generate adb public/private key; private key stored in FILE,\n\t     public key stored in FILE.pub (existing files overwritten)\n\t\n\tscripting:\n\t wait-for[-TRANSPORT]-STATE\n\t     wait for device to be in the given state\n\t     State: device, recovery, sideload, or bootloader\n\t     Transport: usb, local, or any [default=any]\n\t get-state                print offline | bootloader | device\n\t get-serialno             print <serial-number>\n\t get-devpath              print <device-path>\n\t remount\n\t     remount /system, /vendor, and /oem partitions read-write\n\t reboot [bootloader|recovery|sideload|sideload-auto-reboot]\n\t     reboot the device; defaults to booting system image but\n\t     supports bootloader and recovery too. sideload reboots\n\t     into recovery and automatically starts sideload mode,\n\t     sideload-auto-reboot is the same but reboots after sideloading.\n\t sideload OTAPACKAGE      sideload the given full OTA package\n\t root                     restart adbd with root permissions\n\t unroot                   restart adbd without root permissions\n\t usb                      restart adb server listening on USB\n\t tcpip PORT               restart adb server listening on TCP on PORT\n\t\n\tinternal debugging:\n\t start-server             ensure that there is a server running\n\t kill-server              kill the server if it is running\n\t reconnect                kick connection from host side to force reconnect\n\t reconnect device         kick connection from device side to force reconnect\n\t\n\tenvironment variables:\n\t $ADB_TRACE\n\t     comma-separated list of debug info to log:\n\t     all,adb,sockets,packets,rwx,usb,sync,sysdeps,transport,jdwp\n\t $ADB_VENDOR_KEYS         colon-separated list of keys (files or directories)\n\t $ANDROID_SERIAL          serial number to connect to (see -s)\n\t $ANDROID_LOG_TAGS        tags to be used by logcat (see logcat --help)\n","source":"_posts/Android之adb.md","raw":"# adb命令[Android Debug Bridge]\n\n---\nadb是一个标准的CS结构的工具, 连接开发电脑和调试手机.包含如下几个部分:\n\n- Client端, 运行在PC机. 用来发送adb命令.\n- Deamon守护进程, 运行在调试手机或模拟器中.\n- Server端, 后台进程,运行在开发PC机. 用来管理PC中的Client端和手机的Deamon之间的通信.\n\n\t\t其他命令参考:http://www.jianshu.com/p/5980c8c282ef\n---\n### 基础 ###\n\n\t- adb start-server\n\t\t启动adb服务,如果它没启动的话\n\t- adb kill-server\n\t\t关闭服务\n\t- adb devices\n\t\t查看所连接的设备以及设备所对应的序列号\n\t- adb reboot\n\t\t重启\n\t- adb install xxxx.apk\n\t\t安装apk\n\t\t- adb install -s demo.apk  安装到SD卡\n\t\t- adb install -r xxxx.apk  保留数据和缓存文件，重新安装apk,如果连接了两台设备,\n\t\t则会报错,此时可以添加-s <serialNumber>来处理\n\t- adb uninstall <packagename>\n\t\t卸载app,有时候在手机上卸载App会出现数据清理不干净,导致App再也装不上了,这个时候可以敲命令来卸载\n\t\t- adb uninstall -k <packagename> 保留数据\n\t- adb connect <device-ip-address>\n\t\t连接到指定的ip,这个通常配合wifidebug\n\t- adb pull <remote> <local>\n\t\t从手机复制文件出来,比如把Crash日志写在SD卡上,再pull到电脑上 或者 pull ANR的trace日志\n\t- adb push <local> <remote>\n\t\t向手机发送文件,比如测试热修复补丁~\n\t\teg. adb push foo.txt /sdcard/foo.txt\n\n---\n### 设备信息 ###\n\n\t- adb get-serialno\n\t\t查看序列号\n\t- adb shell  cat /sys/class/net/wlan0/address\n\t\t查看MAC地址\n\t- adb shell getprop ro.product.model\n\t\t查看设备型号\n\t- adb shell getprop ro.build.version.release\n\t\t查看Android系统版本\n\t- adb shell wm size\n\t\t查看屏幕分辨率\n\t- adb shell wm density\n\t\t查看屏幕密度\n---\n### 包管理 \n\n\t- adb shell pm list packages\n\t\t列出手机所有app的包名\n\t\t- adb shell pm list packages -s\t\n\t\t\t系统应用\n\t\t- adb shell pm list packages -3\n\t\t\t系统应用外的其他应用\n\t\t- adb shell pm list packages | grep **\n\t\t\tgrep筛选出包括**的包名\n\n\t- adb shell pm clear <packagename>\n\t\t清除应用的数据\n\n\n\t- adb shell am start -n <packagename>/<packagename>.<activityname>\n\t\t启动某个应用的某个Activity\n\t- adb shell am force-stop <packagename>\n\t\t强制停止某应用\n\n\n---\n### 其他 ###\n\t- adb shell\n\t\t进入shell环境\n\t- adb shell dumpsys activity top\n\t\t查看栈顶Activity,可以用来获取包名,可以用来查看其它app的包名\n\t- adb shell ps\n\t\t查看进程信息\n\t- adb shell pm list packages -f\n\t\t查看所有已安装的应用的包名\n\t- adb shell dumpsys activity\n\t\tdumpsys系列命令可以帮助我们查看各种信息\n\t\tam的状态 Activity Manager State\n\t- adb shell dumpsys package\n\t\t包信息 Package Information\n\t- adb shell dumpsys meminfo\n\t\t内存使用情况Memory Usage\n\t- adb shell cat /proc/cpuinfo\n\t\t查看手机CPU,可以看到手机架构(eg.ARMv7) 和几核处理器\n\t\t可以帮助我们选择so库,排查手机cpu架构相关的问题\n\n---\n### 附录:adb命令英文选项 ###\n\n\n\tglobal options:\n\t -a         listen on all network interfaces, not just localhost\n\t -d         use USB device (error if multiple devices connected)\n\t -e         use TCP/IP device (error if multiple TCP/IP devices available)\n\t -s SERIAL\n\t     use device with given serial number (overrides $ANDROID_SERIAL)\n\t -p PRODUCT\n\t     name or path ('angler'/'out/target/product/angler');\n\t     default $ANDROID_PRODUCT_OUT\n\t -H         name of adb server host [default=localhost]\n\t -P         port of adb server [default=5037]\n\t -L SOCKET  listen on given socket for adb server [default=tcp:localhost:5037]\n\t\n\tgeneral commands:\n\t devices [-l]             list connected devices (-l for long output)\n\t help                     show this help message\n\t version                  show version num\n\t\n\tnetworking:\n\t connect HOST[:PORT]      connect to a device via TCP/IP [default port=5555]\n\t disconnect [HOST[:PORT]]\n\t     disconnect from given TCP/IP device [default port=5555], or all\n\t forward --list           list all forward socket connections\n\t forward [--no-rebind] LOCAL REMOTE\n\t     forward socket connection using:\n\t       tcp:<port> (<local> may be \"tcp:0\" to pick any open port)\n\t       localabstract:<unix domain socket name>\n\t       localreserved:<unix domain socket name>\n\t       localfilesystem:<unix domain socket name>\n\t       dev:<character device name>\n\t       jdwp:<process pid> (remote only)\n\t forward --remove LOCAL   remove specific forward socket connection\n\t forward --remove-all     remove all forward socket connections\n\t ppp TTY [PARAMETER...]   run PPP over USB\n\t reverse --list           list all reverse socket connections from device\n\t reverse [--no-rebind] REMOTE LOCAL\n\t     reverse socket connection using:\n\t       tcp:<port> (<remote> may be \"tcp:0\" to pick any open port)\n\t       localabstract:<unix domain socket name>\n\t       localreserved:<unix domain socket name>\n\t       localfilesystem:<unix domain socket name>\n\t reverse --remove REMOTE  remove specific reverse socket connection\n\t reverse --remove-all     remove all reverse socket connections from device\n\t\n\tfile transfer:\n\t push LOCAL... REMOTE\n\t     copy local files/directories to device\n\t pull [-a] REMOTE... LOCAL\n\t     copy files/dirs from device\n\t     -a: preserve file timestamp and mode\n\t sync [DIR]\n\t     copy all changed files to device; if DIR is \"system\", \"vendor\", \"oem\",\n\t     or \"data\", only sync that partition (default all)\n\t     -l: list but don't copy\n\t\n\tshell:\n\t shell [-e ESCAPE] [-n] [-Tt] [-x] [COMMAND...]\n\t     run remote shell command (interactive shell if no command given)\n\t     -e: choose escape character, or \"none\"; default '~'\n\t     -n: don't read from stdin\n\t     -T: disable PTY allocation\n\t     -t: force PTY allocation\n\t     -x: disable remote exit codes and stdout/stderr separation\n\t emu COMMAND              run emulator console command\n\t\n\tapp installation:\n\t install [-lrtsdg] PACKAGE\n\t install-multiple [-lrtsdpg] PACKAGE...\n\t     push package(s) to the device and install them\n\t     -l: forward lock application\n\t     -r: replace existing application\n\t     -t: allow test packages\n\t     -s: install application on sdcard\n\t     -d: allow version code downgrade (debuggable packages only)\n\t     -p: partial application install (install-multiple only)\n\t     -g: grant all runtime permissions\n\t uninstall [-k] PACKAGE\n\t     remove this app package from the device\n\t     '-k': keep the data and cache directories\n\t\n\tbackup/restore:\n\t backup [-f FILE] [-apk|-noapk] [-obb|-noobb] [-shared|-noshared] [-all] [-system|-nosystem] [PACKAGE...]\n\t     write an archive of the device's data to FILE [default=backup.adb]\n\t     package list optional if -all/-shared are supplied\n\t     -apk/-noapk: do/don't back up .apk files (default -noapk)\n\t     -obb/-noobb: do/don't back up .obb files (default -noobb)\n\t     -shared|-noshared: do/don't back up shared storage (default -noshared)\n\t     -all: back up all installed applications\n\t     -system|-nosystem: include system apps in -all (default -system)\n\t restore FILE             restore device contents from FILE\n\t\n\tdebugging:\n\t bugreport [PATH]\n\t     write bugreport to given PATH [default=bugreport.zip];\n\t     if PATH is a directory, the bug report is saved in that directory.\n\t     devices that don't support zipped bug reports output to stdout.\n\t jdwp                     list pids of processes hosting a JDWP transport\n\t logcat                   show device log (logcat --help for more)\n\t\n\tsecurity:\n\t disable-verity           disable dm-verity checking on userdebug builds\n\t enable-verity            re-enable dm-verity checking on userdebug builds\n\t keygen FILE\n\t     generate adb public/private key; private key stored in FILE,\n\t     public key stored in FILE.pub (existing files overwritten)\n\t\n\tscripting:\n\t wait-for[-TRANSPORT]-STATE\n\t     wait for device to be in the given state\n\t     State: device, recovery, sideload, or bootloader\n\t     Transport: usb, local, or any [default=any]\n\t get-state                print offline | bootloader | device\n\t get-serialno             print <serial-number>\n\t get-devpath              print <device-path>\n\t remount\n\t     remount /system, /vendor, and /oem partitions read-write\n\t reboot [bootloader|recovery|sideload|sideload-auto-reboot]\n\t     reboot the device; defaults to booting system image but\n\t     supports bootloader and recovery too. sideload reboots\n\t     into recovery and automatically starts sideload mode,\n\t     sideload-auto-reboot is the same but reboots after sideloading.\n\t sideload OTAPACKAGE      sideload the given full OTA package\n\t root                     restart adbd with root permissions\n\t unroot                   restart adbd without root permissions\n\t usb                      restart adb server listening on USB\n\t tcpip PORT               restart adb server listening on TCP on PORT\n\t\n\tinternal debugging:\n\t start-server             ensure that there is a server running\n\t kill-server              kill the server if it is running\n\t reconnect                kick connection from host side to force reconnect\n\t reconnect device         kick connection from device side to force reconnect\n\t\n\tenvironment variables:\n\t $ADB_TRACE\n\t     comma-separated list of debug info to log:\n\t     all,adb,sockets,packets,rwx,usb,sync,sysdeps,transport,jdwp\n\t $ADB_VENDOR_KEYS         colon-separated list of keys (files or directories)\n\t $ANDROID_SERIAL          serial number to connect to (see -s)\n\t $ANDROID_LOG_TAGS        tags to be used by logcat (see logcat --help)\n","slug":"Android之adb","published":1,"date":"2018-03-21T03:22:18.347Z","updated":"2017-09-27T09:40:34.613Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0kjqiv00030s4lmr75ws7x","content":"<h1 id=\"adb命令-Android-Debug-Bridge\"><a href=\"#adb命令-Android-Debug-Bridge\" class=\"headerlink\" title=\"adb命令[Android Debug Bridge]\"></a>adb命令[Android Debug Bridge]</h1><hr>\n<p>adb是一个标准的CS结构的工具, 连接开发电脑和调试手机.包含如下几个部分:</p>\n<ul>\n<li>Client端, 运行在PC机. 用来发送adb命令.</li>\n<li>Deamon守护进程, 运行在调试手机或模拟器中.</li>\n<li><p>Server端, 后台进程,运行在开发PC机. 用来管理PC中的Client端和手机的Deamon之间的通信.</p>\n<pre><code>其他命令参考:http://www.jianshu.com/p/5980c8c282ef\n</code></pre></li>\n</ul>\n<hr>\n<h3 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h3><pre><code>- adb start-server\n    启动adb服务,如果它没启动的话\n- adb kill-server\n    关闭服务\n- adb devices\n    查看所连接的设备以及设备所对应的序列号\n- adb reboot\n    重启\n- adb install xxxx.apk\n    安装apk\n    - adb install -s demo.apk  安装到SD卡\n    - adb install -r xxxx.apk  保留数据和缓存文件，重新安装apk,如果连接了两台设备,\n    则会报错,此时可以添加-s &lt;serialNumber&gt;来处理\n- adb uninstall &lt;packagename&gt;\n    卸载app,有时候在手机上卸载App会出现数据清理不干净,导致App再也装不上了,这个时候可以敲命令来卸载\n    - adb uninstall -k &lt;packagename&gt; 保留数据\n- adb connect &lt;device-ip-address&gt;\n    连接到指定的ip,这个通常配合wifidebug\n- adb pull &lt;remote&gt; &lt;local&gt;\n    从手机复制文件出来,比如把Crash日志写在SD卡上,再pull到电脑上 或者 pull ANR的trace日志\n- adb push &lt;local&gt; &lt;remote&gt;\n    向手机发送文件,比如测试热修复补丁~\n    eg. adb push foo.txt /sdcard/foo.txt\n</code></pre><hr>\n<h3 id=\"设备信息\"><a href=\"#设备信息\" class=\"headerlink\" title=\"设备信息\"></a>设备信息</h3><pre><code>- adb get-serialno\n    查看序列号\n- adb shell  cat /sys/class/net/wlan0/address\n    查看MAC地址\n- adb shell getprop ro.product.model\n    查看设备型号\n- adb shell getprop ro.build.version.release\n    查看Android系统版本\n- adb shell wm size\n    查看屏幕分辨率\n- adb shell wm density\n    查看屏幕密度\n</code></pre><hr>\n<h3 id=\"包管理\"><a href=\"#包管理\" class=\"headerlink\" title=\"包管理\"></a>包管理</h3><pre><code>- adb shell pm list packages\n    列出手机所有app的包名\n    - adb shell pm list packages -s    \n        系统应用\n    - adb shell pm list packages -3\n        系统应用外的其他应用\n    - adb shell pm list packages | grep **\n        grep筛选出包括**的包名\n\n- adb shell pm clear &lt;packagename&gt;\n    清除应用的数据\n\n\n- adb shell am start -n &lt;packagename&gt;/&lt;packagename&gt;.&lt;activityname&gt;\n    启动某个应用的某个Activity\n- adb shell am force-stop &lt;packagename&gt;\n    强制停止某应用\n</code></pre><hr>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><pre><code>- adb shell\n    进入shell环境\n- adb shell dumpsys activity top\n    查看栈顶Activity,可以用来获取包名,可以用来查看其它app的包名\n- adb shell ps\n    查看进程信息\n- adb shell pm list packages -f\n    查看所有已安装的应用的包名\n- adb shell dumpsys activity\n    dumpsys系列命令可以帮助我们查看各种信息\n    am的状态 Activity Manager State\n- adb shell dumpsys package\n    包信息 Package Information\n- adb shell dumpsys meminfo\n    内存使用情况Memory Usage\n- adb shell cat /proc/cpuinfo\n    查看手机CPU,可以看到手机架构(eg.ARMv7) 和几核处理器\n    可以帮助我们选择so库,排查手机cpu架构相关的问题\n</code></pre><hr>\n<h3 id=\"附录-adb命令英文选项\"><a href=\"#附录-adb命令英文选项\" class=\"headerlink\" title=\"附录:adb命令英文选项\"></a>附录:adb命令英文选项</h3><pre><code>global options:\n -a         listen on all network interfaces, not just localhost\n -d         use USB device (error if multiple devices connected)\n -e         use TCP/IP device (error if multiple TCP/IP devices available)\n -s SERIAL\n     use device with given serial number (overrides $ANDROID_SERIAL)\n -p PRODUCT\n     name or path (&apos;angler&apos;/&apos;out/target/product/angler&apos;);\n     default $ANDROID_PRODUCT_OUT\n -H         name of adb server host [default=localhost]\n -P         port of adb server [default=5037]\n -L SOCKET  listen on given socket for adb server [default=tcp:localhost:5037]\n\ngeneral commands:\n devices [-l]             list connected devices (-l for long output)\n help                     show this help message\n version                  show version num\n\nnetworking:\n connect HOST[:PORT]      connect to a device via TCP/IP [default port=5555]\n disconnect [HOST[:PORT]]\n     disconnect from given TCP/IP device [default port=5555], or all\n forward --list           list all forward socket connections\n forward [--no-rebind] LOCAL REMOTE\n     forward socket connection using:\n       tcp:&lt;port&gt; (&lt;local&gt; may be &quot;tcp:0&quot; to pick any open port)\n       localabstract:&lt;unix domain socket name&gt;\n       localreserved:&lt;unix domain socket name&gt;\n       localfilesystem:&lt;unix domain socket name&gt;\n       dev:&lt;character device name&gt;\n       jdwp:&lt;process pid&gt; (remote only)\n forward --remove LOCAL   remove specific forward socket connection\n forward --remove-all     remove all forward socket connections\n ppp TTY [PARAMETER...]   run PPP over USB\n reverse --list           list all reverse socket connections from device\n reverse [--no-rebind] REMOTE LOCAL\n     reverse socket connection using:\n       tcp:&lt;port&gt; (&lt;remote&gt; may be &quot;tcp:0&quot; to pick any open port)\n       localabstract:&lt;unix domain socket name&gt;\n       localreserved:&lt;unix domain socket name&gt;\n       localfilesystem:&lt;unix domain socket name&gt;\n reverse --remove REMOTE  remove specific reverse socket connection\n reverse --remove-all     remove all reverse socket connections from device\n\nfile transfer:\n push LOCAL... REMOTE\n     copy local files/directories to device\n pull [-a] REMOTE... LOCAL\n     copy files/dirs from device\n     -a: preserve file timestamp and mode\n sync [DIR]\n     copy all changed files to device; if DIR is &quot;system&quot;, &quot;vendor&quot;, &quot;oem&quot;,\n     or &quot;data&quot;, only sync that partition (default all)\n     -l: list but don&apos;t copy\n\nshell:\n shell [-e ESCAPE] [-n] [-Tt] [-x] [COMMAND...]\n     run remote shell command (interactive shell if no command given)\n     -e: choose escape character, or &quot;none&quot;; default &apos;~&apos;\n     -n: don&apos;t read from stdin\n     -T: disable PTY allocation\n     -t: force PTY allocation\n     -x: disable remote exit codes and stdout/stderr separation\n emu COMMAND              run emulator console command\n\napp installation:\n install [-lrtsdg] PACKAGE\n install-multiple [-lrtsdpg] PACKAGE...\n     push package(s) to the device and install them\n     -l: forward lock application\n     -r: replace existing application\n     -t: allow test packages\n     -s: install application on sdcard\n     -d: allow version code downgrade (debuggable packages only)\n     -p: partial application install (install-multiple only)\n     -g: grant all runtime permissions\n uninstall [-k] PACKAGE\n     remove this app package from the device\n     &apos;-k&apos;: keep the data and cache directories\n\nbackup/restore:\n backup [-f FILE] [-apk|-noapk] [-obb|-noobb] [-shared|-noshared] [-all] [-system|-nosystem] [PACKAGE...]\n     write an archive of the device&apos;s data to FILE [default=backup.adb]\n     package list optional if -all/-shared are supplied\n     -apk/-noapk: do/don&apos;t back up .apk files (default -noapk)\n     -obb/-noobb: do/don&apos;t back up .obb files (default -noobb)\n     -shared|-noshared: do/don&apos;t back up shared storage (default -noshared)\n     -all: back up all installed applications\n     -system|-nosystem: include system apps in -all (default -system)\n restore FILE             restore device contents from FILE\n\ndebugging:\n bugreport [PATH]\n     write bugreport to given PATH [default=bugreport.zip];\n     if PATH is a directory, the bug report is saved in that directory.\n     devices that don&apos;t support zipped bug reports output to stdout.\n jdwp                     list pids of processes hosting a JDWP transport\n logcat                   show device log (logcat --help for more)\n\nsecurity:\n disable-verity           disable dm-verity checking on userdebug builds\n enable-verity            re-enable dm-verity checking on userdebug builds\n keygen FILE\n     generate adb public/private key; private key stored in FILE,\n     public key stored in FILE.pub (existing files overwritten)\n\nscripting:\n wait-for[-TRANSPORT]-STATE\n     wait for device to be in the given state\n     State: device, recovery, sideload, or bootloader\n     Transport: usb, local, or any [default=any]\n get-state                print offline | bootloader | device\n get-serialno             print &lt;serial-number&gt;\n get-devpath              print &lt;device-path&gt;\n remount\n     remount /system, /vendor, and /oem partitions read-write\n reboot [bootloader|recovery|sideload|sideload-auto-reboot]\n     reboot the device; defaults to booting system image but\n     supports bootloader and recovery too. sideload reboots\n     into recovery and automatically starts sideload mode,\n     sideload-auto-reboot is the same but reboots after sideloading.\n sideload OTAPACKAGE      sideload the given full OTA package\n root                     restart adbd with root permissions\n unroot                   restart adbd without root permissions\n usb                      restart adb server listening on USB\n tcpip PORT               restart adb server listening on TCP on PORT\n\ninternal debugging:\n start-server             ensure that there is a server running\n kill-server              kill the server if it is running\n reconnect                kick connection from host side to force reconnect\n reconnect device         kick connection from device side to force reconnect\n\nenvironment variables:\n $ADB_TRACE\n     comma-separated list of debug info to log:\n     all,adb,sockets,packets,rwx,usb,sync,sysdeps,transport,jdwp\n $ADB_VENDOR_KEYS         colon-separated list of keys (files or directories)\n $ANDROID_SERIAL          serial number to connect to (see -s)\n $ANDROID_LOG_TAGS        tags to be used by logcat (see logcat --help)\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"adb命令-Android-Debug-Bridge\"><a href=\"#adb命令-Android-Debug-Bridge\" class=\"headerlink\" title=\"adb命令[Android Debug Bridge]\"></a>adb命令[Android Debug Bridge]</h1><hr>\n<p>adb是一个标准的CS结构的工具, 连接开发电脑和调试手机.包含如下几个部分:</p>\n<ul>\n<li>Client端, 运行在PC机. 用来发送adb命令.</li>\n<li>Deamon守护进程, 运行在调试手机或模拟器中.</li>\n<li><p>Server端, 后台进程,运行在开发PC机. 用来管理PC中的Client端和手机的Deamon之间的通信.</p>\n<pre><code>其他命令参考:http://www.jianshu.com/p/5980c8c282ef\n</code></pre></li>\n</ul>\n<hr>\n<h3 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h3><pre><code>- adb start-server\n    启动adb服务,如果它没启动的话\n- adb kill-server\n    关闭服务\n- adb devices\n    查看所连接的设备以及设备所对应的序列号\n- adb reboot\n    重启\n- adb install xxxx.apk\n    安装apk\n    - adb install -s demo.apk  安装到SD卡\n    - adb install -r xxxx.apk  保留数据和缓存文件，重新安装apk,如果连接了两台设备,\n    则会报错,此时可以添加-s &lt;serialNumber&gt;来处理\n- adb uninstall &lt;packagename&gt;\n    卸载app,有时候在手机上卸载App会出现数据清理不干净,导致App再也装不上了,这个时候可以敲命令来卸载\n    - adb uninstall -k &lt;packagename&gt; 保留数据\n- adb connect &lt;device-ip-address&gt;\n    连接到指定的ip,这个通常配合wifidebug\n- adb pull &lt;remote&gt; &lt;local&gt;\n    从手机复制文件出来,比如把Crash日志写在SD卡上,再pull到电脑上 或者 pull ANR的trace日志\n- adb push &lt;local&gt; &lt;remote&gt;\n    向手机发送文件,比如测试热修复补丁~\n    eg. adb push foo.txt /sdcard/foo.txt\n</code></pre><hr>\n<h3 id=\"设备信息\"><a href=\"#设备信息\" class=\"headerlink\" title=\"设备信息\"></a>设备信息</h3><pre><code>- adb get-serialno\n    查看序列号\n- adb shell  cat /sys/class/net/wlan0/address\n    查看MAC地址\n- adb shell getprop ro.product.model\n    查看设备型号\n- adb shell getprop ro.build.version.release\n    查看Android系统版本\n- adb shell wm size\n    查看屏幕分辨率\n- adb shell wm density\n    查看屏幕密度\n</code></pre><hr>\n<h3 id=\"包管理\"><a href=\"#包管理\" class=\"headerlink\" title=\"包管理\"></a>包管理</h3><pre><code>- adb shell pm list packages\n    列出手机所有app的包名\n    - adb shell pm list packages -s    \n        系统应用\n    - adb shell pm list packages -3\n        系统应用外的其他应用\n    - adb shell pm list packages | grep **\n        grep筛选出包括**的包名\n\n- adb shell pm clear &lt;packagename&gt;\n    清除应用的数据\n\n\n- adb shell am start -n &lt;packagename&gt;/&lt;packagename&gt;.&lt;activityname&gt;\n    启动某个应用的某个Activity\n- adb shell am force-stop &lt;packagename&gt;\n    强制停止某应用\n</code></pre><hr>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><pre><code>- adb shell\n    进入shell环境\n- adb shell dumpsys activity top\n    查看栈顶Activity,可以用来获取包名,可以用来查看其它app的包名\n- adb shell ps\n    查看进程信息\n- adb shell pm list packages -f\n    查看所有已安装的应用的包名\n- adb shell dumpsys activity\n    dumpsys系列命令可以帮助我们查看各种信息\n    am的状态 Activity Manager State\n- adb shell dumpsys package\n    包信息 Package Information\n- adb shell dumpsys meminfo\n    内存使用情况Memory Usage\n- adb shell cat /proc/cpuinfo\n    查看手机CPU,可以看到手机架构(eg.ARMv7) 和几核处理器\n    可以帮助我们选择so库,排查手机cpu架构相关的问题\n</code></pre><hr>\n<h3 id=\"附录-adb命令英文选项\"><a href=\"#附录-adb命令英文选项\" class=\"headerlink\" title=\"附录:adb命令英文选项\"></a>附录:adb命令英文选项</h3><pre><code>global options:\n -a         listen on all network interfaces, not just localhost\n -d         use USB device (error if multiple devices connected)\n -e         use TCP/IP device (error if multiple TCP/IP devices available)\n -s SERIAL\n     use device with given serial number (overrides $ANDROID_SERIAL)\n -p PRODUCT\n     name or path (&apos;angler&apos;/&apos;out/target/product/angler&apos;);\n     default $ANDROID_PRODUCT_OUT\n -H         name of adb server host [default=localhost]\n -P         port of adb server [default=5037]\n -L SOCKET  listen on given socket for adb server [default=tcp:localhost:5037]\n\ngeneral commands:\n devices [-l]             list connected devices (-l for long output)\n help                     show this help message\n version                  show version num\n\nnetworking:\n connect HOST[:PORT]      connect to a device via TCP/IP [default port=5555]\n disconnect [HOST[:PORT]]\n     disconnect from given TCP/IP device [default port=5555], or all\n forward --list           list all forward socket connections\n forward [--no-rebind] LOCAL REMOTE\n     forward socket connection using:\n       tcp:&lt;port&gt; (&lt;local&gt; may be &quot;tcp:0&quot; to pick any open port)\n       localabstract:&lt;unix domain socket name&gt;\n       localreserved:&lt;unix domain socket name&gt;\n       localfilesystem:&lt;unix domain socket name&gt;\n       dev:&lt;character device name&gt;\n       jdwp:&lt;process pid&gt; (remote only)\n forward --remove LOCAL   remove specific forward socket connection\n forward --remove-all     remove all forward socket connections\n ppp TTY [PARAMETER...]   run PPP over USB\n reverse --list           list all reverse socket connections from device\n reverse [--no-rebind] REMOTE LOCAL\n     reverse socket connection using:\n       tcp:&lt;port&gt; (&lt;remote&gt; may be &quot;tcp:0&quot; to pick any open port)\n       localabstract:&lt;unix domain socket name&gt;\n       localreserved:&lt;unix domain socket name&gt;\n       localfilesystem:&lt;unix domain socket name&gt;\n reverse --remove REMOTE  remove specific reverse socket connection\n reverse --remove-all     remove all reverse socket connections from device\n\nfile transfer:\n push LOCAL... REMOTE\n     copy local files/directories to device\n pull [-a] REMOTE... LOCAL\n     copy files/dirs from device\n     -a: preserve file timestamp and mode\n sync [DIR]\n     copy all changed files to device; if DIR is &quot;system&quot;, &quot;vendor&quot;, &quot;oem&quot;,\n     or &quot;data&quot;, only sync that partition (default all)\n     -l: list but don&apos;t copy\n\nshell:\n shell [-e ESCAPE] [-n] [-Tt] [-x] [COMMAND...]\n     run remote shell command (interactive shell if no command given)\n     -e: choose escape character, or &quot;none&quot;; default &apos;~&apos;\n     -n: don&apos;t read from stdin\n     -T: disable PTY allocation\n     -t: force PTY allocation\n     -x: disable remote exit codes and stdout/stderr separation\n emu COMMAND              run emulator console command\n\napp installation:\n install [-lrtsdg] PACKAGE\n install-multiple [-lrtsdpg] PACKAGE...\n     push package(s) to the device and install them\n     -l: forward lock application\n     -r: replace existing application\n     -t: allow test packages\n     -s: install application on sdcard\n     -d: allow version code downgrade (debuggable packages only)\n     -p: partial application install (install-multiple only)\n     -g: grant all runtime permissions\n uninstall [-k] PACKAGE\n     remove this app package from the device\n     &apos;-k&apos;: keep the data and cache directories\n\nbackup/restore:\n backup [-f FILE] [-apk|-noapk] [-obb|-noobb] [-shared|-noshared] [-all] [-system|-nosystem] [PACKAGE...]\n     write an archive of the device&apos;s data to FILE [default=backup.adb]\n     package list optional if -all/-shared are supplied\n     -apk/-noapk: do/don&apos;t back up .apk files (default -noapk)\n     -obb/-noobb: do/don&apos;t back up .obb files (default -noobb)\n     -shared|-noshared: do/don&apos;t back up shared storage (default -noshared)\n     -all: back up all installed applications\n     -system|-nosystem: include system apps in -all (default -system)\n restore FILE             restore device contents from FILE\n\ndebugging:\n bugreport [PATH]\n     write bugreport to given PATH [default=bugreport.zip];\n     if PATH is a directory, the bug report is saved in that directory.\n     devices that don&apos;t support zipped bug reports output to stdout.\n jdwp                     list pids of processes hosting a JDWP transport\n logcat                   show device log (logcat --help for more)\n\nsecurity:\n disable-verity           disable dm-verity checking on userdebug builds\n enable-verity            re-enable dm-verity checking on userdebug builds\n keygen FILE\n     generate adb public/private key; private key stored in FILE,\n     public key stored in FILE.pub (existing files overwritten)\n\nscripting:\n wait-for[-TRANSPORT]-STATE\n     wait for device to be in the given state\n     State: device, recovery, sideload, or bootloader\n     Transport: usb, local, or any [default=any]\n get-state                print offline | bootloader | device\n get-serialno             print &lt;serial-number&gt;\n get-devpath              print &lt;device-path&gt;\n remount\n     remount /system, /vendor, and /oem partitions read-write\n reboot [bootloader|recovery|sideload|sideload-auto-reboot]\n     reboot the device; defaults to booting system image but\n     supports bootloader and recovery too. sideload reboots\n     into recovery and automatically starts sideload mode,\n     sideload-auto-reboot is the same but reboots after sideloading.\n sideload OTAPACKAGE      sideload the given full OTA package\n root                     restart adbd with root permissions\n unroot                   restart adbd without root permissions\n usb                      restart adb server listening on USB\n tcpip PORT               restart adb server listening on TCP on PORT\n\ninternal debugging:\n start-server             ensure that there is a server running\n kill-server              kill the server if it is running\n reconnect                kick connection from host side to force reconnect\n reconnect device         kick connection from device side to force reconnect\n\nenvironment variables:\n $ADB_TRACE\n     comma-separated list of debug info to log:\n     all,adb,sockets,packets,rwx,usb,sync,sysdeps,transport,jdwp\n $ADB_VENDOR_KEYS         colon-separated list of keys (files or directories)\n $ANDROID_SERIAL          serial number to connect to (see -s)\n $ANDROID_LOG_TAGS        tags to be used by logcat (see logcat --help)\n</code></pre>"},{"_content":"# 多渠道打包\n\n\thttp://www.jianshu.com/p/2f2ce33e670f\n\n---\n### Gradle → 友盟 ###\n\n1. 清单文件\n\n\t\t<meta-data android:name=\"UMENG_CHANNEL\" \n\t\t\tandroid:value=\"${UMENG_CHANNEL_VALUE}\"/>\n\n2. 签名配置\n\n\t\tandroid {\n\t\t\tsigningConfigs {\n\t\t\t        config {\n\t\t\t            try {\n\t\t\t                keyAlias 'xigua'\n\t\t\t                keyPassword 'yglxigua'\n\t\t\t                storeFile file('C:/appkey/xigua.jks')\n\t\t\t                storePassword 'yglxigua'\n\t\t\t            } catch (ex) {\n\t\t\t                throw new InvalidUserDataException(ex.toString())\n\t\t\t            }\n\t\t\t        }\n\t\t\t        debug_config {\n\t\t\t            try {\n\t\t\t                keyAlias 'xigua'\n\t\t\t                keyPassword 'yglxigua'\n\t\t\t                storeFile file('C:/appkey/xigua.jks')\n\t\t\t                storePassword 'yglxigua'\n\t\t\t            } catch (ex) {\n\t\t\t                throw new InvalidUserDataException(ex.toString())\n\t\t\t            }\n\t\t\t        }\n\t\t\t    }\n\t\t\t    buildTypes {\n\t\t\t        release {\n\t\t\t            signingConfig signingConfigs.config\n\n\t\t\t            //buildConfigField \"boolean\", \"LOG_DEBUG\", \"false\"\n\t\t\t            //zipAlignEnabled true\n\t\t\t            //minifyEnabled true\n\t\t\t            //清除无用资源\n\t\t\t            //shrinkResources true\n\t\t\t            //proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n\n\t\t\t            applicationVariants.all { variant ->\n\t\t\t                variant.outputs.each { output ->\n\t\t\t                    def outputFile = output.outputFile\n\t\t\t                    if (outputFile != null && outputFile.name.endsWith('.apk')) {\n\t\t\t                        // 输出apk名称为xigua_v1.0_2015-01-15_渠道名.apk\n\t\t\t                        def fileName = \"xigua_v${defaultConfig.versionName}_${releaseTime()}_${variant.productFlavors[0].name}.apk\"\n\t\t\t                        output.outputFile = new File(outputFile.parent, fileName)\n\t\t\t                    }\n\t\t\t                }\n\t\t\t            }\n\t\t\t        }\n\t\t\t        debug {\n\t\t\t            //buildConfigField \"boolean\", \"LOG_DEBUG\", \"true\"\n\t\t\t            //versionNameSuffix \"-debug\"\n\t\t\t            //minifyEnabled false\n\t\t\t            //zipAlignEnabled false\n\t\t\t            //shrinkResources false\n\t\t\t            signingConfig signingConfigs.debug_config\n\t\t\t        }\n\t\t\t    }\n\t\t}\n\n3. 渠道名\n\n\t\tandroid {\n\t\t\tproductFlavors {\n\t\t        mainflavor {}\n\t\t        tencent {}\n\t\t        ali {}\n\t\t        qh360 {}\n\t\t        xiaomi {}\n\t\t\t\tmeizu {}\n\t\t        huawei {}\n\t\t        oppo {}\n\t\t        vivo {}\n\t\t        wandoujia {}\n\t\t        baidu {}\n\t\t    }\n\t\t    productFlavors.all { flavor ->\n\t\t        flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name]\n\t\t    }\n\t\t}\n\n\n4. gradle打包,运行命令行或右侧gradle → projectName → :app  → Tasks → build → assembleRelease\n\n\t\t//运行命令行\n\t\t./gradlew assembleRelease\n\n\t\t\n\n---\n### Python → 美团  ###\n\n\n\n\n\n---","source":"_posts/Android之发布优化——多渠道打包.md","raw":"# 多渠道打包\n\n\thttp://www.jianshu.com/p/2f2ce33e670f\n\n---\n### Gradle → 友盟 ###\n\n1. 清单文件\n\n\t\t<meta-data android:name=\"UMENG_CHANNEL\" \n\t\t\tandroid:value=\"${UMENG_CHANNEL_VALUE}\"/>\n\n2. 签名配置\n\n\t\tandroid {\n\t\t\tsigningConfigs {\n\t\t\t        config {\n\t\t\t            try {\n\t\t\t                keyAlias 'xigua'\n\t\t\t                keyPassword 'yglxigua'\n\t\t\t                storeFile file('C:/appkey/xigua.jks')\n\t\t\t                storePassword 'yglxigua'\n\t\t\t            } catch (ex) {\n\t\t\t                throw new InvalidUserDataException(ex.toString())\n\t\t\t            }\n\t\t\t        }\n\t\t\t        debug_config {\n\t\t\t            try {\n\t\t\t                keyAlias 'xigua'\n\t\t\t                keyPassword 'yglxigua'\n\t\t\t                storeFile file('C:/appkey/xigua.jks')\n\t\t\t                storePassword 'yglxigua'\n\t\t\t            } catch (ex) {\n\t\t\t                throw new InvalidUserDataException(ex.toString())\n\t\t\t            }\n\t\t\t        }\n\t\t\t    }\n\t\t\t    buildTypes {\n\t\t\t        release {\n\t\t\t            signingConfig signingConfigs.config\n\n\t\t\t            //buildConfigField \"boolean\", \"LOG_DEBUG\", \"false\"\n\t\t\t            //zipAlignEnabled true\n\t\t\t            //minifyEnabled true\n\t\t\t            //清除无用资源\n\t\t\t            //shrinkResources true\n\t\t\t            //proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n\n\t\t\t            applicationVariants.all { variant ->\n\t\t\t                variant.outputs.each { output ->\n\t\t\t                    def outputFile = output.outputFile\n\t\t\t                    if (outputFile != null && outputFile.name.endsWith('.apk')) {\n\t\t\t                        // 输出apk名称为xigua_v1.0_2015-01-15_渠道名.apk\n\t\t\t                        def fileName = \"xigua_v${defaultConfig.versionName}_${releaseTime()}_${variant.productFlavors[0].name}.apk\"\n\t\t\t                        output.outputFile = new File(outputFile.parent, fileName)\n\t\t\t                    }\n\t\t\t                }\n\t\t\t            }\n\t\t\t        }\n\t\t\t        debug {\n\t\t\t            //buildConfigField \"boolean\", \"LOG_DEBUG\", \"true\"\n\t\t\t            //versionNameSuffix \"-debug\"\n\t\t\t            //minifyEnabled false\n\t\t\t            //zipAlignEnabled false\n\t\t\t            //shrinkResources false\n\t\t\t            signingConfig signingConfigs.debug_config\n\t\t\t        }\n\t\t\t    }\n\t\t}\n\n3. 渠道名\n\n\t\tandroid {\n\t\t\tproductFlavors {\n\t\t        mainflavor {}\n\t\t        tencent {}\n\t\t        ali {}\n\t\t        qh360 {}\n\t\t        xiaomi {}\n\t\t\t\tmeizu {}\n\t\t        huawei {}\n\t\t        oppo {}\n\t\t        vivo {}\n\t\t        wandoujia {}\n\t\t        baidu {}\n\t\t    }\n\t\t    productFlavors.all { flavor ->\n\t\t        flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name]\n\t\t    }\n\t\t}\n\n\n4. gradle打包,运行命令行或右侧gradle → projectName → :app  → Tasks → build → assembleRelease\n\n\t\t//运行命令行\n\t\t./gradlew assembleRelease\n\n\t\t\n\n---\n### Python → 美团  ###\n\n\n\n\n\n---","slug":"Android之发布优化——多渠道打包","published":1,"date":"2018-03-21T03:22:18.379Z","updated":"2017-09-27T10:05:51.450Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0kjqiw00040s4l7a80ytkh","content":"<h1 id=\"多渠道打包\"><a href=\"#多渠道打包\" class=\"headerlink\" title=\"多渠道打包\"></a>多渠道打包</h1><pre><code>http://www.jianshu.com/p/2f2ce33e670f\n</code></pre><hr>\n<h3 id=\"Gradle-→-友盟\"><a href=\"#Gradle-→-友盟\" class=\"headerlink\" title=\"Gradle → 友盟\"></a>Gradle → 友盟</h3><ol>\n<li><p>清单文件</p>\n<pre><code>&lt;meta-data android:name=&quot;UMENG_CHANNEL&quot; \n    android:value=&quot;${UMENG_CHANNEL_VALUE}&quot;/&gt;\n</code></pre></li>\n<li><p>签名配置</p>\n<pre><code>android {\n    signingConfigs {\n            config {\n                try {\n                    keyAlias &apos;xigua&apos;\n                    keyPassword &apos;yglxigua&apos;\n                    storeFile file(&apos;C:/appkey/xigua.jks&apos;)\n                    storePassword &apos;yglxigua&apos;\n                } catch (ex) {\n                    throw new InvalidUserDataException(ex.toString())\n                }\n            }\n            debug_config {\n                try {\n                    keyAlias &apos;xigua&apos;\n                    keyPassword &apos;yglxigua&apos;\n                    storeFile file(&apos;C:/appkey/xigua.jks&apos;)\n                    storePassword &apos;yglxigua&apos;\n                } catch (ex) {\n                    throw new InvalidUserDataException(ex.toString())\n                }\n            }\n        }\n        buildTypes {\n            release {\n                signingConfig signingConfigs.config\n\n                //buildConfigField &quot;boolean&quot;, &quot;LOG_DEBUG&quot;, &quot;false&quot;\n                //zipAlignEnabled true\n                //minifyEnabled true\n                //清除无用资源\n                //shrinkResources true\n                //proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;\n\n                applicationVariants.all { variant -&gt;\n                    variant.outputs.each { output -&gt;\n                        def outputFile = output.outputFile\n                        if (outputFile != null &amp;&amp; outputFile.name.endsWith(&apos;.apk&apos;)) {\n                            // 输出apk名称为xigua_v1.0_2015-01-15_渠道名.apk\n                            def fileName = &quot;xigua_v${defaultConfig.versionName}_${releaseTime()}_${variant.productFlavors[0].name}.apk&quot;\n                            output.outputFile = new File(outputFile.parent, fileName)\n                        }\n                    }\n                }\n            }\n            debug {\n                //buildConfigField &quot;boolean&quot;, &quot;LOG_DEBUG&quot;, &quot;true&quot;\n                //versionNameSuffix &quot;-debug&quot;\n                //minifyEnabled false\n                //zipAlignEnabled false\n                //shrinkResources false\n                signingConfig signingConfigs.debug_config\n            }\n        }\n}\n</code></pre></li>\n<li><p>渠道名</p>\n<pre><code>android {\n    productFlavors {\n        mainflavor {}\n        tencent {}\n        ali {}\n        qh360 {}\n        xiaomi {}\n        meizu {}\n        huawei {}\n        oppo {}\n        vivo {}\n        wandoujia {}\n        baidu {}\n    }\n    productFlavors.all { flavor -&gt;\n        flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name]\n    }\n}\n</code></pre></li>\n</ol>\n<ol>\n<li><p>gradle打包,运行命令行或右侧gradle → projectName → :app  → Tasks → build → assembleRelease</p>\n<pre><code>//运行命令行\n./gradlew assembleRelease\n</code></pre></li>\n</ol>\n<hr>\n<h3 id=\"Python-→-美团\"><a href=\"#Python-→-美团\" class=\"headerlink\" title=\"Python → 美团\"></a>Python → 美团</h3><hr>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"多渠道打包\"><a href=\"#多渠道打包\" class=\"headerlink\" title=\"多渠道打包\"></a>多渠道打包</h1><pre><code>http://www.jianshu.com/p/2f2ce33e670f\n</code></pre><hr>\n<h3 id=\"Gradle-→-友盟\"><a href=\"#Gradle-→-友盟\" class=\"headerlink\" title=\"Gradle → 友盟\"></a>Gradle → 友盟</h3><ol>\n<li><p>清单文件</p>\n<pre><code>&lt;meta-data android:name=&quot;UMENG_CHANNEL&quot; \n    android:value=&quot;${UMENG_CHANNEL_VALUE}&quot;/&gt;\n</code></pre></li>\n<li><p>签名配置</p>\n<pre><code>android {\n    signingConfigs {\n            config {\n                try {\n                    keyAlias &apos;xigua&apos;\n                    keyPassword &apos;yglxigua&apos;\n                    storeFile file(&apos;C:/appkey/xigua.jks&apos;)\n                    storePassword &apos;yglxigua&apos;\n                } catch (ex) {\n                    throw new InvalidUserDataException(ex.toString())\n                }\n            }\n            debug_config {\n                try {\n                    keyAlias &apos;xigua&apos;\n                    keyPassword &apos;yglxigua&apos;\n                    storeFile file(&apos;C:/appkey/xigua.jks&apos;)\n                    storePassword &apos;yglxigua&apos;\n                } catch (ex) {\n                    throw new InvalidUserDataException(ex.toString())\n                }\n            }\n        }\n        buildTypes {\n            release {\n                signingConfig signingConfigs.config\n\n                //buildConfigField &quot;boolean&quot;, &quot;LOG_DEBUG&quot;, &quot;false&quot;\n                //zipAlignEnabled true\n                //minifyEnabled true\n                //清除无用资源\n                //shrinkResources true\n                //proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;\n\n                applicationVariants.all { variant -&gt;\n                    variant.outputs.each { output -&gt;\n                        def outputFile = output.outputFile\n                        if (outputFile != null &amp;&amp; outputFile.name.endsWith(&apos;.apk&apos;)) {\n                            // 输出apk名称为xigua_v1.0_2015-01-15_渠道名.apk\n                            def fileName = &quot;xigua_v${defaultConfig.versionName}_${releaseTime()}_${variant.productFlavors[0].name}.apk&quot;\n                            output.outputFile = new File(outputFile.parent, fileName)\n                        }\n                    }\n                }\n            }\n            debug {\n                //buildConfigField &quot;boolean&quot;, &quot;LOG_DEBUG&quot;, &quot;true&quot;\n                //versionNameSuffix &quot;-debug&quot;\n                //minifyEnabled false\n                //zipAlignEnabled false\n                //shrinkResources false\n                signingConfig signingConfigs.debug_config\n            }\n        }\n}\n</code></pre></li>\n<li><p>渠道名</p>\n<pre><code>android {\n    productFlavors {\n        mainflavor {}\n        tencent {}\n        ali {}\n        qh360 {}\n        xiaomi {}\n        meizu {}\n        huawei {}\n        oppo {}\n        vivo {}\n        wandoujia {}\n        baidu {}\n    }\n    productFlavors.all { flavor -&gt;\n        flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name]\n    }\n}\n</code></pre></li>\n</ol>\n<ol>\n<li><p>gradle打包,运行命令行或右侧gradle → projectName → :app  → Tasks → build → assembleRelease</p>\n<pre><code>//运行命令行\n./gradlew assembleRelease\n</code></pre></li>\n</ol>\n<hr>\n<h3 id=\"Python-→-美团\"><a href=\"#Python-→-美团\" class=\"headerlink\" title=\"Python → 美团\"></a>Python → 美团</h3><hr>\n"},{"_content":"# Activity #\n\n\n\n## Activity的使用 ##\n\n\n\n\n\n---\n## Activity工作原理 ##\n\n> 备注:\n> 1. `ApplicationThread`: APT,继承自`IApplicationThread`(继承自`IInterface`),`ApplicationThreadNative`;\n> 2. `ActivityThread`:    AT\n> 3. `Instrumentation`:   Ins,仪表仪器;\n> 4. `ActivityManagerNative`: AMN,继承自`Binder`与`IActivityManager`;\n> 5. `ActivityManagerService`:AMS,继承自AMN;\n> 6. `ActivityStackSupervisor`: ASS,Activity栈监测类;\n> 7. `ActivityStack`:AS;\n\n> 8. `IInterface`: `Binder` 基类;\n> 9. `ApplicationThreadNative`:APTN,继承自`Binder`,`IApplicationThread`;\n\n### 启动流程 ###\n\n![Activity 启动流程图](https://i.imgur.com/VKNhWzp.png)\n\n\n\n- Activity的启动流程一般是通过调用startActivity/startActivityForResult来开始的\n\n- Activity的启动流程涉及到多个进程之间的通讯这里主要是ActivityThread与ActivityManagerService之间的通讯\n\n- ActivityThread向ActivityManagerService传递进程间消息通过ActivityManagerNative，ActivityManagerService向ActivityThread进程间传递消息通过IApplicationThread。\n\n- ActivityManagerService接收到应用进程创建Activity的请求之后会执行初始化操作，解析启动模式，保存请求信息等一系列操作。\n\n- ActivityManagerService保存完请求信息之后会将当前系统栈顶的Activity执行onPause操作，并且IApplication进程间通讯告诉应用程序继承执行当前栈顶的Activity的onPause方法；\n\n- ActivityThread接收到SystemServer的消息之后会统一交个自身定义的Handler对象处理分发；\n\n- ActivityThread执行完栈顶的Activity的onPause方法之后会通过ActivityManagerNative执行进程间通讯告诉ActivityManagerService，栈顶Actiity已经执行完成onPause方法，继续执行后续操作；\n\n- ActivityManagerService会继续执行启动Activity的逻辑，这时候会判断需要启动的Activity所属的应用进程是否已经启动，若没有启动则首先会启动这个Activity的应用程序进程；\n\n- ActivityManagerService会通过socket与Zygote继承通讯，并告知Zygote进程fork出一个新的应用程序进程，然后执行ActivityThread的mani方法；\n\n- 在ActivityThead.main方法中执行初始化操作，初始化主线程异步消息，然后通知ActivityManagerService执行进程初始化操作；\n\n- ActivityManagerService会在执行初始化操作的同时检测当前进程是否有需要创建的Activity对象，若有的话，则执行创建操作；\n\n- ActivityManagerService将执行创建Activity的通知告知ActivityThread，然后通过反射机制创建出Activity对象，并执行Activity的onCreate方法，onStart方法，onResume方法；\n\n- ActivityThread执行完成onResume方法之后告知ActivityManagerService onResume执行完成，开始执行栈顶Activity的onStop方法；\n\n- ActivityManagerService开始执行栈顶的onStop方法并告知ActivityThread；\n\n- ActivityThread执行真正的onStop方法；\n\n\n---\n\n\n---","source":"_posts/Android之四大组件——Activity.md","raw":"# Activity #\n\n\n\n## Activity的使用 ##\n\n\n\n\n\n---\n## Activity工作原理 ##\n\n> 备注:\n> 1. `ApplicationThread`: APT,继承自`IApplicationThread`(继承自`IInterface`),`ApplicationThreadNative`;\n> 2. `ActivityThread`:    AT\n> 3. `Instrumentation`:   Ins,仪表仪器;\n> 4. `ActivityManagerNative`: AMN,继承自`Binder`与`IActivityManager`;\n> 5. `ActivityManagerService`:AMS,继承自AMN;\n> 6. `ActivityStackSupervisor`: ASS,Activity栈监测类;\n> 7. `ActivityStack`:AS;\n\n> 8. `IInterface`: `Binder` 基类;\n> 9. `ApplicationThreadNative`:APTN,继承自`Binder`,`IApplicationThread`;\n\n### 启动流程 ###\n\n![Activity 启动流程图](https://i.imgur.com/VKNhWzp.png)\n\n\n\n- Activity的启动流程一般是通过调用startActivity/startActivityForResult来开始的\n\n- Activity的启动流程涉及到多个进程之间的通讯这里主要是ActivityThread与ActivityManagerService之间的通讯\n\n- ActivityThread向ActivityManagerService传递进程间消息通过ActivityManagerNative，ActivityManagerService向ActivityThread进程间传递消息通过IApplicationThread。\n\n- ActivityManagerService接收到应用进程创建Activity的请求之后会执行初始化操作，解析启动模式，保存请求信息等一系列操作。\n\n- ActivityManagerService保存完请求信息之后会将当前系统栈顶的Activity执行onPause操作，并且IApplication进程间通讯告诉应用程序继承执行当前栈顶的Activity的onPause方法；\n\n- ActivityThread接收到SystemServer的消息之后会统一交个自身定义的Handler对象处理分发；\n\n- ActivityThread执行完栈顶的Activity的onPause方法之后会通过ActivityManagerNative执行进程间通讯告诉ActivityManagerService，栈顶Actiity已经执行完成onPause方法，继续执行后续操作；\n\n- ActivityManagerService会继续执行启动Activity的逻辑，这时候会判断需要启动的Activity所属的应用进程是否已经启动，若没有启动则首先会启动这个Activity的应用程序进程；\n\n- ActivityManagerService会通过socket与Zygote继承通讯，并告知Zygote进程fork出一个新的应用程序进程，然后执行ActivityThread的mani方法；\n\n- 在ActivityThead.main方法中执行初始化操作，初始化主线程异步消息，然后通知ActivityManagerService执行进程初始化操作；\n\n- ActivityManagerService会在执行初始化操作的同时检测当前进程是否有需要创建的Activity对象，若有的话，则执行创建操作；\n\n- ActivityManagerService将执行创建Activity的通知告知ActivityThread，然后通过反射机制创建出Activity对象，并执行Activity的onCreate方法，onStart方法，onResume方法；\n\n- ActivityThread执行完成onResume方法之后告知ActivityManagerService onResume执行完成，开始执行栈顶Activity的onStop方法；\n\n- ActivityManagerService开始执行栈顶的onStop方法并告知ActivityThread；\n\n- ActivityThread执行真正的onStop方法；\n\n\n---\n\n\n---","slug":"Android之四大组件——Activity","published":1,"date":"2018-03-21T03:22:18.400Z","updated":"2017-12-14T04:01:46.284Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0kjqiz00050s4le2l5jkxv","content":"<h1 id=\"Activity\"><a href=\"#Activity\" class=\"headerlink\" title=\"Activity\"></a>Activity</h1><h2 id=\"Activity的使用\"><a href=\"#Activity的使用\" class=\"headerlink\" title=\"Activity的使用\"></a>Activity的使用</h2><hr>\n<h2 id=\"Activity工作原理\"><a href=\"#Activity工作原理\" class=\"headerlink\" title=\"Activity工作原理\"></a>Activity工作原理</h2><blockquote>\n<p>备注:</p>\n<ol>\n<li><code>ApplicationThread</code>: APT,继承自<code>IApplicationThread</code>(继承自<code>IInterface</code>),<code>ApplicationThreadNative</code>;</li>\n<li><code>ActivityThread</code>:    AT</li>\n<li><code>Instrumentation</code>:   Ins,仪表仪器;</li>\n<li><code>ActivityManagerNative</code>: AMN,继承自<code>Binder</code>与<code>IActivityManager</code>;</li>\n<li><code>ActivityManagerService</code>:AMS,继承自AMN;</li>\n<li><code>ActivityStackSupervisor</code>: ASS,Activity栈监测类;</li>\n<li><code>ActivityStack</code>:AS;</li>\n</ol>\n</blockquote>\n<blockquote>\n<ol>\n<li><code>IInterface</code>: <code>Binder</code> 基类;</li>\n<li><code>ApplicationThreadNative</code>:APTN,继承自<code>Binder</code>,<code>IApplicationThread</code>;</li>\n</ol>\n</blockquote>\n<h3 id=\"启动流程\"><a href=\"#启动流程\" class=\"headerlink\" title=\"启动流程\"></a>启动流程</h3><p><img src=\"https://i.imgur.com/VKNhWzp.png\" alt=\"Activity 启动流程图\"></p>\n<ul>\n<li><p>Activity的启动流程一般是通过调用startActivity/startActivityForResult来开始的</p>\n</li>\n<li><p>Activity的启动流程涉及到多个进程之间的通讯这里主要是ActivityThread与ActivityManagerService之间的通讯</p>\n</li>\n<li><p>ActivityThread向ActivityManagerService传递进程间消息通过ActivityManagerNative，ActivityManagerService向ActivityThread进程间传递消息通过IApplicationThread。</p>\n</li>\n<li><p>ActivityManagerService接收到应用进程创建Activity的请求之后会执行初始化操作，解析启动模式，保存请求信息等一系列操作。</p>\n</li>\n<li><p>ActivityManagerService保存完请求信息之后会将当前系统栈顶的Activity执行onPause操作，并且IApplication进程间通讯告诉应用程序继承执行当前栈顶的Activity的onPause方法；</p>\n</li>\n<li><p>ActivityThread接收到SystemServer的消息之后会统一交个自身定义的Handler对象处理分发；</p>\n</li>\n<li><p>ActivityThread执行完栈顶的Activity的onPause方法之后会通过ActivityManagerNative执行进程间通讯告诉ActivityManagerService，栈顶Actiity已经执行完成onPause方法，继续执行后续操作；</p>\n</li>\n<li><p>ActivityManagerService会继续执行启动Activity的逻辑，这时候会判断需要启动的Activity所属的应用进程是否已经启动，若没有启动则首先会启动这个Activity的应用程序进程；</p>\n</li>\n<li><p>ActivityManagerService会通过socket与Zygote继承通讯，并告知Zygote进程fork出一个新的应用程序进程，然后执行ActivityThread的mani方法；</p>\n</li>\n<li><p>在ActivityThead.main方法中执行初始化操作，初始化主线程异步消息，然后通知ActivityManagerService执行进程初始化操作；</p>\n</li>\n<li><p>ActivityManagerService会在执行初始化操作的同时检测当前进程是否有需要创建的Activity对象，若有的话，则执行创建操作；</p>\n</li>\n<li><p>ActivityManagerService将执行创建Activity的通知告知ActivityThread，然后通过反射机制创建出Activity对象，并执行Activity的onCreate方法，onStart方法，onResume方法；</p>\n</li>\n<li><p>ActivityThread执行完成onResume方法之后告知ActivityManagerService onResume执行完成，开始执行栈顶Activity的onStop方法；</p>\n</li>\n<li><p>ActivityManagerService开始执行栈顶的onStop方法并告知ActivityThread；</p>\n</li>\n<li><p>ActivityThread执行真正的onStop方法；</p>\n</li>\n</ul>\n<hr>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Activity\"><a href=\"#Activity\" class=\"headerlink\" title=\"Activity\"></a>Activity</h1><h2 id=\"Activity的使用\"><a href=\"#Activity的使用\" class=\"headerlink\" title=\"Activity的使用\"></a>Activity的使用</h2><hr>\n<h2 id=\"Activity工作原理\"><a href=\"#Activity工作原理\" class=\"headerlink\" title=\"Activity工作原理\"></a>Activity工作原理</h2><blockquote>\n<p>备注:</p>\n<ol>\n<li><code>ApplicationThread</code>: APT,继承自<code>IApplicationThread</code>(继承自<code>IInterface</code>),<code>ApplicationThreadNative</code>;</li>\n<li><code>ActivityThread</code>:    AT</li>\n<li><code>Instrumentation</code>:   Ins,仪表仪器;</li>\n<li><code>ActivityManagerNative</code>: AMN,继承自<code>Binder</code>与<code>IActivityManager</code>;</li>\n<li><code>ActivityManagerService</code>:AMS,继承自AMN;</li>\n<li><code>ActivityStackSupervisor</code>: ASS,Activity栈监测类;</li>\n<li><code>ActivityStack</code>:AS;</li>\n</ol>\n</blockquote>\n<blockquote>\n<ol>\n<li><code>IInterface</code>: <code>Binder</code> 基类;</li>\n<li><code>ApplicationThreadNative</code>:APTN,继承自<code>Binder</code>,<code>IApplicationThread</code>;</li>\n</ol>\n</blockquote>\n<h3 id=\"启动流程\"><a href=\"#启动流程\" class=\"headerlink\" title=\"启动流程\"></a>启动流程</h3><p><img src=\"https://i.imgur.com/VKNhWzp.png\" alt=\"Activity 启动流程图\"></p>\n<ul>\n<li><p>Activity的启动流程一般是通过调用startActivity/startActivityForResult来开始的</p>\n</li>\n<li><p>Activity的启动流程涉及到多个进程之间的通讯这里主要是ActivityThread与ActivityManagerService之间的通讯</p>\n</li>\n<li><p>ActivityThread向ActivityManagerService传递进程间消息通过ActivityManagerNative，ActivityManagerService向ActivityThread进程间传递消息通过IApplicationThread。</p>\n</li>\n<li><p>ActivityManagerService接收到应用进程创建Activity的请求之后会执行初始化操作，解析启动模式，保存请求信息等一系列操作。</p>\n</li>\n<li><p>ActivityManagerService保存完请求信息之后会将当前系统栈顶的Activity执行onPause操作，并且IApplication进程间通讯告诉应用程序继承执行当前栈顶的Activity的onPause方法；</p>\n</li>\n<li><p>ActivityThread接收到SystemServer的消息之后会统一交个自身定义的Handler对象处理分发；</p>\n</li>\n<li><p>ActivityThread执行完栈顶的Activity的onPause方法之后会通过ActivityManagerNative执行进程间通讯告诉ActivityManagerService，栈顶Actiity已经执行完成onPause方法，继续执行后续操作；</p>\n</li>\n<li><p>ActivityManagerService会继续执行启动Activity的逻辑，这时候会判断需要启动的Activity所属的应用进程是否已经启动，若没有启动则首先会启动这个Activity的应用程序进程；</p>\n</li>\n<li><p>ActivityManagerService会通过socket与Zygote继承通讯，并告知Zygote进程fork出一个新的应用程序进程，然后执行ActivityThread的mani方法；</p>\n</li>\n<li><p>在ActivityThead.main方法中执行初始化操作，初始化主线程异步消息，然后通知ActivityManagerService执行进程初始化操作；</p>\n</li>\n<li><p>ActivityManagerService会在执行初始化操作的同时检测当前进程是否有需要创建的Activity对象，若有的话，则执行创建操作；</p>\n</li>\n<li><p>ActivityManagerService将执行创建Activity的通知告知ActivityThread，然后通过反射机制创建出Activity对象，并执行Activity的onCreate方法，onStart方法，onResume方法；</p>\n</li>\n<li><p>ActivityThread执行完成onResume方法之后告知ActivityManagerService onResume执行完成，开始执行栈顶Activity的onStop方法；</p>\n</li>\n<li><p>ActivityManagerService开始执行栈顶的onStop方法并告知ActivityThread；</p>\n</li>\n<li><p>ActivityThread执行真正的onStop方法；</p>\n</li>\n</ul>\n<hr>\n<hr>\n"},{"_content":"# BroadcastReceiver\n---\n<font color=\"red\"> **`BroadcastReceiver` 没有停止的概念** </font>\n\n![广播动态注册与订阅过程](https://i.imgur.com/tSKOkk1.png)\n\n### BroadcastReceiver安全问题 ###\n`BroadcastReceiver`设计的初衷是**从全局考虑可以方便应用程序和系统、应用程序之间、应用程序内的通信**，所以对单个应用程序而言`BroadcastReceiver`是存在安全性问题的(**恶意程序脚本不断的去发送你所接收的广播**)。\n\n#### 发送\n\n\t通过类似sendBroadcast(Intent, String)的接口在发送广播时指定接收者\n\t必须具备的permission或通过Intent.setPackage设置广播仅对某个程序有效。\n\n#### 接收\n当应用程序注册了某个广播时，即便设置了IntentFilter还是会接收到来自其他应用程序的广播进行匹配判断。\n\n\t动态注册 \t通过类似registerReceiver(BroadcastReceiver, IntentFilter,\n\t\t \t\tString, android.os.Handler)的接口指定发送者必须具备的permission。\n\n\t静态注册 \t通过android:exported=\"false\"属性表示接收者对外部应用程序不可用，\n\t\t\t\t即不接受来自外部的广播。\n\n\n#### LocalBroadcastManager工具类\n`android.support.v4.content.LocalBroadcastManager`工具类，可以实现在自己的进程内进行局部广播发送与注册,不用担心隐私数据泄露的问题而且高效。\n\n\n\tLocalBroadcastManager mLocalBroadcastManager;  \n\tBroadcastReceiver mReceiver;  \n\t\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\t IntentFilter filter = new IntentFilter();  \n\t\t filter.addAction(\"test\");  \n\t\n\t\t mReceiver = new BroadcastReceiver() {  \n\t\t\t@Override  \n\t\t\tpublic void onReceive(Context context, Intent intent) {  \n\t\t\t\tif (intent.getAction().equals(\"test\")) {  \n\t\t\t\t\t//Do Something\n\t\t\t\t} \n\t\t\t}  \n\t\t};  \n\t\tmLocalBroadcastManager = LocalBroadcastManager.getInstance(this);\n\t\t\n\t\t//发送\n\t\tIntent intent = new Intent(\"com.example.broadcasttest.LOCAL_BROADCAST\");\n\t\tmLocalBroadcastManager.sendBroadcast(intent);\n\t\t//注册广播接收器\n\t\tmLocalBroadcastManager.registerReceiver(mReceiver, filter);\n\t}\n\t\n\t\n\t@Override\n\tprotected void onDestroy() {\n\t   mLocalBroadcastManager.unregisterReceiver(mReceiver);\n\t   super.onDestroy();\n\t} \n\n---","source":"_posts/Android之四大组件——广播.md","raw":"# BroadcastReceiver\n---\n<font color=\"red\"> **`BroadcastReceiver` 没有停止的概念** </font>\n\n![广播动态注册与订阅过程](https://i.imgur.com/tSKOkk1.png)\n\n### BroadcastReceiver安全问题 ###\n`BroadcastReceiver`设计的初衷是**从全局考虑可以方便应用程序和系统、应用程序之间、应用程序内的通信**，所以对单个应用程序而言`BroadcastReceiver`是存在安全性问题的(**恶意程序脚本不断的去发送你所接收的广播**)。\n\n#### 发送\n\n\t通过类似sendBroadcast(Intent, String)的接口在发送广播时指定接收者\n\t必须具备的permission或通过Intent.setPackage设置广播仅对某个程序有效。\n\n#### 接收\n当应用程序注册了某个广播时，即便设置了IntentFilter还是会接收到来自其他应用程序的广播进行匹配判断。\n\n\t动态注册 \t通过类似registerReceiver(BroadcastReceiver, IntentFilter,\n\t\t \t\tString, android.os.Handler)的接口指定发送者必须具备的permission。\n\n\t静态注册 \t通过android:exported=\"false\"属性表示接收者对外部应用程序不可用，\n\t\t\t\t即不接受来自外部的广播。\n\n\n#### LocalBroadcastManager工具类\n`android.support.v4.content.LocalBroadcastManager`工具类，可以实现在自己的进程内进行局部广播发送与注册,不用担心隐私数据泄露的问题而且高效。\n\n\n\tLocalBroadcastManager mLocalBroadcastManager;  \n\tBroadcastReceiver mReceiver;  \n\t\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\t IntentFilter filter = new IntentFilter();  \n\t\t filter.addAction(\"test\");  \n\t\n\t\t mReceiver = new BroadcastReceiver() {  \n\t\t\t@Override  \n\t\t\tpublic void onReceive(Context context, Intent intent) {  \n\t\t\t\tif (intent.getAction().equals(\"test\")) {  \n\t\t\t\t\t//Do Something\n\t\t\t\t} \n\t\t\t}  \n\t\t};  \n\t\tmLocalBroadcastManager = LocalBroadcastManager.getInstance(this);\n\t\t\n\t\t//发送\n\t\tIntent intent = new Intent(\"com.example.broadcasttest.LOCAL_BROADCAST\");\n\t\tmLocalBroadcastManager.sendBroadcast(intent);\n\t\t//注册广播接收器\n\t\tmLocalBroadcastManager.registerReceiver(mReceiver, filter);\n\t}\n\t\n\t\n\t@Override\n\tprotected void onDestroy() {\n\t   mLocalBroadcastManager.unregisterReceiver(mReceiver);\n\t   super.onDestroy();\n\t} \n\n---","slug":"Android之四大组件——广播","published":1,"date":"2018-03-21T03:22:18.407Z","updated":"2018-03-19T01:59:46.870Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0kjqj000060s4lcjdlvbni","content":"<h1 id=\"BroadcastReceiver\"><a href=\"#BroadcastReceiver\" class=\"headerlink\" title=\"BroadcastReceiver\"></a>BroadcastReceiver</h1><hr>\n<font color=\"red\"> <strong><code>BroadcastReceiver</code> 没有停止的概念</strong> </font>\n\n<p><img src=\"https://i.imgur.com/tSKOkk1.png\" alt=\"广播动态注册与订阅过程\"></p>\n<h3 id=\"BroadcastReceiver安全问题\"><a href=\"#BroadcastReceiver安全问题\" class=\"headerlink\" title=\"BroadcastReceiver安全问题\"></a>BroadcastReceiver安全问题</h3><p><code>BroadcastReceiver</code>设计的初衷是<strong>从全局考虑可以方便应用程序和系统、应用程序之间、应用程序内的通信</strong>，所以对单个应用程序而言<code>BroadcastReceiver</code>是存在安全性问题的(<strong>恶意程序脚本不断的去发送你所接收的广播</strong>)。</p>\n<h4 id=\"发送\"><a href=\"#发送\" class=\"headerlink\" title=\"发送\"></a>发送</h4><pre><code>通过类似sendBroadcast(Intent, String)的接口在发送广播时指定接收者\n必须具备的permission或通过Intent.setPackage设置广播仅对某个程序有效。\n</code></pre><h4 id=\"接收\"><a href=\"#接收\" class=\"headerlink\" title=\"接收\"></a>接收</h4><p>当应用程序注册了某个广播时，即便设置了IntentFilter还是会接收到来自其他应用程序的广播进行匹配判断。</p>\n<pre><code>动态注册     通过类似registerReceiver(BroadcastReceiver, IntentFilter,\n             String, android.os.Handler)的接口指定发送者必须具备的permission。\n\n静态注册     通过android:exported=&quot;false&quot;属性表示接收者对外部应用程序不可用，\n            即不接受来自外部的广播。\n</code></pre><h4 id=\"LocalBroadcastManager工具类\"><a href=\"#LocalBroadcastManager工具类\" class=\"headerlink\" title=\"LocalBroadcastManager工具类\"></a>LocalBroadcastManager工具类</h4><p><code>android.support.v4.content.LocalBroadcastManager</code>工具类，可以实现在自己的进程内进行局部广播发送与注册,不用担心隐私数据泄露的问题而且高效。</p>\n<pre><code>LocalBroadcastManager mLocalBroadcastManager;  \nBroadcastReceiver mReceiver;  \n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n     IntentFilter filter = new IntentFilter();  \n     filter.addAction(&quot;test&quot;);  \n\n     mReceiver = new BroadcastReceiver() {  \n        @Override  \n        public void onReceive(Context context, Intent intent) {  \n            if (intent.getAction().equals(&quot;test&quot;)) {  \n                //Do Something\n            } \n        }  \n    };  \n    mLocalBroadcastManager = LocalBroadcastManager.getInstance(this);\n\n    //发送\n    Intent intent = new Intent(&quot;com.example.broadcasttest.LOCAL_BROADCAST&quot;);\n    mLocalBroadcastManager.sendBroadcast(intent);\n    //注册广播接收器\n    mLocalBroadcastManager.registerReceiver(mReceiver, filter);\n}\n\n\n@Override\nprotected void onDestroy() {\n   mLocalBroadcastManager.unregisterReceiver(mReceiver);\n   super.onDestroy();\n} \n</code></pre><hr>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"BroadcastReceiver\"><a href=\"#BroadcastReceiver\" class=\"headerlink\" title=\"BroadcastReceiver\"></a>BroadcastReceiver</h1><hr>\n<font color=\"red\"> <strong><code>BroadcastReceiver</code> 没有停止的概念</strong> </font>\n\n<p><img src=\"https://i.imgur.com/tSKOkk1.png\" alt=\"广播动态注册与订阅过程\"></p>\n<h3 id=\"BroadcastReceiver安全问题\"><a href=\"#BroadcastReceiver安全问题\" class=\"headerlink\" title=\"BroadcastReceiver安全问题\"></a>BroadcastReceiver安全问题</h3><p><code>BroadcastReceiver</code>设计的初衷是<strong>从全局考虑可以方便应用程序和系统、应用程序之间、应用程序内的通信</strong>，所以对单个应用程序而言<code>BroadcastReceiver</code>是存在安全性问题的(<strong>恶意程序脚本不断的去发送你所接收的广播</strong>)。</p>\n<h4 id=\"发送\"><a href=\"#发送\" class=\"headerlink\" title=\"发送\"></a>发送</h4><pre><code>通过类似sendBroadcast(Intent, String)的接口在发送广播时指定接收者\n必须具备的permission或通过Intent.setPackage设置广播仅对某个程序有效。\n</code></pre><h4 id=\"接收\"><a href=\"#接收\" class=\"headerlink\" title=\"接收\"></a>接收</h4><p>当应用程序注册了某个广播时，即便设置了IntentFilter还是会接收到来自其他应用程序的广播进行匹配判断。</p>\n<pre><code>动态注册     通过类似registerReceiver(BroadcastReceiver, IntentFilter,\n             String, android.os.Handler)的接口指定发送者必须具备的permission。\n\n静态注册     通过android:exported=&quot;false&quot;属性表示接收者对外部应用程序不可用，\n            即不接受来自外部的广播。\n</code></pre><h4 id=\"LocalBroadcastManager工具类\"><a href=\"#LocalBroadcastManager工具类\" class=\"headerlink\" title=\"LocalBroadcastManager工具类\"></a>LocalBroadcastManager工具类</h4><p><code>android.support.v4.content.LocalBroadcastManager</code>工具类，可以实现在自己的进程内进行局部广播发送与注册,不用担心隐私数据泄露的问题而且高效。</p>\n<pre><code>LocalBroadcastManager mLocalBroadcastManager;  \nBroadcastReceiver mReceiver;  \n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n     IntentFilter filter = new IntentFilter();  \n     filter.addAction(&quot;test&quot;);  \n\n     mReceiver = new BroadcastReceiver() {  \n        @Override  \n        public void onReceive(Context context, Intent intent) {  \n            if (intent.getAction().equals(&quot;test&quot;)) {  \n                //Do Something\n            } \n        }  \n    };  \n    mLocalBroadcastManager = LocalBroadcastManager.getInstance(this);\n\n    //发送\n    Intent intent = new Intent(&quot;com.example.broadcasttest.LOCAL_BROADCAST&quot;);\n    mLocalBroadcastManager.sendBroadcast(intent);\n    //注册广播接收器\n    mLocalBroadcastManager.registerReceiver(mReceiver, filter);\n}\n\n\n@Override\nprotected void onDestroy() {\n   mLocalBroadcastManager.unregisterReceiver(mReceiver);\n   super.onDestroy();\n} \n</code></pre><hr>\n"},{"_content":"# Bitmap\n\n\n\t\t1. BitmapFactory.Options类解析\n\t\t\t1.1. inMutable\n\t\t\t1.2. inJustDecodeBounds、outWidth、outHeight\n\t\t\t1.3. outMimeType\n\t\t\t1.4. inPurgeable、inInputShareable\n\t\t\t1.5. inPreferredConfig\n\t\t\t1.6. inBitmap\n\t\t\t1.7. inScaled、inDensity、inTargetDensity、inScreenDensity\n\t\t\t1.8. inSampleSize\n\n\t\t2. Bitmap内存占用\n\n\t\t3. 缩放因子和Bitmap复用限制的由来\n\t\t\t3.1. Android4.3 API18\n\t\t\t3.2. Android4.4 API19\n\n\n---\n\n\n### 1. Options解析\n\n- `inMutable`\n\n\t\t= true,bitmap可编辑,可以作为Canvas的底层Bitmap使用。\n\t\t= false,bitmap不可变。\n\n- `inJustDecodeBounds`\n\n\t\t= true,不加载到内存,Native层解码了图片,未生成Java层的Bitmap;\n\t\t= false,加载到内存;\n\n\n- `outWidth`、`outHeight`\n\n\t\tinJustDecodeBounds = true 时 Options 得到图片的原始宽高,未经缩放;\n\t\tinJustDecodeBounds = false 时 加载到内存经缩放的宽高;\n\t\n- `outMimeType`\n\n\t\tString,加载图片类型,格式为\"image/*\",如:\"image/png\",\"image/jpeg\";\n\n- `inPurgeable`\n\n\t\tAPI19及以下，= true，BitmapFactory创建的用于存储Bitmap Pixel的内存空间，可以在系统内存不足时被回收。\n\t\tAPP需要再次访问Bitmap的Pixel时（例如：绘制Bitmap或是调用getPixel)，系统会再次调用BitmapFactory decode方法重新生成Bitmap的Pixel数组。\n\n\n- `inInputShareable`\n\n\t\t与 inPurgeable = true 结合使用\n\t\t= true ,\t浅拷贝;\n\t\t= false,\t深拷贝;\n\n- `inPreferredConfig`\n\n\n\n参数取值\t| 存储 | 详解 \n-|-|-\nALPHA_8\t|每个像素一个字节（8位），只存储8位的透明度值|不包含颜色信息\nRGB_565\t|每个像素两个字节（16位），颜色通道比 红:绿:蓝 = 5 : 6 : 5| 65536 = 2^5 × 2^6 × 2^5,可用相近颜色代替\nARGB_4444\t|每个像素两个字节（16位），Alpha，R，G，B四个通道每个通道用4位表示 | 已弃用\nARGB_8888\t|每个像素四个字节（32位），Alpha，R，G，B四个通道每个通道用8位表示 | 完全表示32位真彩色,占用内存过大,是RGB_565模式的两倍，是ALPHA_8模式的4倍\n\n\tinPreferredConfig ≠ null，解码器会尝试使用此参数指定的颜色模式来对图片进行解码\n\tinPreferredConfig = null或者在解码时无法满足此参数指定的颜色模式，\n\t\t\t解码器会自动根据原始图片的特征以及当前设备的屏幕位深，选取合适的颜色模式来解码\n\n<font color = \"red\">指定RGB_565 和不设置inPreferredConfig的效果是一样的。</font>\n\n\t参考自:http://blog.csdn.net/ccpat/article/details/46834089\n\n- `inBitmap`\n\n\tBitmap,API11添加用于重用已有的Bitmap\n\t\t\n\t\t- API 11 ~ API 19\n\n\t\t\t- 被复用的Bitmap的宽高必须等于被加载的Bitmap的原始宽高。（注意这里是指原始宽高，即没进行缩放之前的宽高）\n\t\t\t- 被加载Bitmap的Options.inSampleSize = 1。\n\t\t\t- 被加载Bitmap的Options.inPreferredConfig字段失效，会被被复用的Bitmap的inPreferredConfig值所覆盖（不然，所占内存可能就不一样了）\n\n\t\t- API 19 以上\n\n\t\t\t- 被复用的Bitmap必须是Mutable。违反此限制会返回新申请内存的Bitmap。\n\t\t\t- 被复用的Bitmap的内存大小（通过Bitmap.getAllocationByteCount方法获得，API19及以上才有）必须大于等于被加载的Bitmap的内存大小。违反此限制，将会导致复用失败，抛出异常IllegalArgumentException(Problem decoding into existing bitmap）\n\n- `inScaled`、`inDensity`、`inTargetDensity`、\n\n\t\t表示是否进行缩放,默认 = true;\n\t\t= true , Bitmap#mDensity = inTargetDensity,缩放因子 = inTargetDensity/inDensity;\n\n\t\t\t从res加载图片时,\n\t\t\t\tinDensity = 图片所在文件夹的密度,\n\t\t\t\tinTargetDensity = 系统密度;\n\n\t\t\t从文件加载图片时,默认不缩放\n\t\t\t\tinDensity = 0;一般根据需求设置;\n\t\t\t\tinTargetDensity = 0;一般设为系统密度;\n\n\t\t= false, Bitmap#mDensity = inDensity或者系统默认密度160;\n\n\n\t\t\n\n- `inScreenDensity`\n\n\n- `inSampleSize`\n图片宽高和像素的缩放比;\n\n\t\t当 inSampleSize = 2 时,\n\t\t\t\n\t\t\t宽和高设为本来的1/2,像素总数为原来的1/4。\n\n---\n\t\n### 2. Bitmap内存占用\n\n\t内存\t\t= 每个像素所占字节 × 像素数 \n\t= 每个像素所占字节 × 原始宽度 × 缩放因子 × 原始高度 × 缩放因子\n\t= 每个像素所占字节 × originWidth  × originHeight\n\t  × (inTargetDensity/inDensity)^2\n\n\n \t参考自:http://ltlovezh.com/2016/05/31/Android-Bitmap%E9%82%A3%E4%BA%9B%E4%BA%8B/\n---","source":"_posts/Android之多媒体——Bitmap及图层叠加,裁剪,适配,显示.md","raw":"# Bitmap\n\n\n\t\t1. BitmapFactory.Options类解析\n\t\t\t1.1. inMutable\n\t\t\t1.2. inJustDecodeBounds、outWidth、outHeight\n\t\t\t1.3. outMimeType\n\t\t\t1.4. inPurgeable、inInputShareable\n\t\t\t1.5. inPreferredConfig\n\t\t\t1.6. inBitmap\n\t\t\t1.7. inScaled、inDensity、inTargetDensity、inScreenDensity\n\t\t\t1.8. inSampleSize\n\n\t\t2. Bitmap内存占用\n\n\t\t3. 缩放因子和Bitmap复用限制的由来\n\t\t\t3.1. Android4.3 API18\n\t\t\t3.2. Android4.4 API19\n\n\n---\n\n\n### 1. Options解析\n\n- `inMutable`\n\n\t\t= true,bitmap可编辑,可以作为Canvas的底层Bitmap使用。\n\t\t= false,bitmap不可变。\n\n- `inJustDecodeBounds`\n\n\t\t= true,不加载到内存,Native层解码了图片,未生成Java层的Bitmap;\n\t\t= false,加载到内存;\n\n\n- `outWidth`、`outHeight`\n\n\t\tinJustDecodeBounds = true 时 Options 得到图片的原始宽高,未经缩放;\n\t\tinJustDecodeBounds = false 时 加载到内存经缩放的宽高;\n\t\n- `outMimeType`\n\n\t\tString,加载图片类型,格式为\"image/*\",如:\"image/png\",\"image/jpeg\";\n\n- `inPurgeable`\n\n\t\tAPI19及以下，= true，BitmapFactory创建的用于存储Bitmap Pixel的内存空间，可以在系统内存不足时被回收。\n\t\tAPP需要再次访问Bitmap的Pixel时（例如：绘制Bitmap或是调用getPixel)，系统会再次调用BitmapFactory decode方法重新生成Bitmap的Pixel数组。\n\n\n- `inInputShareable`\n\n\t\t与 inPurgeable = true 结合使用\n\t\t= true ,\t浅拷贝;\n\t\t= false,\t深拷贝;\n\n- `inPreferredConfig`\n\n\n\n参数取值\t| 存储 | 详解 \n-|-|-\nALPHA_8\t|每个像素一个字节（8位），只存储8位的透明度值|不包含颜色信息\nRGB_565\t|每个像素两个字节（16位），颜色通道比 红:绿:蓝 = 5 : 6 : 5| 65536 = 2^5 × 2^6 × 2^5,可用相近颜色代替\nARGB_4444\t|每个像素两个字节（16位），Alpha，R，G，B四个通道每个通道用4位表示 | 已弃用\nARGB_8888\t|每个像素四个字节（32位），Alpha，R，G，B四个通道每个通道用8位表示 | 完全表示32位真彩色,占用内存过大,是RGB_565模式的两倍，是ALPHA_8模式的4倍\n\n\tinPreferredConfig ≠ null，解码器会尝试使用此参数指定的颜色模式来对图片进行解码\n\tinPreferredConfig = null或者在解码时无法满足此参数指定的颜色模式，\n\t\t\t解码器会自动根据原始图片的特征以及当前设备的屏幕位深，选取合适的颜色模式来解码\n\n<font color = \"red\">指定RGB_565 和不设置inPreferredConfig的效果是一样的。</font>\n\n\t参考自:http://blog.csdn.net/ccpat/article/details/46834089\n\n- `inBitmap`\n\n\tBitmap,API11添加用于重用已有的Bitmap\n\t\t\n\t\t- API 11 ~ API 19\n\n\t\t\t- 被复用的Bitmap的宽高必须等于被加载的Bitmap的原始宽高。（注意这里是指原始宽高，即没进行缩放之前的宽高）\n\t\t\t- 被加载Bitmap的Options.inSampleSize = 1。\n\t\t\t- 被加载Bitmap的Options.inPreferredConfig字段失效，会被被复用的Bitmap的inPreferredConfig值所覆盖（不然，所占内存可能就不一样了）\n\n\t\t- API 19 以上\n\n\t\t\t- 被复用的Bitmap必须是Mutable。违反此限制会返回新申请内存的Bitmap。\n\t\t\t- 被复用的Bitmap的内存大小（通过Bitmap.getAllocationByteCount方法获得，API19及以上才有）必须大于等于被加载的Bitmap的内存大小。违反此限制，将会导致复用失败，抛出异常IllegalArgumentException(Problem decoding into existing bitmap）\n\n- `inScaled`、`inDensity`、`inTargetDensity`、\n\n\t\t表示是否进行缩放,默认 = true;\n\t\t= true , Bitmap#mDensity = inTargetDensity,缩放因子 = inTargetDensity/inDensity;\n\n\t\t\t从res加载图片时,\n\t\t\t\tinDensity = 图片所在文件夹的密度,\n\t\t\t\tinTargetDensity = 系统密度;\n\n\t\t\t从文件加载图片时,默认不缩放\n\t\t\t\tinDensity = 0;一般根据需求设置;\n\t\t\t\tinTargetDensity = 0;一般设为系统密度;\n\n\t\t= false, Bitmap#mDensity = inDensity或者系统默认密度160;\n\n\n\t\t\n\n- `inScreenDensity`\n\n\n- `inSampleSize`\n图片宽高和像素的缩放比;\n\n\t\t当 inSampleSize = 2 时,\n\t\t\t\n\t\t\t宽和高设为本来的1/2,像素总数为原来的1/4。\n\n---\n\t\n### 2. Bitmap内存占用\n\n\t内存\t\t= 每个像素所占字节 × 像素数 \n\t= 每个像素所占字节 × 原始宽度 × 缩放因子 × 原始高度 × 缩放因子\n\t= 每个像素所占字节 × originWidth  × originHeight\n\t  × (inTargetDensity/inDensity)^2\n\n\n \t参考自:http://ltlovezh.com/2016/05/31/Android-Bitmap%E9%82%A3%E4%BA%9B%E4%BA%8B/\n---","slug":"Android之多媒体——Bitmap及图层叠加,裁剪,适配,显示","published":1,"date":"2018-03-21T03:22:18.368Z","updated":"2018-01-11T07:47:58.626Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0kjqj100070s4lwep5pew8","content":"<h1 id=\"Bitmap\"><a href=\"#Bitmap\" class=\"headerlink\" title=\"Bitmap\"></a>Bitmap</h1><pre><code>1. BitmapFactory.Options类解析\n    1.1. inMutable\n    1.2. inJustDecodeBounds、outWidth、outHeight\n    1.3. outMimeType\n    1.4. inPurgeable、inInputShareable\n    1.5. inPreferredConfig\n    1.6. inBitmap\n    1.7. inScaled、inDensity、inTargetDensity、inScreenDensity\n    1.8. inSampleSize\n\n2. Bitmap内存占用\n\n3. 缩放因子和Bitmap复用限制的由来\n    3.1. Android4.3 API18\n    3.2. Android4.4 API19\n</code></pre><hr>\n<h3 id=\"1-Options解析\"><a href=\"#1-Options解析\" class=\"headerlink\" title=\"1. Options解析\"></a>1. Options解析</h3><ul>\n<li><p><code>inMutable</code></p>\n<pre><code>= true,bitmap可编辑,可以作为Canvas的底层Bitmap使用。\n= false,bitmap不可变。\n</code></pre></li>\n<li><p><code>inJustDecodeBounds</code></p>\n<pre><code>= true,不加载到内存,Native层解码了图片,未生成Java层的Bitmap;\n= false,加载到内存;\n</code></pre></li>\n</ul>\n<ul>\n<li><p><code>outWidth</code>、<code>outHeight</code></p>\n<pre><code>inJustDecodeBounds = true 时 Options 得到图片的原始宽高,未经缩放;\ninJustDecodeBounds = false 时 加载到内存经缩放的宽高;\n</code></pre></li>\n<li><p><code>outMimeType</code></p>\n<pre><code>String,加载图片类型,格式为&quot;image/*&quot;,如:&quot;image/png&quot;,&quot;image/jpeg&quot;;\n</code></pre></li>\n<li><p><code>inPurgeable</code></p>\n<pre><code>API19及以下，= true，BitmapFactory创建的用于存储Bitmap Pixel的内存空间，可以在系统内存不足时被回收。\nAPP需要再次访问Bitmap的Pixel时（例如：绘制Bitmap或是调用getPixel)，系统会再次调用BitmapFactory decode方法重新生成Bitmap的Pixel数组。\n</code></pre></li>\n</ul>\n<ul>\n<li><p><code>inInputShareable</code></p>\n<pre><code>与 inPurgeable = true 结合使用\n= true ,    浅拷贝;\n= false,    深拷贝;\n</code></pre></li>\n<li><p><code>inPreferredConfig</code></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数取值</th>\n<th>存储</th>\n<th>详解 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ALPHA_8</td>\n<td>每个像素一个字节（8位），只存储8位的透明度值</td>\n<td>不包含颜色信息</td>\n</tr>\n<tr>\n<td>RGB_565</td>\n<td>每个像素两个字节（16位），颜色通道比 红:绿:蓝 = 5 : 6 : 5</td>\n<td>65536 = 2^5 × 2^6 × 2^5,可用相近颜色代替</td>\n</tr>\n<tr>\n<td>ARGB_4444</td>\n<td>每个像素两个字节（16位），Alpha，R，G，B四个通道每个通道用4位表示</td>\n<td>已弃用</td>\n</tr>\n<tr>\n<td>ARGB_8888</td>\n<td>每个像素四个字节（32位），Alpha，R，G，B四个通道每个通道用8位表示</td>\n<td>完全表示32位真彩色,占用内存过大,是RGB_565模式的两倍，是ALPHA_8模式的4倍</td>\n</tr>\n</tbody>\n</table>\n<pre><code>inPreferredConfig ≠ null，解码器会尝试使用此参数指定的颜色模式来对图片进行解码\ninPreferredConfig = null或者在解码时无法满足此参数指定的颜色模式，\n        解码器会自动根据原始图片的特征以及当前设备的屏幕位深，选取合适的颜色模式来解码\n</code></pre><font color=\"red\">指定RGB_565 和不设置inPreferredConfig的效果是一样的。</font>\n\n<pre><code>参考自:http://blog.csdn.net/ccpat/article/details/46834089\n</code></pre><ul>\n<li><p><code>inBitmap</code></p>\n<p>  Bitmap,API11添加用于重用已有的Bitmap</p>\n<pre><code>- API 11 ~ API 19\n\n    - 被复用的Bitmap的宽高必须等于被加载的Bitmap的原始宽高。（注意这里是指原始宽高，即没进行缩放之前的宽高）\n    - 被加载Bitmap的Options.inSampleSize = 1。\n    - 被加载Bitmap的Options.inPreferredConfig字段失效，会被被复用的Bitmap的inPreferredConfig值所覆盖（不然，所占内存可能就不一样了）\n\n- API 19 以上\n\n    - 被复用的Bitmap必须是Mutable。违反此限制会返回新申请内存的Bitmap。\n    - 被复用的Bitmap的内存大小（通过Bitmap.getAllocationByteCount方法获得，API19及以上才有）必须大于等于被加载的Bitmap的内存大小。违反此限制，将会导致复用失败，抛出异常IllegalArgumentException(Problem decoding into existing bitmap）\n</code></pre></li>\n<li><p><code>inScaled</code>、<code>inDensity</code>、<code>inTargetDensity</code>、</p>\n<pre><code>表示是否进行缩放,默认 = true;\n= true , Bitmap#mDensity = inTargetDensity,缩放因子 = inTargetDensity/inDensity;\n\n    从res加载图片时,\n        inDensity = 图片所在文件夹的密度,\n        inTargetDensity = 系统密度;\n\n    从文件加载图片时,默认不缩放\n        inDensity = 0;一般根据需求设置;\n        inTargetDensity = 0;一般设为系统密度;\n\n= false, Bitmap#mDensity = inDensity或者系统默认密度160;\n</code></pre></li>\n</ul>\n<ul>\n<li><code>inScreenDensity</code></li>\n</ul>\n<ul>\n<li><p><code>inSampleSize</code><br>图片宽高和像素的缩放比;</p>\n<pre><code>当 inSampleSize = 2 时,\n\n    宽和高设为本来的1/2,像素总数为原来的1/4。\n</code></pre></li>\n</ul>\n<hr>\n<h3 id=\"2-Bitmap内存占用\"><a href=\"#2-Bitmap内存占用\" class=\"headerlink\" title=\"2. Bitmap内存占用\"></a>2. Bitmap内存占用</h3><pre><code>内存        = 每个像素所占字节 × 像素数 \n= 每个像素所占字节 × 原始宽度 × 缩放因子 × 原始高度 × 缩放因子\n= 每个像素所占字节 × originWidth  × originHeight\n  × (inTargetDensity/inDensity)^2\n\n\n 参考自:http://ltlovezh.com/2016/05/31/Android-Bitmap%E9%82%A3%E4%BA%9B%E4%BA%8B/\n</code></pre><hr>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Bitmap\"><a href=\"#Bitmap\" class=\"headerlink\" title=\"Bitmap\"></a>Bitmap</h1><pre><code>1. BitmapFactory.Options类解析\n    1.1. inMutable\n    1.2. inJustDecodeBounds、outWidth、outHeight\n    1.3. outMimeType\n    1.4. inPurgeable、inInputShareable\n    1.5. inPreferredConfig\n    1.6. inBitmap\n    1.7. inScaled、inDensity、inTargetDensity、inScreenDensity\n    1.8. inSampleSize\n\n2. Bitmap内存占用\n\n3. 缩放因子和Bitmap复用限制的由来\n    3.1. Android4.3 API18\n    3.2. Android4.4 API19\n</code></pre><hr>\n<h3 id=\"1-Options解析\"><a href=\"#1-Options解析\" class=\"headerlink\" title=\"1. Options解析\"></a>1. Options解析</h3><ul>\n<li><p><code>inMutable</code></p>\n<pre><code>= true,bitmap可编辑,可以作为Canvas的底层Bitmap使用。\n= false,bitmap不可变。\n</code></pre></li>\n<li><p><code>inJustDecodeBounds</code></p>\n<pre><code>= true,不加载到内存,Native层解码了图片,未生成Java层的Bitmap;\n= false,加载到内存;\n</code></pre></li>\n</ul>\n<ul>\n<li><p><code>outWidth</code>、<code>outHeight</code></p>\n<pre><code>inJustDecodeBounds = true 时 Options 得到图片的原始宽高,未经缩放;\ninJustDecodeBounds = false 时 加载到内存经缩放的宽高;\n</code></pre></li>\n<li><p><code>outMimeType</code></p>\n<pre><code>String,加载图片类型,格式为&quot;image/*&quot;,如:&quot;image/png&quot;,&quot;image/jpeg&quot;;\n</code></pre></li>\n<li><p><code>inPurgeable</code></p>\n<pre><code>API19及以下，= true，BitmapFactory创建的用于存储Bitmap Pixel的内存空间，可以在系统内存不足时被回收。\nAPP需要再次访问Bitmap的Pixel时（例如：绘制Bitmap或是调用getPixel)，系统会再次调用BitmapFactory decode方法重新生成Bitmap的Pixel数组。\n</code></pre></li>\n</ul>\n<ul>\n<li><p><code>inInputShareable</code></p>\n<pre><code>与 inPurgeable = true 结合使用\n= true ,    浅拷贝;\n= false,    深拷贝;\n</code></pre></li>\n<li><p><code>inPreferredConfig</code></p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数取值</th>\n<th>存储</th>\n<th>详解 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ALPHA_8</td>\n<td>每个像素一个字节（8位），只存储8位的透明度值</td>\n<td>不包含颜色信息</td>\n</tr>\n<tr>\n<td>RGB_565</td>\n<td>每个像素两个字节（16位），颜色通道比 红:绿:蓝 = 5 : 6 : 5</td>\n<td>65536 = 2^5 × 2^6 × 2^5,可用相近颜色代替</td>\n</tr>\n<tr>\n<td>ARGB_4444</td>\n<td>每个像素两个字节（16位），Alpha，R，G，B四个通道每个通道用4位表示</td>\n<td>已弃用</td>\n</tr>\n<tr>\n<td>ARGB_8888</td>\n<td>每个像素四个字节（32位），Alpha，R，G，B四个通道每个通道用8位表示</td>\n<td>完全表示32位真彩色,占用内存过大,是RGB_565模式的两倍，是ALPHA_8模式的4倍</td>\n</tr>\n</tbody>\n</table>\n<pre><code>inPreferredConfig ≠ null，解码器会尝试使用此参数指定的颜色模式来对图片进行解码\ninPreferredConfig = null或者在解码时无法满足此参数指定的颜色模式，\n        解码器会自动根据原始图片的特征以及当前设备的屏幕位深，选取合适的颜色模式来解码\n</code></pre><font color=\"red\">指定RGB_565 和不设置inPreferredConfig的效果是一样的。</font>\n\n<pre><code>参考自:http://blog.csdn.net/ccpat/article/details/46834089\n</code></pre><ul>\n<li><p><code>inBitmap</code></p>\n<p>  Bitmap,API11添加用于重用已有的Bitmap</p>\n<pre><code>- API 11 ~ API 19\n\n    - 被复用的Bitmap的宽高必须等于被加载的Bitmap的原始宽高。（注意这里是指原始宽高，即没进行缩放之前的宽高）\n    - 被加载Bitmap的Options.inSampleSize = 1。\n    - 被加载Bitmap的Options.inPreferredConfig字段失效，会被被复用的Bitmap的inPreferredConfig值所覆盖（不然，所占内存可能就不一样了）\n\n- API 19 以上\n\n    - 被复用的Bitmap必须是Mutable。违反此限制会返回新申请内存的Bitmap。\n    - 被复用的Bitmap的内存大小（通过Bitmap.getAllocationByteCount方法获得，API19及以上才有）必须大于等于被加载的Bitmap的内存大小。违反此限制，将会导致复用失败，抛出异常IllegalArgumentException(Problem decoding into existing bitmap）\n</code></pre></li>\n<li><p><code>inScaled</code>、<code>inDensity</code>、<code>inTargetDensity</code>、</p>\n<pre><code>表示是否进行缩放,默认 = true;\n= true , Bitmap#mDensity = inTargetDensity,缩放因子 = inTargetDensity/inDensity;\n\n    从res加载图片时,\n        inDensity = 图片所在文件夹的密度,\n        inTargetDensity = 系统密度;\n\n    从文件加载图片时,默认不缩放\n        inDensity = 0;一般根据需求设置;\n        inTargetDensity = 0;一般设为系统密度;\n\n= false, Bitmap#mDensity = inDensity或者系统默认密度160;\n</code></pre></li>\n</ul>\n<ul>\n<li><code>inScreenDensity</code></li>\n</ul>\n<ul>\n<li><p><code>inSampleSize</code><br>图片宽高和像素的缩放比;</p>\n<pre><code>当 inSampleSize = 2 时,\n\n    宽和高设为本来的1/2,像素总数为原来的1/4。\n</code></pre></li>\n</ul>\n<hr>\n<h3 id=\"2-Bitmap内存占用\"><a href=\"#2-Bitmap内存占用\" class=\"headerlink\" title=\"2. Bitmap内存占用\"></a>2. Bitmap内存占用</h3><pre><code>内存        = 每个像素所占字节 × 像素数 \n= 每个像素所占字节 × 原始宽度 × 缩放因子 × 原始高度 × 缩放因子\n= 每个像素所占字节 × originWidth  × originHeight\n  × (inTargetDensity/inDensity)^2\n\n\n 参考自:http://ltlovezh.com/2016/05/31/Android-Bitmap%E9%82%A3%E4%BA%9B%E4%BA%8B/\n</code></pre><hr>\n"},{"_content":"# SQLite 操作  #\n---\n- 目录\n\n\t```\n\t1. SQLite ( SQLite 命令中 以\"[]\"包含的内容表示可省略 )\n\t\t- SQLiteHelper\n\t\t- 操作\n\t\t\t- 创建数据库\n\t\t\t- 增\n\t\t\t- 删\n\t\t\t- 改\n\t\t\t- 查\n\t\t\t- 关闭数据库\n\t\t\t- 删除数据库\n\t\t- SQL语句中的子句\n\t\t- SQLite 位运算符\n\n\t2. 其他数据库\n\t\t- Realm\n\t\t- DBFlow\n\t\t\n\t```\n- 参考\n\t- [ **SQLite 教程 | 菜鸟教程** ](http://www.runoob.com/sqlite/sqlite-tutorial.html)\n\t- [ **Android ：这是一份详细 & 全面的 SQLlite数据库 使用手册** ](https://juejin.im/post/5a5bfc016fb9a01ca10ae0a9#heading-5)\n\t- [ **玩转SQLite系列** ](http://blog.csdn.net/linglongxin24/article/details/53230842)\n\n\n---\n## SQLite ##\n\n![Sqlite](https://i.imgur.com/CHgDAL0.png)\n\n<font color = red >**字段支持 **</font>\n<font color = red > > `NULL`、`INTEGER`、`FLOAT`、`STRING`、`BLOB ` </font>\n\n\n\n\n### 1. `SQLiteHelper` ###\n\n```java\npublic class MySqliteHelper extends SQLiteOpenHelper {\n\n\n    public MySqliteHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) {\n        super(context, name, factory, version);\n    }\n\n    @Override\n    public void onCreate(SQLiteDatabase sqLiteDatabase) {\n\n    }\n\n    @Override\n    public void onUpgrade(SQLiteDatabase sqLiteDatabase, int i, int i1) {\n\n    }\n}\n\n```\n\n### 2. 数据库操作 ###\n\n- 创建或获取数据库\n\n\t- 打开或创建原始位置的数据库\n\n\t\t```java\n\t\tPersonalSQLiteHelper helper = new PersonalSQLiteHelper(this, \"db_name\", 1);\n\t\tSQLiteDatabase db0 = helper.getReadableDatabase();\n\t\t//获取位置信息\n\t\tList<Pair<String, String>> attachedDbs = db0.getAttachedDbs();\n\t\tString path = attachedDbs.get(0).first + attachedDbs.get(0).second;\n\t\t```\n\n\t- 打开指定位置的数据库\n\n\t\t```java\n\t\tSQLiteDatabase db1 = SQLiteDatabase.openOrCreateDatabase(filePath, null);\n\t\tSQLiteDatabase db2 = SQLiteDatabase.openOrCreateDatabase(file, null);\n\t\t//获取位置信息\n\t\tList<Pair<String, String>> attachedDbs = db1.getAttachedDbs();\n\t\tString path = attachedDbs.get(0).first + attachedDbs.get(0).second;\n\t\t```\n\n\t- 打开或创建指定操作模式的数据库\n\n\t\t```java\n\t\tSQLiteDatabase db3 = this.openOrCreateDatabase(\"db_name\", MODE_PRIVATE, null, null);\n\t\t//获取位置信息\n\t\tList<Pair<String, String>> attachedDbs = db3.getAttachedDbs();\n\t\tString path = attachedDbs.get(0).first + attachedDbs.get(0).second;\n\t\t```\n\n- 创建表单`(create)`\n\t- SQL 语句\n\t\t```\n\t\tCREATE TABLE IF NOT EXISTS 表名(\t\n\t\t\t\t列名  列类型(大小)  属性,\n\t\t\t\t列名  列类型(大小)  属性,\n\t\t\t\t列名  列类型(大小)  属性\n\t\t\t\t... )\n\t\teg:\n\t\t\tCREATE TABLE IF NOT EXISTS tableName(_id integer primary key autoincrement, name varchar(20) not null , ...)\n\t\t```\n- 删除表单`(drop)`\n\t- SQL 语句\n\t\t```\n\t\tDROP TABLE IF  EXISTS 表名\t\n\t\teg:\n\t\t\tDROP TABLE IF EXISTS tableName\n\t\t```\n\t\t\n- 增`(insert)`\n\n\t- SQL 语句\n\t\t```\n\t\tINSERT INTO TABLE_NAME [(column1, column2, column3,...columnN)]  VALUES (value1, value2, value3,...valueN)\n\t\t\t\t\n\t\teg:\n\t\t\t- INSERT INTO User VALUES (1,'张三',26)\n\t\t\t- INSERT INTO User(id,name,age) VALUES (1,'张三',26)\n\t\t```\t\n\t\t\n\t\t```\n\t\t// 从一张表填充到另一个表\n\t\tINSERT INTO first_table_name [(column1, column2, ... columnN)]  SELECT column1, column2, ...columnN \n   \t\t\tFROM second_table_name [WHERE condition]\n\n\t\t```\n\t- API\n\n\t\t```java\n\t\t    /**\n\t\t     * 给user表中新增一条数据\n\t\t     * <p>\n\t\t     * long insert(String table, String nullColumnHack, ContentValues values)\n\t\t     * 第一个参数：数据库表名\n\t\t     * 第二个参数：当values参数为空或者里面没有内容的时候，\n\t\t     * insert是会失败的(底层数据库不允许插入一个空行)，\n\t\t     * 为了防止这种情况，要在这里指定一个列名，\n\t\t     * 到时候如果发现将要插入的行为空行时，\n\t\t     * 就会将你指定的这个列名的值设为null，然后再向数据库中插入。\n\t\t     * 第三个参数：要插入的值\n\t\t     * 返回值：成功操作的行号，错误返回-1\n\t\t     *\n\t\t     * @param v\n\t\t     */\n\t\t    public void insert(View v) {\n\t\t        String table = \"user\";\n\t\t        ContentValues contentValues = new ContentValues();\n\t\t        contentValues.put(\"name\", \"张三\");\n\t\t        contentValues.put(\"age\", 25);\n\t\t        long num = sqLiteDatabase.insert(table, null, contentValues);\n\t\t        if (num == -1) {\n\t\t            Toast.makeText(this, \"插入失败\", Toast.LENGTH_SHORT).show();\n\t\t        } else {\n\t\t            Toast.makeText(this, \"成功插入到第\" + num + \"行\", Toast.LENGTH_SHORT).show();\n\t\t        }\n\t\t    }\n\t\t\n\t\t```\n\t- <font color = red>**API 批量操作的优化**</font>\n\n\t\t```java \n\t\t\tlong startTime = System.currentTimeMillis();\n\t\t\tString table = \"user\";\n\t\t\t/**开启一个事务**/\n\t\t\tsqLiteDatabase.beginTransaction();\n\t\t\ttry {\n\t\t            for (int i = 0; i < 100; i++) {\n\t\t                ContentValues contentValues = new ContentValues();\n\t\t                contentValues.put(\"name\", \"张三\" + i);\n\t\t                contentValues.put(\"age\", i);\n\t\t                sqLiteDatabase.insertOrThrow(table, null, contentValues);\n\t\t            }\n\t\t            /**将数据库事务设置为成功**/\n\t\t            sqLiteDatabase.setTransactionSuccessful();\n\t\t\t} catch (Exception e) {\n\t\t            e.printStackTrace();\n\t\t\t} finally {\n\t\t            /**结束数据库事务**/\n\t\t            sqLiteDatabase.endTransaction();\n\t\t\t}\n\t\t\n\t\t```\n- 删`(delete)`\n\t- SQL 语句\n\t\t```\n\t\tDELETE FROM table_name WHERE [condition]\n\t\t\n\t\teg:\n\t\t\tDELETE FROM User WHERE id=2\n\t\t\tDELETE FROM COMPANY //删除所有记录\n\t\t```\n\t- API\n\n\t\t```java\n\t\t /**\n\t\t     * 删除user表中id为2的记录\n\t\t     * <p>\n\t\t     * int delete(String table, String whereClause, String[] whereArgs)\n\t\t     * 第一个参数：删除的表名\n\t\t     * 第二个参数：修改的条件的字段\n\t\t     * 第三个参数：修改的条件字段对应的值\n\t\t     * 返回值：影响的行数\n\t\t     *\n\t\t     * @param v\n\t\t     */\n\t\t    public void delete(View v) {\n\t\t    \t//1\n\t\t        //String table = \"user\";\n\t\t        //String where = \"id=2\";\n\t\t        //sqLiteDatabase.delete(table, where, null);\n\t\t        \n\t\t        //2\n\t\t        String table = \"user\";\n\t\t        String where = \"id=?\";\n\t\t        String[] whereArgs = new String[]{\"2\"};\n\t\t        int num = sqLiteDatabase.delete(table, where, whereArgs);\n\t\t    }\n\t\t```\n- 改`(update)`\n\t- SQL 语句\n\t\t```\n\t\tUPDATE table_name SET column1 = value1, column2 = value2.... WHERE [condition]\n\t\t//可以使用 AND 或 OR 运算符来结合 N 个数量的条件\n\t\t\n\t\teg:\n\t\t\tUPDATE User SET name=\"李四\" WHERE id=2;\n\t\t\tUPDATE COMPANY SET ADDRESS = 'Texas' WHERE ID = 6;\n\t\t\tUPDATE COMPANY SET ADDRESS = 'Texas', SALARY = 20000.00;//修改所有\n\t\t```\n\t- API\n\n\t\t```java\n\t\t     /* UPDATE User SET name=\"李四\" WHERE id=2; */\n\t\t     public void update(View v) {\n\t\t         /**\n\t\t          * 方式一\n\t\t          */\t\t\n\t\t         //String table = \"user\";\n\t\t         //ContentValues contentValues = new ContentValues();\n\t\t         //contentValues.put(\"name\", \"李四\");\n\t\t         //String where = \"id=2\";\n\t\t         //sqLiteDatabase.update(table, contentValues, where, null);\n\n\t\t         /**\n\t\t          * 方式二\n\t\t          */\n\t\t         String table = \"user\";\n\t\t         ContentValues contentValues = new ContentValues();\n\t\t         contentValues.put(\"name\", \"李四\");\n\t\t         String where = \"id=?\";\n\t\t         String[] whereArgs = new String[]{\"2\"};\n\t\t         int num = sqLiteDatabase.update(table, contentValues, where, whereArgs);\n\t\t         Toast.makeText(this, \"修改了\" + num + \"行\", Toast.LENGTH_SHORT).show();\n\t\t     }\n\t\t```\n\n- 查`(select)`\n\t- SQL 语句\n\t\t```\n\t\tSELECT * \t\tFROM 表名 WHERE 查询的条件表达式  GROUP BY 分组的字段 ORDER BY 排序的字段\n\t\tSELECT 字段名 \tFROM 表名 WHERE 查询的条件表达式  GROUP BY 分组的字段 ORDER BY 排序的字段\n\t\t\n\t\teg:\n\t\t\tSELECT * FROM  User\n\t\t\tSELECT * FROM  User WHERE id=2\n\t\t\t\n\t\t\tSELECT name,age FROM  User WHERE age>25\n\t\t\tSELECT name,age FROM  User WHERE age BETWEEN 20 AND 40\n\t\t\tSELECT name,age FROM  User WHERE name LIKE \"亮\"\n\t\t\tSELECT name,age FROM  User WHERE name IS NULL\n\t\t\tSELECT name,age FROM  User ORDER BY age\n\t\t\n\t\t//查询过程\t\t\n\t\tpublic void query(View v) {\n\n\t\t\tString sql = \"SELECT * FROM user\";\n\t\t\t/***这里得到的是一个游标*/\n\t\t\tCursor cursor = sqLiteDatabase.rawQuery(sql, null, null);\n\t\t\tif (cursor == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/***循环游标得到数据*/\n\t\t\twhile (cursor.moveToNext()) {\n\t\t\t\tLog.d(Contacts.TAG,\n\t\t\t\t\t\"id=\" + cursor.getInt(0) \n\t\t\t\t\t+ \"，name=\" + cursor.getString(1)\n\t\t\t\t\t+ \"，age=\" + cursor.getInt(2));\n\t\t\t\tint id = cursor.getInt(cursor.getColumnIndex(\"id\"));\n\t\t\t}\n\t\t\t/***记得操作完将游标关闭*/\n\t\t\tcursor.close();\n\t\t}\n\t\t```\n\n- 关闭数据库\n\n\t```java\n\t//查询的游标\n\tqueryCursor.close();\n\t//数据库对象\n\tsqLiteDatabase.close();\n\t\n\t```\n- 删除数据库,通过删除文件进行删除操作\n\n\t```java\n\t\t//关闭数据库文件及操作\n\t\tdb2.close();\n\t\tString path1 = db2.getPath();\n\t\tFile file = new File(path1);\n\t\tif (file.exists() && file.isFile()) {\n\t\t\ttry {\n\t\t\t\tfile.delete();\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t```\n### 3. SQL语句中的子句 ###\n\n- `WHERE`\n\t1. 比较 / 逻辑运算符: >、<、=\n\t2. 与( AND )、或( OR 、  IN ( value1, value2 ) )、非( IS NOT )、包含( LIKE / GLOB  )\n\t3. 筛选语句,先子后父\n\n```\n\teg:\n\tSELECT * FROM COMPANY WHERE AGE >= 25 AND SALARY >= 65000;\n\tSELECT * FROM COMPANY WHERE AGE IS NOT NULL;\t\n\t\n\tSELECT * FROM COMPANY WHERE NAME LIKE 'Ki%'; \n\tSELECT * FROM COMPANY WHERE NAME GLOB 'Ki*';\n\t// LIKE 'Ki%' 与 GLOB 'Ki*' 相同 , 均表示 以 'Ki' 开始的所有记录，'Ki' 之后的字符不做限制;\n\t\n\t//列出了 AGE 的值为 25 或 27 的所有记录\n\tSELECT * FROM COMPANY WHERE AGE IN ( 25, 27 );\n\t//列出了 AGE 的值既不是 25 也不是 27 的所有记录\n\tSELECT * FROM COMPANY WHERE AGE NOT IN ( 25, 27 );\n\t//列出了 AGE 的值在 25 与 27 之间的所有记录\n\tSELECT * FROM COMPANY WHERE AGE BETWEEN 25 AND 27;\n\t\n\t//筛选结果 要包含子句筛选结果\n\tSELECT AGE FROM COMPANY WHERE \tEXISTS (SELECT AGE FROM COMPANY WHERE SALARY > 65000);\n\t// 列出了比 SALARY大于65000的值的AGE项 更大的值的所有信息\n\tSELECT * FROM COMPANY WHERE \tAGE > (SELECT AGE FROM COMPANY WHERE SALARY > 65000);\n\n```\n\n- `ORDER BY`\n排序操作。使用 `ASC | DESC`设置升序降序。\n\n```\n\tSELECT column-list FROM table_name [WHERE condition] [ORDER BY column1, column2, .. columnN] [ASC | DESC];\n\t\n```\n- `GROUP BY`\n对相同的数据进行分组。\n\n```\t\n\tSELECT column0, SUM(column1) FROM tabName \t[GROUP BY column0] \t[ORDER BY column0][ASC | DESC];\n\t\n\teg:\n\t\t//筛选出带有 NAME 与 SALARY 项的信息,根据NAME字段排序,并将相同NAME字段的SALARY合并为SUM(SALARY) ;\n\t\tSELECT NAME, SUM(SALARY) FROM COMPANY \tGROUP BY NAME \tORDER BY NAME\tASC;//升序\n\t\tSELECT NAME, SUM(SALARY) FROM COMPANY \tGROUP BY NAME \tORDER BY NAME \tDESC;//降序\n```\n- `LIKE`\n用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，LIKE 运算符将返回真（true），也就是 1。\n通配符有\" % \"、\" _ \":\n\t- \" % \" : 零个、一个或多个数字或字符；\n\t- \" _ \" : 代表一个单一的数字或字符。\n\n<font color = red>**示例**</font>:\n\n`LIKE`语句\t|\t描述\n:-|:-\nWHERE SALARY LIKE '200%'\t|查找以 200 开头的任意值\nWHERE SALARY LIKE '%200%'\t|查找任意位置包含 200 的任意值\nWHERE SALARY LIKE '_00%'\t|查找第二位和第三位为 00 的任意值\nWHERE SALARY LIKE '2_%_%'\t|查找以 2 开头，且长度至少为 3 个字符的任意值\nWHERE SALARY LIKE '%2'\t\t|查找以 2 结尾的任意值\nWHERE SALARY LIKE '_2%3'\t|查找第二位为 2，且以 3 结尾的任意值\nWHERE SALARY LIKE '2___3'\t|查找长度为 5 位数，且以 2 开头以 3 结尾的任意值\n\n\n- `GLOB`\n用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，GLOB 运算符将返回真（true），也就是 1。<font color = red>**大小写敏感**</font>。\n\n\t- 星号 （*） : 代表零个、一个或多个数字或字符。\n\t- 问号 （?） : 代表一个单一的数字或字符。\n\n<font color = red>**示例**</font>:\n\n`GLOB`语句\t|\t描述\n:-|:-\nWHERE SALARY GLOB '200*'\t|查找以 200 开头的任意值\nWHERE SALARY GLOB '\\*200\\*'\t|查找任意位置包含 200 的任意值\nWHERE SALARY GLOB '?00*'\t|查找第二位和第三位为 00 的任意值\nWHERE SALARY GLOB '2??'\t\t|查找以 2 开头，且长度至少为 3 个字符的任意值\nWHERE SALARY GLOB '*2'\t\t|查找以 2 结尾的任意值\nWHERE SALARY GLOB '?2*3'\t|查找第二位为 2，且以 3 结尾的任意值\nWHERE SALARY GLOB '2???3'\t|查找长度为 5 位数，且以 2 开头以 3 结尾的任意值\n\n\n- `HAVING`\nHAVING 子句必须放在 GROUP BY 子句之后，必须放在 ORDER BY 子句之前。\n\n```\n\tSELECT column1, column2 FROM table1, table2 WHERE [ conditions ]\n\t\tGROUP BY column1, column2 HAVING [ conditions ] ORDER BY column1, column2\n\t\n\teg:\n\t\t//name 字段 重复次数小于2的内容按名称排序\n\t\tSELECT * FROM COMPANY GROUP BY name HAVING count(name) < 2;\n```\n\n---\n### 4. SQLite 位运算符  ###\n\n\n位运算符作用于位，并逐位执行操作。真值表 & 和 | 如下：\n\np| q | p & q | p &#124; q\n:-:|:-:|:-:|:-:\n0\t|0\t|0\t|0\n0\t|1\t|0\t|1\n1\t|1\t|1\t|1\n1\t|0\t|0\t|1\n假设如果 A = 60，且 B = 13，现在以二进制格式，它们如下所示：\nA = 0011 1100;\nB = 0000 1101;\nA&B = 0000 1100;\nA|B = 0011 1101;\n~A  = 1100 0011;\n下表中列出了 SQLite 语言支持的位运算符。假设变量 A=60，变量 B=13，则：\n\n运算符\t|\t描述\t|实例\n-|-|-\n&\t|如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。|( A & B ) =12，即为 0000 1100\n&#124;\t|如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。\t|( A &#124; B ) = 61，即为 0011 1101\n~\t|二进制补码运算符是一元运算符，具有\"翻转\"位效应，即0变成1，1变成0。\t|( ~ A ) = -61，即为 1100 0011，一个有符号二进制数的补码形式。\n<<\t|二进制左移运算符。左操作数的值向左移动右操作数指定的位数。\t|A << 2=240，即为 1111 0000\n>>\t|二进制右移运算符。左操作数的值向右移动右操作数指定的位数。\t|A >> 2 =15，即为 0000 1111\n\n\n---\n","source":"_posts/Android之存储——SQLite与其他数据库.md","raw":"# SQLite 操作  #\n---\n- 目录\n\n\t```\n\t1. SQLite ( SQLite 命令中 以\"[]\"包含的内容表示可省略 )\n\t\t- SQLiteHelper\n\t\t- 操作\n\t\t\t- 创建数据库\n\t\t\t- 增\n\t\t\t- 删\n\t\t\t- 改\n\t\t\t- 查\n\t\t\t- 关闭数据库\n\t\t\t- 删除数据库\n\t\t- SQL语句中的子句\n\t\t- SQLite 位运算符\n\n\t2. 其他数据库\n\t\t- Realm\n\t\t- DBFlow\n\t\t\n\t```\n- 参考\n\t- [ **SQLite 教程 | 菜鸟教程** ](http://www.runoob.com/sqlite/sqlite-tutorial.html)\n\t- [ **Android ：这是一份详细 & 全面的 SQLlite数据库 使用手册** ](https://juejin.im/post/5a5bfc016fb9a01ca10ae0a9#heading-5)\n\t- [ **玩转SQLite系列** ](http://blog.csdn.net/linglongxin24/article/details/53230842)\n\n\n---\n## SQLite ##\n\n![Sqlite](https://i.imgur.com/CHgDAL0.png)\n\n<font color = red >**字段支持 **</font>\n<font color = red > > `NULL`、`INTEGER`、`FLOAT`、`STRING`、`BLOB ` </font>\n\n\n\n\n### 1. `SQLiteHelper` ###\n\n```java\npublic class MySqliteHelper extends SQLiteOpenHelper {\n\n\n    public MySqliteHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) {\n        super(context, name, factory, version);\n    }\n\n    @Override\n    public void onCreate(SQLiteDatabase sqLiteDatabase) {\n\n    }\n\n    @Override\n    public void onUpgrade(SQLiteDatabase sqLiteDatabase, int i, int i1) {\n\n    }\n}\n\n```\n\n### 2. 数据库操作 ###\n\n- 创建或获取数据库\n\n\t- 打开或创建原始位置的数据库\n\n\t\t```java\n\t\tPersonalSQLiteHelper helper = new PersonalSQLiteHelper(this, \"db_name\", 1);\n\t\tSQLiteDatabase db0 = helper.getReadableDatabase();\n\t\t//获取位置信息\n\t\tList<Pair<String, String>> attachedDbs = db0.getAttachedDbs();\n\t\tString path = attachedDbs.get(0).first + attachedDbs.get(0).second;\n\t\t```\n\n\t- 打开指定位置的数据库\n\n\t\t```java\n\t\tSQLiteDatabase db1 = SQLiteDatabase.openOrCreateDatabase(filePath, null);\n\t\tSQLiteDatabase db2 = SQLiteDatabase.openOrCreateDatabase(file, null);\n\t\t//获取位置信息\n\t\tList<Pair<String, String>> attachedDbs = db1.getAttachedDbs();\n\t\tString path = attachedDbs.get(0).first + attachedDbs.get(0).second;\n\t\t```\n\n\t- 打开或创建指定操作模式的数据库\n\n\t\t```java\n\t\tSQLiteDatabase db3 = this.openOrCreateDatabase(\"db_name\", MODE_PRIVATE, null, null);\n\t\t//获取位置信息\n\t\tList<Pair<String, String>> attachedDbs = db3.getAttachedDbs();\n\t\tString path = attachedDbs.get(0).first + attachedDbs.get(0).second;\n\t\t```\n\n- 创建表单`(create)`\n\t- SQL 语句\n\t\t```\n\t\tCREATE TABLE IF NOT EXISTS 表名(\t\n\t\t\t\t列名  列类型(大小)  属性,\n\t\t\t\t列名  列类型(大小)  属性,\n\t\t\t\t列名  列类型(大小)  属性\n\t\t\t\t... )\n\t\teg:\n\t\t\tCREATE TABLE IF NOT EXISTS tableName(_id integer primary key autoincrement, name varchar(20) not null , ...)\n\t\t```\n- 删除表单`(drop)`\n\t- SQL 语句\n\t\t```\n\t\tDROP TABLE IF  EXISTS 表名\t\n\t\teg:\n\t\t\tDROP TABLE IF EXISTS tableName\n\t\t```\n\t\t\n- 增`(insert)`\n\n\t- SQL 语句\n\t\t```\n\t\tINSERT INTO TABLE_NAME [(column1, column2, column3,...columnN)]  VALUES (value1, value2, value3,...valueN)\n\t\t\t\t\n\t\teg:\n\t\t\t- INSERT INTO User VALUES (1,'张三',26)\n\t\t\t- INSERT INTO User(id,name,age) VALUES (1,'张三',26)\n\t\t```\t\n\t\t\n\t\t```\n\t\t// 从一张表填充到另一个表\n\t\tINSERT INTO first_table_name [(column1, column2, ... columnN)]  SELECT column1, column2, ...columnN \n   \t\t\tFROM second_table_name [WHERE condition]\n\n\t\t```\n\t- API\n\n\t\t```java\n\t\t    /**\n\t\t     * 给user表中新增一条数据\n\t\t     * <p>\n\t\t     * long insert(String table, String nullColumnHack, ContentValues values)\n\t\t     * 第一个参数：数据库表名\n\t\t     * 第二个参数：当values参数为空或者里面没有内容的时候，\n\t\t     * insert是会失败的(底层数据库不允许插入一个空行)，\n\t\t     * 为了防止这种情况，要在这里指定一个列名，\n\t\t     * 到时候如果发现将要插入的行为空行时，\n\t\t     * 就会将你指定的这个列名的值设为null，然后再向数据库中插入。\n\t\t     * 第三个参数：要插入的值\n\t\t     * 返回值：成功操作的行号，错误返回-1\n\t\t     *\n\t\t     * @param v\n\t\t     */\n\t\t    public void insert(View v) {\n\t\t        String table = \"user\";\n\t\t        ContentValues contentValues = new ContentValues();\n\t\t        contentValues.put(\"name\", \"张三\");\n\t\t        contentValues.put(\"age\", 25);\n\t\t        long num = sqLiteDatabase.insert(table, null, contentValues);\n\t\t        if (num == -1) {\n\t\t            Toast.makeText(this, \"插入失败\", Toast.LENGTH_SHORT).show();\n\t\t        } else {\n\t\t            Toast.makeText(this, \"成功插入到第\" + num + \"行\", Toast.LENGTH_SHORT).show();\n\t\t        }\n\t\t    }\n\t\t\n\t\t```\n\t- <font color = red>**API 批量操作的优化**</font>\n\n\t\t```java \n\t\t\tlong startTime = System.currentTimeMillis();\n\t\t\tString table = \"user\";\n\t\t\t/**开启一个事务**/\n\t\t\tsqLiteDatabase.beginTransaction();\n\t\t\ttry {\n\t\t            for (int i = 0; i < 100; i++) {\n\t\t                ContentValues contentValues = new ContentValues();\n\t\t                contentValues.put(\"name\", \"张三\" + i);\n\t\t                contentValues.put(\"age\", i);\n\t\t                sqLiteDatabase.insertOrThrow(table, null, contentValues);\n\t\t            }\n\t\t            /**将数据库事务设置为成功**/\n\t\t            sqLiteDatabase.setTransactionSuccessful();\n\t\t\t} catch (Exception e) {\n\t\t            e.printStackTrace();\n\t\t\t} finally {\n\t\t            /**结束数据库事务**/\n\t\t            sqLiteDatabase.endTransaction();\n\t\t\t}\n\t\t\n\t\t```\n- 删`(delete)`\n\t- SQL 语句\n\t\t```\n\t\tDELETE FROM table_name WHERE [condition]\n\t\t\n\t\teg:\n\t\t\tDELETE FROM User WHERE id=2\n\t\t\tDELETE FROM COMPANY //删除所有记录\n\t\t```\n\t- API\n\n\t\t```java\n\t\t /**\n\t\t     * 删除user表中id为2的记录\n\t\t     * <p>\n\t\t     * int delete(String table, String whereClause, String[] whereArgs)\n\t\t     * 第一个参数：删除的表名\n\t\t     * 第二个参数：修改的条件的字段\n\t\t     * 第三个参数：修改的条件字段对应的值\n\t\t     * 返回值：影响的行数\n\t\t     *\n\t\t     * @param v\n\t\t     */\n\t\t    public void delete(View v) {\n\t\t    \t//1\n\t\t        //String table = \"user\";\n\t\t        //String where = \"id=2\";\n\t\t        //sqLiteDatabase.delete(table, where, null);\n\t\t        \n\t\t        //2\n\t\t        String table = \"user\";\n\t\t        String where = \"id=?\";\n\t\t        String[] whereArgs = new String[]{\"2\"};\n\t\t        int num = sqLiteDatabase.delete(table, where, whereArgs);\n\t\t    }\n\t\t```\n- 改`(update)`\n\t- SQL 语句\n\t\t```\n\t\tUPDATE table_name SET column1 = value1, column2 = value2.... WHERE [condition]\n\t\t//可以使用 AND 或 OR 运算符来结合 N 个数量的条件\n\t\t\n\t\teg:\n\t\t\tUPDATE User SET name=\"李四\" WHERE id=2;\n\t\t\tUPDATE COMPANY SET ADDRESS = 'Texas' WHERE ID = 6;\n\t\t\tUPDATE COMPANY SET ADDRESS = 'Texas', SALARY = 20000.00;//修改所有\n\t\t```\n\t- API\n\n\t\t```java\n\t\t     /* UPDATE User SET name=\"李四\" WHERE id=2; */\n\t\t     public void update(View v) {\n\t\t         /**\n\t\t          * 方式一\n\t\t          */\t\t\n\t\t         //String table = \"user\";\n\t\t         //ContentValues contentValues = new ContentValues();\n\t\t         //contentValues.put(\"name\", \"李四\");\n\t\t         //String where = \"id=2\";\n\t\t         //sqLiteDatabase.update(table, contentValues, where, null);\n\n\t\t         /**\n\t\t          * 方式二\n\t\t          */\n\t\t         String table = \"user\";\n\t\t         ContentValues contentValues = new ContentValues();\n\t\t         contentValues.put(\"name\", \"李四\");\n\t\t         String where = \"id=?\";\n\t\t         String[] whereArgs = new String[]{\"2\"};\n\t\t         int num = sqLiteDatabase.update(table, contentValues, where, whereArgs);\n\t\t         Toast.makeText(this, \"修改了\" + num + \"行\", Toast.LENGTH_SHORT).show();\n\t\t     }\n\t\t```\n\n- 查`(select)`\n\t- SQL 语句\n\t\t```\n\t\tSELECT * \t\tFROM 表名 WHERE 查询的条件表达式  GROUP BY 分组的字段 ORDER BY 排序的字段\n\t\tSELECT 字段名 \tFROM 表名 WHERE 查询的条件表达式  GROUP BY 分组的字段 ORDER BY 排序的字段\n\t\t\n\t\teg:\n\t\t\tSELECT * FROM  User\n\t\t\tSELECT * FROM  User WHERE id=2\n\t\t\t\n\t\t\tSELECT name,age FROM  User WHERE age>25\n\t\t\tSELECT name,age FROM  User WHERE age BETWEEN 20 AND 40\n\t\t\tSELECT name,age FROM  User WHERE name LIKE \"亮\"\n\t\t\tSELECT name,age FROM  User WHERE name IS NULL\n\t\t\tSELECT name,age FROM  User ORDER BY age\n\t\t\n\t\t//查询过程\t\t\n\t\tpublic void query(View v) {\n\n\t\t\tString sql = \"SELECT * FROM user\";\n\t\t\t/***这里得到的是一个游标*/\n\t\t\tCursor cursor = sqLiteDatabase.rawQuery(sql, null, null);\n\t\t\tif (cursor == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/***循环游标得到数据*/\n\t\t\twhile (cursor.moveToNext()) {\n\t\t\t\tLog.d(Contacts.TAG,\n\t\t\t\t\t\"id=\" + cursor.getInt(0) \n\t\t\t\t\t+ \"，name=\" + cursor.getString(1)\n\t\t\t\t\t+ \"，age=\" + cursor.getInt(2));\n\t\t\t\tint id = cursor.getInt(cursor.getColumnIndex(\"id\"));\n\t\t\t}\n\t\t\t/***记得操作完将游标关闭*/\n\t\t\tcursor.close();\n\t\t}\n\t\t```\n\n- 关闭数据库\n\n\t```java\n\t//查询的游标\n\tqueryCursor.close();\n\t//数据库对象\n\tsqLiteDatabase.close();\n\t\n\t```\n- 删除数据库,通过删除文件进行删除操作\n\n\t```java\n\t\t//关闭数据库文件及操作\n\t\tdb2.close();\n\t\tString path1 = db2.getPath();\n\t\tFile file = new File(path1);\n\t\tif (file.exists() && file.isFile()) {\n\t\t\ttry {\n\t\t\t\tfile.delete();\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t```\n### 3. SQL语句中的子句 ###\n\n- `WHERE`\n\t1. 比较 / 逻辑运算符: >、<、=\n\t2. 与( AND )、或( OR 、  IN ( value1, value2 ) )、非( IS NOT )、包含( LIKE / GLOB  )\n\t3. 筛选语句,先子后父\n\n```\n\teg:\n\tSELECT * FROM COMPANY WHERE AGE >= 25 AND SALARY >= 65000;\n\tSELECT * FROM COMPANY WHERE AGE IS NOT NULL;\t\n\t\n\tSELECT * FROM COMPANY WHERE NAME LIKE 'Ki%'; \n\tSELECT * FROM COMPANY WHERE NAME GLOB 'Ki*';\n\t// LIKE 'Ki%' 与 GLOB 'Ki*' 相同 , 均表示 以 'Ki' 开始的所有记录，'Ki' 之后的字符不做限制;\n\t\n\t//列出了 AGE 的值为 25 或 27 的所有记录\n\tSELECT * FROM COMPANY WHERE AGE IN ( 25, 27 );\n\t//列出了 AGE 的值既不是 25 也不是 27 的所有记录\n\tSELECT * FROM COMPANY WHERE AGE NOT IN ( 25, 27 );\n\t//列出了 AGE 的值在 25 与 27 之间的所有记录\n\tSELECT * FROM COMPANY WHERE AGE BETWEEN 25 AND 27;\n\t\n\t//筛选结果 要包含子句筛选结果\n\tSELECT AGE FROM COMPANY WHERE \tEXISTS (SELECT AGE FROM COMPANY WHERE SALARY > 65000);\n\t// 列出了比 SALARY大于65000的值的AGE项 更大的值的所有信息\n\tSELECT * FROM COMPANY WHERE \tAGE > (SELECT AGE FROM COMPANY WHERE SALARY > 65000);\n\n```\n\n- `ORDER BY`\n排序操作。使用 `ASC | DESC`设置升序降序。\n\n```\n\tSELECT column-list FROM table_name [WHERE condition] [ORDER BY column1, column2, .. columnN] [ASC | DESC];\n\t\n```\n- `GROUP BY`\n对相同的数据进行分组。\n\n```\t\n\tSELECT column0, SUM(column1) FROM tabName \t[GROUP BY column0] \t[ORDER BY column0][ASC | DESC];\n\t\n\teg:\n\t\t//筛选出带有 NAME 与 SALARY 项的信息,根据NAME字段排序,并将相同NAME字段的SALARY合并为SUM(SALARY) ;\n\t\tSELECT NAME, SUM(SALARY) FROM COMPANY \tGROUP BY NAME \tORDER BY NAME\tASC;//升序\n\t\tSELECT NAME, SUM(SALARY) FROM COMPANY \tGROUP BY NAME \tORDER BY NAME \tDESC;//降序\n```\n- `LIKE`\n用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，LIKE 运算符将返回真（true），也就是 1。\n通配符有\" % \"、\" _ \":\n\t- \" % \" : 零个、一个或多个数字或字符；\n\t- \" _ \" : 代表一个单一的数字或字符。\n\n<font color = red>**示例**</font>:\n\n`LIKE`语句\t|\t描述\n:-|:-\nWHERE SALARY LIKE '200%'\t|查找以 200 开头的任意值\nWHERE SALARY LIKE '%200%'\t|查找任意位置包含 200 的任意值\nWHERE SALARY LIKE '_00%'\t|查找第二位和第三位为 00 的任意值\nWHERE SALARY LIKE '2_%_%'\t|查找以 2 开头，且长度至少为 3 个字符的任意值\nWHERE SALARY LIKE '%2'\t\t|查找以 2 结尾的任意值\nWHERE SALARY LIKE '_2%3'\t|查找第二位为 2，且以 3 结尾的任意值\nWHERE SALARY LIKE '2___3'\t|查找长度为 5 位数，且以 2 开头以 3 结尾的任意值\n\n\n- `GLOB`\n用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，GLOB 运算符将返回真（true），也就是 1。<font color = red>**大小写敏感**</font>。\n\n\t- 星号 （*） : 代表零个、一个或多个数字或字符。\n\t- 问号 （?） : 代表一个单一的数字或字符。\n\n<font color = red>**示例**</font>:\n\n`GLOB`语句\t|\t描述\n:-|:-\nWHERE SALARY GLOB '200*'\t|查找以 200 开头的任意值\nWHERE SALARY GLOB '\\*200\\*'\t|查找任意位置包含 200 的任意值\nWHERE SALARY GLOB '?00*'\t|查找第二位和第三位为 00 的任意值\nWHERE SALARY GLOB '2??'\t\t|查找以 2 开头，且长度至少为 3 个字符的任意值\nWHERE SALARY GLOB '*2'\t\t|查找以 2 结尾的任意值\nWHERE SALARY GLOB '?2*3'\t|查找第二位为 2，且以 3 结尾的任意值\nWHERE SALARY GLOB '2???3'\t|查找长度为 5 位数，且以 2 开头以 3 结尾的任意值\n\n\n- `HAVING`\nHAVING 子句必须放在 GROUP BY 子句之后，必须放在 ORDER BY 子句之前。\n\n```\n\tSELECT column1, column2 FROM table1, table2 WHERE [ conditions ]\n\t\tGROUP BY column1, column2 HAVING [ conditions ] ORDER BY column1, column2\n\t\n\teg:\n\t\t//name 字段 重复次数小于2的内容按名称排序\n\t\tSELECT * FROM COMPANY GROUP BY name HAVING count(name) < 2;\n```\n\n---\n### 4. SQLite 位运算符  ###\n\n\n位运算符作用于位，并逐位执行操作。真值表 & 和 | 如下：\n\np| q | p & q | p &#124; q\n:-:|:-:|:-:|:-:\n0\t|0\t|0\t|0\n0\t|1\t|0\t|1\n1\t|1\t|1\t|1\n1\t|0\t|0\t|1\n假设如果 A = 60，且 B = 13，现在以二进制格式，它们如下所示：\nA = 0011 1100;\nB = 0000 1101;\nA&B = 0000 1100;\nA|B = 0011 1101;\n~A  = 1100 0011;\n下表中列出了 SQLite 语言支持的位运算符。假设变量 A=60，变量 B=13，则：\n\n运算符\t|\t描述\t|实例\n-|-|-\n&\t|如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。|( A & B ) =12，即为 0000 1100\n&#124;\t|如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。\t|( A &#124; B ) = 61，即为 0011 1101\n~\t|二进制补码运算符是一元运算符，具有\"翻转\"位效应，即0变成1，1变成0。\t|( ~ A ) = -61，即为 1100 0011，一个有符号二进制数的补码形式。\n<<\t|二进制左移运算符。左操作数的值向左移动右操作数指定的位数。\t|A << 2=240，即为 1111 0000\n>>\t|二进制右移运算符。左操作数的值向右移动右操作数指定的位数。\t|A >> 2 =15，即为 0000 1111\n\n\n---\n","slug":"Android之存储——SQLite与其他数据库","published":1,"date":"2018-03-21T03:22:18.358Z","updated":"2018-01-31T08:41:25.157Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0kjqj200080s4lyjj5wfia","content":"<h1 id=\"SQLite-操作\"><a href=\"#SQLite-操作\" class=\"headerlink\" title=\"SQLite 操作\"></a>SQLite 操作</h1><hr>\n<ul>\n<li><p>目录</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. SQLite ( SQLite 命令中 以&quot;[]&quot;包含的内容表示可省略 )</span><br><span class=\"line\">\t- SQLiteHelper</span><br><span class=\"line\">\t- 操作</span><br><span class=\"line\">\t\t- 创建数据库</span><br><span class=\"line\">\t\t- 增</span><br><span class=\"line\">\t\t- 删</span><br><span class=\"line\">\t\t- 改</span><br><span class=\"line\">\t\t- 查</span><br><span class=\"line\">\t\t- 关闭数据库</span><br><span class=\"line\">\t\t- 删除数据库</span><br><span class=\"line\">\t- SQL语句中的子句</span><br><span class=\"line\">\t- SQLite 位运算符</span><br><span class=\"line\"></span><br><span class=\"line\">2. 其他数据库</span><br><span class=\"line\">\t- Realm</span><br><span class=\"line\">\t- DBFlow</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>参考</p>\n<ul>\n<li><a href=\"http://www.runoob.com/sqlite/sqlite-tutorial.html\" target=\"_blank\" rel=\"noopener\"> <strong>SQLite 教程 | 菜鸟教程</strong> </a></li>\n<li><a href=\"https://juejin.im/post/5a5bfc016fb9a01ca10ae0a9#heading-5\" target=\"_blank\" rel=\"noopener\"> <strong>Android ：这是一份详细 &amp; 全面的 SQLlite数据库 使用手册</strong> </a></li>\n<li><a href=\"http://blog.csdn.net/linglongxin24/article/details/53230842\" target=\"_blank\" rel=\"noopener\"> <strong>玩转SQLite系列</strong> </a></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"SQLite\"><a href=\"#SQLite\" class=\"headerlink\" title=\"SQLite\"></a>SQLite</h2><p><img src=\"https://i.imgur.com/CHgDAL0.png\" alt=\"Sqlite\"></p>\n<font color=\"red\"><strong>字段支持 </strong></font><br><font color=\"red\"> &gt; <code>NULL</code>、<code>INTEGER</code>、<code>FLOAT</code>、<code>STRING</code>、<code>BLOB</code> </font>\n\n\n\n\n<h3 id=\"1-SQLiteHelper\"><a href=\"#1-SQLiteHelper\" class=\"headerlink\" title=\"1. SQLiteHelper\"></a>1. <code>SQLiteHelper</code></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MySqliteHelper</span> <span class=\"keyword\">extends</span> <span class=\"title\">SQLiteOpenHelper</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MySqliteHelper</span><span class=\"params\">(Context context, String name, SQLiteDatabase.CursorFactory factory, <span class=\"keyword\">int</span> version)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, name, factory, version);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(SQLiteDatabase sqLiteDatabase)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onUpgrade</span><span class=\"params\">(SQLiteDatabase sqLiteDatabase, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> i1)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-数据库操作\"><a href=\"#2-数据库操作\" class=\"headerlink\" title=\"2. 数据库操作\"></a>2. 数据库操作</h3><ul>\n<li><p>创建或获取数据库</p>\n<ul>\n<li><p>打开或创建原始位置的数据库</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PersonalSQLiteHelper helper = <span class=\"keyword\">new</span> PersonalSQLiteHelper(<span class=\"keyword\">this</span>, <span class=\"string\">\"db_name\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">SQLiteDatabase db0 = helper.getReadableDatabase();</span><br><span class=\"line\"><span class=\"comment\">//获取位置信息</span></span><br><span class=\"line\">List&lt;Pair&lt;String, String&gt;&gt; attachedDbs = db0.getAttachedDbs();</span><br><span class=\"line\">String path = attachedDbs.get(<span class=\"number\">0</span>).first + attachedDbs.get(<span class=\"number\">0</span>).second;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>打开指定位置的数据库</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SQLiteDatabase db1 = SQLiteDatabase.openOrCreateDatabase(filePath, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">SQLiteDatabase db2 = SQLiteDatabase.openOrCreateDatabase(file, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"><span class=\"comment\">//获取位置信息</span></span><br><span class=\"line\">List&lt;Pair&lt;String, String&gt;&gt; attachedDbs = db1.getAttachedDbs();</span><br><span class=\"line\">String path = attachedDbs.get(<span class=\"number\">0</span>).first + attachedDbs.get(<span class=\"number\">0</span>).second;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>打开或创建指定操作模式的数据库</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SQLiteDatabase db3 = <span class=\"keyword\">this</span>.openOrCreateDatabase(<span class=\"string\">\"db_name\"</span>, MODE_PRIVATE, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"><span class=\"comment\">//获取位置信息</span></span><br><span class=\"line\">List&lt;Pair&lt;String, String&gt;&gt; attachedDbs = db3.getAttachedDbs();</span><br><span class=\"line\">String path = attachedDbs.get(<span class=\"number\">0</span>).first + attachedDbs.get(<span class=\"number\">0</span>).second;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>创建表单<code>(create)</code></p>\n<ul>\n<li>SQL 语句  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE TABLE IF NOT EXISTS 表名(\t</span><br><span class=\"line\">\t\t列名  列类型(大小)  属性,</span><br><span class=\"line\">\t\t列名  列类型(大小)  属性,</span><br><span class=\"line\">\t\t列名  列类型(大小)  属性</span><br><span class=\"line\">\t\t... )</span><br><span class=\"line\">eg:</span><br><span class=\"line\">\tCREATE TABLE IF NOT EXISTS tableName(_id integer primary key autoincrement, name varchar(20) not null , ...)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>删除表单<code>(drop)</code></p>\n<ul>\n<li>SQL 语句  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DROP TABLE IF  EXISTS 表名\t</span><br><span class=\"line\">eg:</span><br><span class=\"line\">\tDROP TABLE IF EXISTS tableName</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>增<code>(insert)</code></p>\n<ul>\n<li><p>SQL 语句</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INSERT INTO TABLE_NAME [(column1, column2, column3,...columnN)]  VALUES (value1, value2, value3,...valueN)</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">eg:</span><br><span class=\"line\">\t- INSERT INTO User VALUES (1,&apos;张三&apos;,26)</span><br><span class=\"line\">\t- INSERT INTO User(id,name,age) VALUES (1,&apos;张三&apos;,26)</span><br><span class=\"line\">```</span><br></pre></td></tr></table></figure>\n<p>  // 从一张表填充到另一个表<br>  INSERT INTO first_table_name [(column1, column2, … columnN)]  SELECT column1, column2, …columnN </p>\n<pre><code>FROM second_table_name [WHERE condition]\n</code></pre>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- API</span><br><span class=\"line\"></span><br><span class=\"line\">\t```java</span><br><span class=\"line\">\t    /**</span><br><span class=\"line\">\t     * 给user表中新增一条数据</span><br><span class=\"line\">\t     * &lt;p&gt;</span><br><span class=\"line\">\t     * long insert(String table, String nullColumnHack, ContentValues values)</span><br><span class=\"line\">\t     * 第一个参数：数据库表名</span><br><span class=\"line\">\t     * 第二个参数：当values参数为空或者里面没有内容的时候，</span><br><span class=\"line\">\t     * insert是会失败的(底层数据库不允许插入一个空行)，</span><br><span class=\"line\">\t     * 为了防止这种情况，要在这里指定一个列名，</span><br><span class=\"line\">\t     * 到时候如果发现将要插入的行为空行时，</span><br><span class=\"line\">\t     * 就会将你指定的这个列名的值设为null，然后再向数据库中插入。</span><br><span class=\"line\">\t     * 第三个参数：要插入的值</span><br><span class=\"line\">\t     * 返回值：成功操作的行号，错误返回-1</span><br><span class=\"line\">\t     *</span><br><span class=\"line\">\t     * @param v</span><br><span class=\"line\">\t     */</span><br><span class=\"line\">\t    public void insert(View v) &#123;</span><br><span class=\"line\">\t        String table = &quot;user&quot;;</span><br><span class=\"line\">\t        ContentValues contentValues = new ContentValues();</span><br><span class=\"line\">\t        contentValues.put(&quot;name&quot;, &quot;张三&quot;);</span><br><span class=\"line\">\t        contentValues.put(&quot;age&quot;, 25);</span><br><span class=\"line\">\t        long num = sqLiteDatabase.insert(table, null, contentValues);</span><br><span class=\"line\">\t        if (num == -1) &#123;</span><br><span class=\"line\">\t            Toast.makeText(this, &quot;插入失败&quot;, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">\t        &#125; else &#123;</span><br><span class=\"line\">\t            Toast.makeText(this, &quot;成功插入到第&quot; + num + &quot;行&quot;, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><font color=\"red\"><strong>API 批量操作的优化</strong></font>\n\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">long</span> startTime = System.currentTimeMillis();</span><br><span class=\"line\">String table = <span class=\"string\">\"user\"</span>;</span><br><span class=\"line\"><span class=\"comment\">/**开启一个事务**/</span></span><br><span class=\"line\">sqLiteDatabase.beginTransaction();</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">               ContentValues contentValues = <span class=\"keyword\">new</span> ContentValues();</span><br><span class=\"line\">               contentValues.put(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"张三\"</span> + i);</span><br><span class=\"line\">               contentValues.put(<span class=\"string\">\"age\"</span>, i);</span><br><span class=\"line\">               sqLiteDatabase.insertOrThrow(table, <span class=\"keyword\">null</span>, contentValues);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"comment\">/**将数据库事务设置为成功**/</span></span><br><span class=\"line\">           sqLiteDatabase.setTransactionSuccessful();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">/**结束数据库事务**/</span></span><br><span class=\"line\">           sqLiteDatabase.endTransaction();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>删<code>(delete)</code></p>\n<ul>\n<li><p>SQL 语句</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DELETE FROM table_name WHERE [condition]</span><br><span class=\"line\"></span><br><span class=\"line\">eg:</span><br><span class=\"line\">\tDELETE FROM User WHERE id=2</span><br><span class=\"line\">\tDELETE FROM COMPANY //删除所有记录</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>API</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 删除user表中id为2的记录</span></span><br><span class=\"line\"><span class=\"comment\">    * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    * int delete(String table, String whereClause, String[] whereArgs)</span></span><br><span class=\"line\"><span class=\"comment\">    * 第一个参数：删除的表名</span></span><br><span class=\"line\"><span class=\"comment\">    * 第二个参数：修改的条件的字段</span></span><br><span class=\"line\"><span class=\"comment\">    * 第三个参数：修改的条件字段对应的值</span></span><br><span class=\"line\"><span class=\"comment\">    * 返回值：影响的行数</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> v</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">delete</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">   \t<span class=\"comment\">//1</span></span><br><span class=\"line\">       <span class=\"comment\">//String table = \"user\";</span></span><br><span class=\"line\">       <span class=\"comment\">//String where = \"id=2\";</span></span><br><span class=\"line\">       <span class=\"comment\">//sqLiteDatabase.delete(table, where, null);</span></span><br><span class=\"line\">       </span><br><span class=\"line\">       <span class=\"comment\">//2</span></span><br><span class=\"line\">       String table = <span class=\"string\">\"user\"</span>;</span><br><span class=\"line\">       String where = <span class=\"string\">\"id=?\"</span>;</span><br><span class=\"line\">       String[] whereArgs = <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">\"2\"</span>&#125;;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> num = sqLiteDatabase.delete(table, where, whereArgs);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>改<code>(update)</code></p>\n<ul>\n<li><p>SQL 语句</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UPDATE table_name SET column1 = value1, column2 = value2.... WHERE [condition]</span><br><span class=\"line\">//可以使用 AND 或 OR 运算符来结合 N 个数量的条件</span><br><span class=\"line\"></span><br><span class=\"line\">eg:</span><br><span class=\"line\">\tUPDATE User SET name=&quot;李四&quot; WHERE id=2;</span><br><span class=\"line\">\tUPDATE COMPANY SET ADDRESS = &apos;Texas&apos; WHERE ID = 6;</span><br><span class=\"line\">\tUPDATE COMPANY SET ADDRESS = &apos;Texas&apos;, SALARY = 20000.00;//修改所有</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>API</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* UPDATE User SET name=\"李四\" WHERE id=2; */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 方式一</span></span><br><span class=\"line\"><span class=\"comment\">     */</span>\t\t</span><br><span class=\"line\">    <span class=\"comment\">//String table = \"user\";</span></span><br><span class=\"line\">    <span class=\"comment\">//ContentValues contentValues = new ContentValues();</span></span><br><span class=\"line\">    <span class=\"comment\">//contentValues.put(\"name\", \"李四\");</span></span><br><span class=\"line\">    <span class=\"comment\">//String where = \"id=2\";</span></span><br><span class=\"line\">    <span class=\"comment\">//sqLiteDatabase.update(table, contentValues, where, null);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 方式二</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    String table = <span class=\"string\">\"user\"</span>;</span><br><span class=\"line\">    ContentValues contentValues = <span class=\"keyword\">new</span> ContentValues();</span><br><span class=\"line\">    contentValues.put(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"李四\"</span>);</span><br><span class=\"line\">    String where = <span class=\"string\">\"id=?\"</span>;</span><br><span class=\"line\">    String[] whereArgs = <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">\"2\"</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num = sqLiteDatabase.update(table, contentValues, where, whereArgs);</span><br><span class=\"line\">    Toast.makeText(<span class=\"keyword\">this</span>, <span class=\"string\">\"修改了\"</span> + num + <span class=\"string\">\"行\"</span>, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>查<code>(select)</code></p>\n<ul>\n<li>SQL 语句  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * \t\tFROM 表名 WHERE 查询的条件表达式  GROUP BY 分组的字段 ORDER BY 排序的字段</span><br><span class=\"line\">SELECT 字段名 \tFROM 表名 WHERE 查询的条件表达式  GROUP BY 分组的字段 ORDER BY 排序的字段</span><br><span class=\"line\"></span><br><span class=\"line\">eg:</span><br><span class=\"line\">\tSELECT * FROM  User</span><br><span class=\"line\">\tSELECT * FROM  User WHERE id=2</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tSELECT name,age FROM  User WHERE age&gt;25</span><br><span class=\"line\">\tSELECT name,age FROM  User WHERE age BETWEEN 20 AND 40</span><br><span class=\"line\">\tSELECT name,age FROM  User WHERE name LIKE &quot;亮&quot;</span><br><span class=\"line\">\tSELECT name,age FROM  User WHERE name IS NULL</span><br><span class=\"line\">\tSELECT name,age FROM  User ORDER BY age</span><br><span class=\"line\"></span><br><span class=\"line\">//查询过程\t\t</span><br><span class=\"line\">public void query(View v) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tString sql = &quot;SELECT * FROM user&quot;;</span><br><span class=\"line\">\t/***这里得到的是一个游标*/</span><br><span class=\"line\">\tCursor cursor = sqLiteDatabase.rawQuery(sql, null, null);</span><br><span class=\"line\">\tif (cursor == null) &#123;</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t/***循环游标得到数据*/</span><br><span class=\"line\">\twhile (cursor.moveToNext()) &#123;</span><br><span class=\"line\">\t\tLog.d(Contacts.TAG,</span><br><span class=\"line\">\t\t\t&quot;id=&quot; + cursor.getInt(0) </span><br><span class=\"line\">\t\t\t+ &quot;，name=&quot; + cursor.getString(1)</span><br><span class=\"line\">\t\t\t+ &quot;，age=&quot; + cursor.getInt(2));</span><br><span class=\"line\">\t\tint id = cursor.getInt(cursor.getColumnIndex(&quot;id&quot;));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t/***记得操作完将游标关闭*/</span><br><span class=\"line\">\tcursor.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>关闭数据库</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询的游标</span></span><br><span class=\"line\">queryCursor.close();</span><br><span class=\"line\"><span class=\"comment\">//数据库对象</span></span><br><span class=\"line\">sqLiteDatabase.close();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>删除数据库,通过删除文件进行删除操作</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//关闭数据库文件及操作</span></span><br><span class=\"line\">db2.close();</span><br><span class=\"line\">String path1 = db2.getPath();</span><br><span class=\"line\">File file = <span class=\"keyword\">new</span> File(path1);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (file.exists() &amp;&amp; file.isFile()) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\tfile.delete();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"3-SQL语句中的子句\"><a href=\"#3-SQL语句中的子句\" class=\"headerlink\" title=\"3. SQL语句中的子句\"></a>3. SQL语句中的子句</h3><ul>\n<li><code>WHERE</code><ol>\n<li>比较 / 逻辑运算符: &gt;、&lt;、=</li>\n<li>与( AND )、或( OR 、  IN ( value1, value2 ) )、非( IS NOT )、包含( LIKE / GLOB  )</li>\n<li>筛选语句,先子后父</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\">SELECT * FROM COMPANY WHERE AGE &gt;= 25 AND SALARY &gt;= 65000;</span><br><span class=\"line\">SELECT * FROM COMPANY WHERE AGE IS NOT NULL;\t</span><br><span class=\"line\"></span><br><span class=\"line\">SELECT * FROM COMPANY WHERE NAME LIKE &apos;Ki%&apos;; </span><br><span class=\"line\">SELECT * FROM COMPANY WHERE NAME GLOB &apos;Ki*&apos;;</span><br><span class=\"line\">// LIKE &apos;Ki%&apos; 与 GLOB &apos;Ki*&apos; 相同 , 均表示 以 &apos;Ki&apos; 开始的所有记录，&apos;Ki&apos; 之后的字符不做限制;</span><br><span class=\"line\"></span><br><span class=\"line\">//列出了 AGE 的值为 25 或 27 的所有记录</span><br><span class=\"line\">SELECT * FROM COMPANY WHERE AGE IN ( 25, 27 );</span><br><span class=\"line\">//列出了 AGE 的值既不是 25 也不是 27 的所有记录</span><br><span class=\"line\">SELECT * FROM COMPANY WHERE AGE NOT IN ( 25, 27 );</span><br><span class=\"line\">//列出了 AGE 的值在 25 与 27 之间的所有记录</span><br><span class=\"line\">SELECT * FROM COMPANY WHERE AGE BETWEEN 25 AND 27;</span><br><span class=\"line\"></span><br><span class=\"line\">//筛选结果 要包含子句筛选结果</span><br><span class=\"line\">SELECT AGE FROM COMPANY WHERE \tEXISTS (SELECT AGE FROM COMPANY WHERE SALARY &gt; 65000);</span><br><span class=\"line\">// 列出了比 SALARY大于65000的值的AGE项 更大的值的所有信息</span><br><span class=\"line\">SELECT * FROM COMPANY WHERE \tAGE &gt; (SELECT AGE FROM COMPANY WHERE SALARY &gt; 65000);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>ORDER BY</code><br>排序操作。使用 <code>ASC | DESC</code>设置升序降序。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT column-list FROM table_name [WHERE condition] [ORDER BY column1, column2, .. columnN] [ASC | DESC];</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>GROUP BY</code><br>对相同的数据进行分组。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT column0, SUM(column1) FROM tabName \t[GROUP BY column0] \t[ORDER BY column0][ASC | DESC];</span><br><span class=\"line\"></span><br><span class=\"line\">eg:</span><br><span class=\"line\">\t//筛选出带有 NAME 与 SALARY 项的信息,根据NAME字段排序,并将相同NAME字段的SALARY合并为SUM(SALARY) ;</span><br><span class=\"line\">\tSELECT NAME, SUM(SALARY) FROM COMPANY \tGROUP BY NAME \tORDER BY NAME\tASC;//升序</span><br><span class=\"line\">\tSELECT NAME, SUM(SALARY) FROM COMPANY \tGROUP BY NAME \tORDER BY NAME \tDESC;//降序</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>LIKE</code><br>用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，LIKE 运算符将返回真（true），也就是 1。<br>通配符有” % “、” _ “:<ul>\n<li>“ % “ : 零个、一个或多个数字或字符；</li>\n<li>“ _ “ : 代表一个单一的数字或字符。</li>\n</ul>\n</li>\n</ul>\n<p><font color=\"red\"><strong>示例</strong></font>:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><code>LIKE</code>语句</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">WHERE SALARY LIKE ‘200%’</td>\n<td style=\"text-align:left\">查找以 200 开头的任意值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">WHERE SALARY LIKE ‘%200%’</td>\n<td style=\"text-align:left\">查找任意位置包含 200 的任意值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">WHERE SALARY LIKE ‘_00%’</td>\n<td style=\"text-align:left\">查找第二位和第三位为 00 的任意值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">WHERE SALARY LIKE ‘2_%_%’</td>\n<td style=\"text-align:left\">查找以 2 开头，且长度至少为 3 个字符的任意值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">WHERE SALARY LIKE ‘%2’</td>\n<td style=\"text-align:left\">查找以 2 结尾的任意值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">WHERE SALARY LIKE ‘_2%3’</td>\n<td style=\"text-align:left\">查找第二位为 2，且以 3 结尾的任意值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">WHERE SALARY LIKE ‘2___3’</td>\n<td style=\"text-align:left\">查找长度为 5 位数，且以 2 开头以 3 结尾的任意值</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p><code>GLOB</code><br>用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，GLOB 运算符将返回真（true），也就是 1。<font color=\"red\"><strong>大小写敏感</strong></font>。</p>\n<ul>\n<li>星号 （*） : 代表零个、一个或多个数字或字符。</li>\n<li>问号 （?） : 代表一个单一的数字或字符。</li>\n</ul>\n</li>\n</ul>\n<p><font color=\"red\"><strong>示例</strong></font>:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><code>GLOB</code>语句</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">WHERE SALARY GLOB ‘200*’</td>\n<td style=\"text-align:left\">查找以 200 开头的任意值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">WHERE SALARY GLOB ‘*200*‘</td>\n<td style=\"text-align:left\">查找任意位置包含 200 的任意值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">WHERE SALARY GLOB ‘?00*’</td>\n<td style=\"text-align:left\">查找第二位和第三位为 00 的任意值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">WHERE SALARY GLOB ‘2??’</td>\n<td style=\"text-align:left\">查找以 2 开头，且长度至少为 3 个字符的任意值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">WHERE SALARY GLOB ‘*2’</td>\n<td style=\"text-align:left\">查找以 2 结尾的任意值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">WHERE SALARY GLOB ‘?2*3’</td>\n<td style=\"text-align:left\">查找第二位为 2，且以 3 结尾的任意值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">WHERE SALARY GLOB ‘2???3’</td>\n<td style=\"text-align:left\">查找长度为 5 位数，且以 2 开头以 3 结尾的任意值</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><code>HAVING</code><br>HAVING 子句必须放在 GROUP BY 子句之后，必须放在 ORDER BY 子句之前。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT column1, column2 FROM table1, table2 WHERE [ conditions ]</span><br><span class=\"line\">\tGROUP BY column1, column2 HAVING [ conditions ] ORDER BY column1, column2</span><br><span class=\"line\"></span><br><span class=\"line\">eg:</span><br><span class=\"line\">\t//name 字段 重复次数小于2的内容按名称排序</span><br><span class=\"line\">\tSELECT * FROM COMPANY GROUP BY name HAVING count(name) &lt; 2;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"4-SQLite-位运算符\"><a href=\"#4-SQLite-位运算符\" class=\"headerlink\" title=\"4. SQLite 位运算符\"></a>4. SQLite 位运算符</h3><p>位运算符作用于位，并逐位执行操作。真值表 &amp; 和 | 如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">p</th>\n<th style=\"text-align:center\">q</th>\n<th style=\"text-align:center\">p &amp; q</th>\n<th style=\"text-align:center\">p &#124; q</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n</tr>\n</tbody>\n</table>\n<p>假设如果 A = 60，且 B = 13，现在以二进制格式，它们如下所示：<br>A = 0011 1100;<br>B = 0000 1101;<br>A&amp;B = 0000 1100;<br>A|B = 0011 1101;<br>~A  = 1100 0011;<br>下表中列出了 SQLite 语言支持的位运算符。假设变量 A=60，变量 B=13，则：</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n<th>实例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&amp;</td>\n<td>如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td>\n<td>( A &amp; B ) =12，即为 0000 1100</td>\n</tr>\n<tr>\n<td>&#124;</td>\n<td>如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td>\n<td>( A &#124; B ) = 61，即为 0011 1101</td>\n</tr>\n<tr>\n<td>~</td>\n<td>二进制补码运算符是一元运算符，具有”翻转”位效应，即0变成1，1变成0。</td>\n<td>( ~ A ) = -61，即为 1100 0011，一个有符号二进制数的补码形式。</td>\n</tr>\n<tr>\n<td>&lt;&lt;</td>\n<td>二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td>\n<td>A &lt;&lt; 2=240，即为 1111 0000</td>\n</tr>\n<tr>\n<td>&gt;&gt;</td>\n<td>二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td>\n<td>A &gt;&gt; 2 =15，即为 0000 1111</td>\n</tr>\n</tbody>\n</table>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"SQLite-操作\"><a href=\"#SQLite-操作\" class=\"headerlink\" title=\"SQLite 操作\"></a>SQLite 操作</h1><hr>\n<ul>\n<li><p>目录</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. SQLite ( SQLite 命令中 以&quot;[]&quot;包含的内容表示可省略 )</span><br><span class=\"line\">\t- SQLiteHelper</span><br><span class=\"line\">\t- 操作</span><br><span class=\"line\">\t\t- 创建数据库</span><br><span class=\"line\">\t\t- 增</span><br><span class=\"line\">\t\t- 删</span><br><span class=\"line\">\t\t- 改</span><br><span class=\"line\">\t\t- 查</span><br><span class=\"line\">\t\t- 关闭数据库</span><br><span class=\"line\">\t\t- 删除数据库</span><br><span class=\"line\">\t- SQL语句中的子句</span><br><span class=\"line\">\t- SQLite 位运算符</span><br><span class=\"line\"></span><br><span class=\"line\">2. 其他数据库</span><br><span class=\"line\">\t- Realm</span><br><span class=\"line\">\t- DBFlow</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>参考</p>\n<ul>\n<li><a href=\"http://www.runoob.com/sqlite/sqlite-tutorial.html\" target=\"_blank\" rel=\"noopener\"> <strong>SQLite 教程 | 菜鸟教程</strong> </a></li>\n<li><a href=\"https://juejin.im/post/5a5bfc016fb9a01ca10ae0a9#heading-5\" target=\"_blank\" rel=\"noopener\"> <strong>Android ：这是一份详细 &amp; 全面的 SQLlite数据库 使用手册</strong> </a></li>\n<li><a href=\"http://blog.csdn.net/linglongxin24/article/details/53230842\" target=\"_blank\" rel=\"noopener\"> <strong>玩转SQLite系列</strong> </a></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"SQLite\"><a href=\"#SQLite\" class=\"headerlink\" title=\"SQLite\"></a>SQLite</h2><p><img src=\"https://i.imgur.com/CHgDAL0.png\" alt=\"Sqlite\"></p>\n<font color=\"red\"><strong>字段支持 </strong></font><br><font color=\"red\"> &gt; <code>NULL</code>、<code>INTEGER</code>、<code>FLOAT</code>、<code>STRING</code>、<code>BLOB</code> </font>\n\n\n\n\n<h3 id=\"1-SQLiteHelper\"><a href=\"#1-SQLiteHelper\" class=\"headerlink\" title=\"1. SQLiteHelper\"></a>1. <code>SQLiteHelper</code></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MySqliteHelper</span> <span class=\"keyword\">extends</span> <span class=\"title\">SQLiteOpenHelper</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MySqliteHelper</span><span class=\"params\">(Context context, String name, SQLiteDatabase.CursorFactory factory, <span class=\"keyword\">int</span> version)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, name, factory, version);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(SQLiteDatabase sqLiteDatabase)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onUpgrade</span><span class=\"params\">(SQLiteDatabase sqLiteDatabase, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> i1)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-数据库操作\"><a href=\"#2-数据库操作\" class=\"headerlink\" title=\"2. 数据库操作\"></a>2. 数据库操作</h3><ul>\n<li><p>创建或获取数据库</p>\n<ul>\n<li><p>打开或创建原始位置的数据库</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PersonalSQLiteHelper helper = <span class=\"keyword\">new</span> PersonalSQLiteHelper(<span class=\"keyword\">this</span>, <span class=\"string\">\"db_name\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">SQLiteDatabase db0 = helper.getReadableDatabase();</span><br><span class=\"line\"><span class=\"comment\">//获取位置信息</span></span><br><span class=\"line\">List&lt;Pair&lt;String, String&gt;&gt; attachedDbs = db0.getAttachedDbs();</span><br><span class=\"line\">String path = attachedDbs.get(<span class=\"number\">0</span>).first + attachedDbs.get(<span class=\"number\">0</span>).second;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>打开指定位置的数据库</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SQLiteDatabase db1 = SQLiteDatabase.openOrCreateDatabase(filePath, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">SQLiteDatabase db2 = SQLiteDatabase.openOrCreateDatabase(file, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"><span class=\"comment\">//获取位置信息</span></span><br><span class=\"line\">List&lt;Pair&lt;String, String&gt;&gt; attachedDbs = db1.getAttachedDbs();</span><br><span class=\"line\">String path = attachedDbs.get(<span class=\"number\">0</span>).first + attachedDbs.get(<span class=\"number\">0</span>).second;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>打开或创建指定操作模式的数据库</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SQLiteDatabase db3 = <span class=\"keyword\">this</span>.openOrCreateDatabase(<span class=\"string\">\"db_name\"</span>, MODE_PRIVATE, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"><span class=\"comment\">//获取位置信息</span></span><br><span class=\"line\">List&lt;Pair&lt;String, String&gt;&gt; attachedDbs = db3.getAttachedDbs();</span><br><span class=\"line\">String path = attachedDbs.get(<span class=\"number\">0</span>).first + attachedDbs.get(<span class=\"number\">0</span>).second;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>创建表单<code>(create)</code></p>\n<ul>\n<li>SQL 语句  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE TABLE IF NOT EXISTS 表名(\t</span><br><span class=\"line\">\t\t列名  列类型(大小)  属性,</span><br><span class=\"line\">\t\t列名  列类型(大小)  属性,</span><br><span class=\"line\">\t\t列名  列类型(大小)  属性</span><br><span class=\"line\">\t\t... )</span><br><span class=\"line\">eg:</span><br><span class=\"line\">\tCREATE TABLE IF NOT EXISTS tableName(_id integer primary key autoincrement, name varchar(20) not null , ...)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>删除表单<code>(drop)</code></p>\n<ul>\n<li>SQL 语句  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DROP TABLE IF  EXISTS 表名\t</span><br><span class=\"line\">eg:</span><br><span class=\"line\">\tDROP TABLE IF EXISTS tableName</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>增<code>(insert)</code></p>\n<ul>\n<li><p>SQL 语句</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INSERT INTO TABLE_NAME [(column1, column2, column3,...columnN)]  VALUES (value1, value2, value3,...valueN)</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">eg:</span><br><span class=\"line\">\t- INSERT INTO User VALUES (1,&apos;张三&apos;,26)</span><br><span class=\"line\">\t- INSERT INTO User(id,name,age) VALUES (1,&apos;张三&apos;,26)</span><br><span class=\"line\">```</span><br></pre></td></tr></table></figure>\n<p>  // 从一张表填充到另一个表<br>  INSERT INTO first_table_name [(column1, column2, … columnN)]  SELECT column1, column2, …columnN </p>\n<pre><code>FROM second_table_name [WHERE condition]\n</code></pre>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- API</span><br><span class=\"line\"></span><br><span class=\"line\">\t```java</span><br><span class=\"line\">\t    /**</span><br><span class=\"line\">\t     * 给user表中新增一条数据</span><br><span class=\"line\">\t     * &lt;p&gt;</span><br><span class=\"line\">\t     * long insert(String table, String nullColumnHack, ContentValues values)</span><br><span class=\"line\">\t     * 第一个参数：数据库表名</span><br><span class=\"line\">\t     * 第二个参数：当values参数为空或者里面没有内容的时候，</span><br><span class=\"line\">\t     * insert是会失败的(底层数据库不允许插入一个空行)，</span><br><span class=\"line\">\t     * 为了防止这种情况，要在这里指定一个列名，</span><br><span class=\"line\">\t     * 到时候如果发现将要插入的行为空行时，</span><br><span class=\"line\">\t     * 就会将你指定的这个列名的值设为null，然后再向数据库中插入。</span><br><span class=\"line\">\t     * 第三个参数：要插入的值</span><br><span class=\"line\">\t     * 返回值：成功操作的行号，错误返回-1</span><br><span class=\"line\">\t     *</span><br><span class=\"line\">\t     * @param v</span><br><span class=\"line\">\t     */</span><br><span class=\"line\">\t    public void insert(View v) &#123;</span><br><span class=\"line\">\t        String table = &quot;user&quot;;</span><br><span class=\"line\">\t        ContentValues contentValues = new ContentValues();</span><br><span class=\"line\">\t        contentValues.put(&quot;name&quot;, &quot;张三&quot;);</span><br><span class=\"line\">\t        contentValues.put(&quot;age&quot;, 25);</span><br><span class=\"line\">\t        long num = sqLiteDatabase.insert(table, null, contentValues);</span><br><span class=\"line\">\t        if (num == -1) &#123;</span><br><span class=\"line\">\t            Toast.makeText(this, &quot;插入失败&quot;, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">\t        &#125; else &#123;</span><br><span class=\"line\">\t            Toast.makeText(this, &quot;成功插入到第&quot; + num + &quot;行&quot;, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><font color=\"red\"><strong>API 批量操作的优化</strong></font>\n\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">long</span> startTime = System.currentTimeMillis();</span><br><span class=\"line\">String table = <span class=\"string\">\"user\"</span>;</span><br><span class=\"line\"><span class=\"comment\">/**开启一个事务**/</span></span><br><span class=\"line\">sqLiteDatabase.beginTransaction();</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">               ContentValues contentValues = <span class=\"keyword\">new</span> ContentValues();</span><br><span class=\"line\">               contentValues.put(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"张三\"</span> + i);</span><br><span class=\"line\">               contentValues.put(<span class=\"string\">\"age\"</span>, i);</span><br><span class=\"line\">               sqLiteDatabase.insertOrThrow(table, <span class=\"keyword\">null</span>, contentValues);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"comment\">/**将数据库事务设置为成功**/</span></span><br><span class=\"line\">           sqLiteDatabase.setTransactionSuccessful();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">/**结束数据库事务**/</span></span><br><span class=\"line\">           sqLiteDatabase.endTransaction();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>删<code>(delete)</code></p>\n<ul>\n<li><p>SQL 语句</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DELETE FROM table_name WHERE [condition]</span><br><span class=\"line\"></span><br><span class=\"line\">eg:</span><br><span class=\"line\">\tDELETE FROM User WHERE id=2</span><br><span class=\"line\">\tDELETE FROM COMPANY //删除所有记录</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>API</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 删除user表中id为2的记录</span></span><br><span class=\"line\"><span class=\"comment\">    * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    * int delete(String table, String whereClause, String[] whereArgs)</span></span><br><span class=\"line\"><span class=\"comment\">    * 第一个参数：删除的表名</span></span><br><span class=\"line\"><span class=\"comment\">    * 第二个参数：修改的条件的字段</span></span><br><span class=\"line\"><span class=\"comment\">    * 第三个参数：修改的条件字段对应的值</span></span><br><span class=\"line\"><span class=\"comment\">    * 返回值：影响的行数</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> v</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">delete</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">   \t<span class=\"comment\">//1</span></span><br><span class=\"line\">       <span class=\"comment\">//String table = \"user\";</span></span><br><span class=\"line\">       <span class=\"comment\">//String where = \"id=2\";</span></span><br><span class=\"line\">       <span class=\"comment\">//sqLiteDatabase.delete(table, where, null);</span></span><br><span class=\"line\">       </span><br><span class=\"line\">       <span class=\"comment\">//2</span></span><br><span class=\"line\">       String table = <span class=\"string\">\"user\"</span>;</span><br><span class=\"line\">       String where = <span class=\"string\">\"id=?\"</span>;</span><br><span class=\"line\">       String[] whereArgs = <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">\"2\"</span>&#125;;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> num = sqLiteDatabase.delete(table, where, whereArgs);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>改<code>(update)</code></p>\n<ul>\n<li><p>SQL 语句</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UPDATE table_name SET column1 = value1, column2 = value2.... WHERE [condition]</span><br><span class=\"line\">//可以使用 AND 或 OR 运算符来结合 N 个数量的条件</span><br><span class=\"line\"></span><br><span class=\"line\">eg:</span><br><span class=\"line\">\tUPDATE User SET name=&quot;李四&quot; WHERE id=2;</span><br><span class=\"line\">\tUPDATE COMPANY SET ADDRESS = &apos;Texas&apos; WHERE ID = 6;</span><br><span class=\"line\">\tUPDATE COMPANY SET ADDRESS = &apos;Texas&apos;, SALARY = 20000.00;//修改所有</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>API</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* UPDATE User SET name=\"李四\" WHERE id=2; */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 方式一</span></span><br><span class=\"line\"><span class=\"comment\">     */</span>\t\t</span><br><span class=\"line\">    <span class=\"comment\">//String table = \"user\";</span></span><br><span class=\"line\">    <span class=\"comment\">//ContentValues contentValues = new ContentValues();</span></span><br><span class=\"line\">    <span class=\"comment\">//contentValues.put(\"name\", \"李四\");</span></span><br><span class=\"line\">    <span class=\"comment\">//String where = \"id=2\";</span></span><br><span class=\"line\">    <span class=\"comment\">//sqLiteDatabase.update(table, contentValues, where, null);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 方式二</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    String table = <span class=\"string\">\"user\"</span>;</span><br><span class=\"line\">    ContentValues contentValues = <span class=\"keyword\">new</span> ContentValues();</span><br><span class=\"line\">    contentValues.put(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"李四\"</span>);</span><br><span class=\"line\">    String where = <span class=\"string\">\"id=?\"</span>;</span><br><span class=\"line\">    String[] whereArgs = <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">\"2\"</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num = sqLiteDatabase.update(table, contentValues, where, whereArgs);</span><br><span class=\"line\">    Toast.makeText(<span class=\"keyword\">this</span>, <span class=\"string\">\"修改了\"</span> + num + <span class=\"string\">\"行\"</span>, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>查<code>(select)</code></p>\n<ul>\n<li>SQL 语句  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * \t\tFROM 表名 WHERE 查询的条件表达式  GROUP BY 分组的字段 ORDER BY 排序的字段</span><br><span class=\"line\">SELECT 字段名 \tFROM 表名 WHERE 查询的条件表达式  GROUP BY 分组的字段 ORDER BY 排序的字段</span><br><span class=\"line\"></span><br><span class=\"line\">eg:</span><br><span class=\"line\">\tSELECT * FROM  User</span><br><span class=\"line\">\tSELECT * FROM  User WHERE id=2</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tSELECT name,age FROM  User WHERE age&gt;25</span><br><span class=\"line\">\tSELECT name,age FROM  User WHERE age BETWEEN 20 AND 40</span><br><span class=\"line\">\tSELECT name,age FROM  User WHERE name LIKE &quot;亮&quot;</span><br><span class=\"line\">\tSELECT name,age FROM  User WHERE name IS NULL</span><br><span class=\"line\">\tSELECT name,age FROM  User ORDER BY age</span><br><span class=\"line\"></span><br><span class=\"line\">//查询过程\t\t</span><br><span class=\"line\">public void query(View v) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tString sql = &quot;SELECT * FROM user&quot;;</span><br><span class=\"line\">\t/***这里得到的是一个游标*/</span><br><span class=\"line\">\tCursor cursor = sqLiteDatabase.rawQuery(sql, null, null);</span><br><span class=\"line\">\tif (cursor == null) &#123;</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t/***循环游标得到数据*/</span><br><span class=\"line\">\twhile (cursor.moveToNext()) &#123;</span><br><span class=\"line\">\t\tLog.d(Contacts.TAG,</span><br><span class=\"line\">\t\t\t&quot;id=&quot; + cursor.getInt(0) </span><br><span class=\"line\">\t\t\t+ &quot;，name=&quot; + cursor.getString(1)</span><br><span class=\"line\">\t\t\t+ &quot;，age=&quot; + cursor.getInt(2));</span><br><span class=\"line\">\t\tint id = cursor.getInt(cursor.getColumnIndex(&quot;id&quot;));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t/***记得操作完将游标关闭*/</span><br><span class=\"line\">\tcursor.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>关闭数据库</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询的游标</span></span><br><span class=\"line\">queryCursor.close();</span><br><span class=\"line\"><span class=\"comment\">//数据库对象</span></span><br><span class=\"line\">sqLiteDatabase.close();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>删除数据库,通过删除文件进行删除操作</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//关闭数据库文件及操作</span></span><br><span class=\"line\">db2.close();</span><br><span class=\"line\">String path1 = db2.getPath();</span><br><span class=\"line\">File file = <span class=\"keyword\">new</span> File(path1);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (file.exists() &amp;&amp; file.isFile()) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\tfile.delete();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"3-SQL语句中的子句\"><a href=\"#3-SQL语句中的子句\" class=\"headerlink\" title=\"3. SQL语句中的子句\"></a>3. SQL语句中的子句</h3><ul>\n<li><code>WHERE</code><ol>\n<li>比较 / 逻辑运算符: &gt;、&lt;、=</li>\n<li>与( AND )、或( OR 、  IN ( value1, value2 ) )、非( IS NOT )、包含( LIKE / GLOB  )</li>\n<li>筛选语句,先子后父</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\">SELECT * FROM COMPANY WHERE AGE &gt;= 25 AND SALARY &gt;= 65000;</span><br><span class=\"line\">SELECT * FROM COMPANY WHERE AGE IS NOT NULL;\t</span><br><span class=\"line\"></span><br><span class=\"line\">SELECT * FROM COMPANY WHERE NAME LIKE &apos;Ki%&apos;; </span><br><span class=\"line\">SELECT * FROM COMPANY WHERE NAME GLOB &apos;Ki*&apos;;</span><br><span class=\"line\">// LIKE &apos;Ki%&apos; 与 GLOB &apos;Ki*&apos; 相同 , 均表示 以 &apos;Ki&apos; 开始的所有记录，&apos;Ki&apos; 之后的字符不做限制;</span><br><span class=\"line\"></span><br><span class=\"line\">//列出了 AGE 的值为 25 或 27 的所有记录</span><br><span class=\"line\">SELECT * FROM COMPANY WHERE AGE IN ( 25, 27 );</span><br><span class=\"line\">//列出了 AGE 的值既不是 25 也不是 27 的所有记录</span><br><span class=\"line\">SELECT * FROM COMPANY WHERE AGE NOT IN ( 25, 27 );</span><br><span class=\"line\">//列出了 AGE 的值在 25 与 27 之间的所有记录</span><br><span class=\"line\">SELECT * FROM COMPANY WHERE AGE BETWEEN 25 AND 27;</span><br><span class=\"line\"></span><br><span class=\"line\">//筛选结果 要包含子句筛选结果</span><br><span class=\"line\">SELECT AGE FROM COMPANY WHERE \tEXISTS (SELECT AGE FROM COMPANY WHERE SALARY &gt; 65000);</span><br><span class=\"line\">// 列出了比 SALARY大于65000的值的AGE项 更大的值的所有信息</span><br><span class=\"line\">SELECT * FROM COMPANY WHERE \tAGE &gt; (SELECT AGE FROM COMPANY WHERE SALARY &gt; 65000);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>ORDER BY</code><br>排序操作。使用 <code>ASC | DESC</code>设置升序降序。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT column-list FROM table_name [WHERE condition] [ORDER BY column1, column2, .. columnN] [ASC | DESC];</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>GROUP BY</code><br>对相同的数据进行分组。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT column0, SUM(column1) FROM tabName \t[GROUP BY column0] \t[ORDER BY column0][ASC | DESC];</span><br><span class=\"line\"></span><br><span class=\"line\">eg:</span><br><span class=\"line\">\t//筛选出带有 NAME 与 SALARY 项的信息,根据NAME字段排序,并将相同NAME字段的SALARY合并为SUM(SALARY) ;</span><br><span class=\"line\">\tSELECT NAME, SUM(SALARY) FROM COMPANY \tGROUP BY NAME \tORDER BY NAME\tASC;//升序</span><br><span class=\"line\">\tSELECT NAME, SUM(SALARY) FROM COMPANY \tGROUP BY NAME \tORDER BY NAME \tDESC;//降序</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>LIKE</code><br>用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，LIKE 运算符将返回真（true），也就是 1。<br>通配符有” % “、” _ “:<ul>\n<li>“ % “ : 零个、一个或多个数字或字符；</li>\n<li>“ _ “ : 代表一个单一的数字或字符。</li>\n</ul>\n</li>\n</ul>\n<p><font color=\"red\"><strong>示例</strong></font>:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><code>LIKE</code>语句</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">WHERE SALARY LIKE ‘200%’</td>\n<td style=\"text-align:left\">查找以 200 开头的任意值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">WHERE SALARY LIKE ‘%200%’</td>\n<td style=\"text-align:left\">查找任意位置包含 200 的任意值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">WHERE SALARY LIKE ‘_00%’</td>\n<td style=\"text-align:left\">查找第二位和第三位为 00 的任意值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">WHERE SALARY LIKE ‘2_%_%’</td>\n<td style=\"text-align:left\">查找以 2 开头，且长度至少为 3 个字符的任意值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">WHERE SALARY LIKE ‘%2’</td>\n<td style=\"text-align:left\">查找以 2 结尾的任意值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">WHERE SALARY LIKE ‘_2%3’</td>\n<td style=\"text-align:left\">查找第二位为 2，且以 3 结尾的任意值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">WHERE SALARY LIKE ‘2___3’</td>\n<td style=\"text-align:left\">查找长度为 5 位数，且以 2 开头以 3 结尾的任意值</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p><code>GLOB</code><br>用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，GLOB 运算符将返回真（true），也就是 1。<font color=\"red\"><strong>大小写敏感</strong></font>。</p>\n<ul>\n<li>星号 （*） : 代表零个、一个或多个数字或字符。</li>\n<li>问号 （?） : 代表一个单一的数字或字符。</li>\n</ul>\n</li>\n</ul>\n<p><font color=\"red\"><strong>示例</strong></font>:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><code>GLOB</code>语句</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">WHERE SALARY GLOB ‘200*’</td>\n<td style=\"text-align:left\">查找以 200 开头的任意值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">WHERE SALARY GLOB ‘*200*‘</td>\n<td style=\"text-align:left\">查找任意位置包含 200 的任意值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">WHERE SALARY GLOB ‘?00*’</td>\n<td style=\"text-align:left\">查找第二位和第三位为 00 的任意值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">WHERE SALARY GLOB ‘2??’</td>\n<td style=\"text-align:left\">查找以 2 开头，且长度至少为 3 个字符的任意值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">WHERE SALARY GLOB ‘*2’</td>\n<td style=\"text-align:left\">查找以 2 结尾的任意值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">WHERE SALARY GLOB ‘?2*3’</td>\n<td style=\"text-align:left\">查找第二位为 2，且以 3 结尾的任意值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">WHERE SALARY GLOB ‘2???3’</td>\n<td style=\"text-align:left\">查找长度为 5 位数，且以 2 开头以 3 结尾的任意值</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><code>HAVING</code><br>HAVING 子句必须放在 GROUP BY 子句之后，必须放在 ORDER BY 子句之前。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT column1, column2 FROM table1, table2 WHERE [ conditions ]</span><br><span class=\"line\">\tGROUP BY column1, column2 HAVING [ conditions ] ORDER BY column1, column2</span><br><span class=\"line\"></span><br><span class=\"line\">eg:</span><br><span class=\"line\">\t//name 字段 重复次数小于2的内容按名称排序</span><br><span class=\"line\">\tSELECT * FROM COMPANY GROUP BY name HAVING count(name) &lt; 2;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"4-SQLite-位运算符\"><a href=\"#4-SQLite-位运算符\" class=\"headerlink\" title=\"4. SQLite 位运算符\"></a>4. SQLite 位运算符</h3><p>位运算符作用于位，并逐位执行操作。真值表 &amp; 和 | 如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">p</th>\n<th style=\"text-align:center\">q</th>\n<th style=\"text-align:center\">p &amp; q</th>\n<th style=\"text-align:center\">p &#124; q</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n</tr>\n</tbody>\n</table>\n<p>假设如果 A = 60，且 B = 13，现在以二进制格式，它们如下所示：<br>A = 0011 1100;<br>B = 0000 1101;<br>A&amp;B = 0000 1100;<br>A|B = 0011 1101;<br>~A  = 1100 0011;<br>下表中列出了 SQLite 语言支持的位运算符。假设变量 A=60，变量 B=13，则：</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n<th>实例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&amp;</td>\n<td>如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td>\n<td>( A &amp; B ) =12，即为 0000 1100</td>\n</tr>\n<tr>\n<td>&#124;</td>\n<td>如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td>\n<td>( A &#124; B ) = 61，即为 0011 1101</td>\n</tr>\n<tr>\n<td>~</td>\n<td>二进制补码运算符是一元运算符，具有”翻转”位效应，即0变成1，1变成0。</td>\n<td>( ~ A ) = -61，即为 1100 0011，一个有符号二进制数的补码形式。</td>\n</tr>\n<tr>\n<td>&lt;&lt;</td>\n<td>二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td>\n<td>A &lt;&lt; 2=240，即为 1111 0000</td>\n</tr>\n<tr>\n<td>&gt;&gt;</td>\n<td>二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td>\n<td>A &gt;&gt; 2 =15，即为 0000 1111</td>\n</tr>\n</tbody>\n</table>\n<hr>\n"},{"_content":"# 内存与内存机制 #\n\n\n### 内存机制 ###\n\n\n---\n\n### 内存占用过多的原因 ###\n\n\n- 明明可以少创建对象，却创建多个；\n\t\n\t\t1. ArrayMap/SparseArray 替代 HashMap，避免装箱解箱；\n\t\t2. StringBuilder 替代 String拼接;\n\t\t3. DefineView # onDraw()中避免创建对象造成的内存抖动。\n\n- 明明可以复用，却不提取而重复操作；\n\n\t\t1. 相同的代码重复执行 → 抽取函数；\n\t\t2. 相同xml的多次填充 → xml转View；\n\t\t3. convertView不复用 → ViewHolder。\n\n- 明明可以释放，却不释放；\n\n\t\t1. IO流/cursor游标；\n\t\t2. Listeners/观察者；\n\t\t3. handler.removeCallbacksAndMessages(null)；\n\t\t4. 动画(易造成内存泄露)。\n\n- 明明可以减少内存占用大小，却不优化；\n\n\t\t1. 静态属性代替枚举，减少内存占用；\n\t\t2. bitmap/drawable 处理\n\t\t\t1. BitmapFactory#decodeResource();\n\t\t\t2. BitmapFactory.Options;\n\t\t\t3. Bitmap.Config.RBG_565/ARGB_4444;\n\t\t\t4. Bitmap#recycle();\n\n- 可以使用弱引用代替使用强引用。\n\n\n\n---\n","source":"_posts/Android之存储——内存&内存机制.md","raw":"# 内存与内存机制 #\n\n\n### 内存机制 ###\n\n\n---\n\n### 内存占用过多的原因 ###\n\n\n- 明明可以少创建对象，却创建多个；\n\t\n\t\t1. ArrayMap/SparseArray 替代 HashMap，避免装箱解箱；\n\t\t2. StringBuilder 替代 String拼接;\n\t\t3. DefineView # onDraw()中避免创建对象造成的内存抖动。\n\n- 明明可以复用，却不提取而重复操作；\n\n\t\t1. 相同的代码重复执行 → 抽取函数；\n\t\t2. 相同xml的多次填充 → xml转View；\n\t\t3. convertView不复用 → ViewHolder。\n\n- 明明可以释放，却不释放；\n\n\t\t1. IO流/cursor游标；\n\t\t2. Listeners/观察者；\n\t\t3. handler.removeCallbacksAndMessages(null)；\n\t\t4. 动画(易造成内存泄露)。\n\n- 明明可以减少内存占用大小，却不优化；\n\n\t\t1. 静态属性代替枚举，减少内存占用；\n\t\t2. bitmap/drawable 处理\n\t\t\t1. BitmapFactory#decodeResource();\n\t\t\t2. BitmapFactory.Options;\n\t\t\t3. Bitmap.Config.RBG_565/ARGB_4444;\n\t\t\t4. Bitmap#recycle();\n\n- 可以使用弱引用代替使用强引用。\n\n\n\n---\n","slug":"Android之存储——内存&内存机制","published":1,"date":"2018-03-21T03:22:18.363Z","updated":"2018-03-15T09:33:39.195Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0kjqj300090s4lu4u45p1v","content":"<h1 id=\"内存与内存机制\"><a href=\"#内存与内存机制\" class=\"headerlink\" title=\"内存与内存机制\"></a>内存与内存机制</h1><h3 id=\"内存机制\"><a href=\"#内存机制\" class=\"headerlink\" title=\"内存机制\"></a>内存机制</h3><hr>\n<h3 id=\"内存占用过多的原因\"><a href=\"#内存占用过多的原因\" class=\"headerlink\" title=\"内存占用过多的原因\"></a>内存占用过多的原因</h3><ul>\n<li><p>明明可以少创建对象，却创建多个；</p>\n<pre><code>1. ArrayMap/SparseArray 替代 HashMap，避免装箱解箱；\n2. StringBuilder 替代 String拼接;\n3. DefineView # onDraw()中避免创建对象造成的内存抖动。\n</code></pre></li>\n<li><p>明明可以复用，却不提取而重复操作；</p>\n<pre><code>1. 相同的代码重复执行 → 抽取函数；\n2. 相同xml的多次填充 → xml转View；\n3. convertView不复用 → ViewHolder。\n</code></pre></li>\n<li><p>明明可以释放，却不释放；</p>\n<pre><code>1. IO流/cursor游标；\n2. Listeners/观察者；\n3. handler.removeCallbacksAndMessages(null)；\n4. 动画(易造成内存泄露)。\n</code></pre></li>\n<li><p>明明可以减少内存占用大小，却不优化；</p>\n<pre><code>1. 静态属性代替枚举，减少内存占用；\n2. bitmap/drawable 处理\n    1. BitmapFactory#decodeResource();\n    2. BitmapFactory.Options;\n    3. Bitmap.Config.RBG_565/ARGB_4444;\n    4. Bitmap#recycle();\n</code></pre></li>\n<li><p>可以使用弱引用代替使用强引用。</p>\n</li>\n</ul>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"内存与内存机制\"><a href=\"#内存与内存机制\" class=\"headerlink\" title=\"内存与内存机制\"></a>内存与内存机制</h1><h3 id=\"内存机制\"><a href=\"#内存机制\" class=\"headerlink\" title=\"内存机制\"></a>内存机制</h3><hr>\n<h3 id=\"内存占用过多的原因\"><a href=\"#内存占用过多的原因\" class=\"headerlink\" title=\"内存占用过多的原因\"></a>内存占用过多的原因</h3><ul>\n<li><p>明明可以少创建对象，却创建多个；</p>\n<pre><code>1. ArrayMap/SparseArray 替代 HashMap，避免装箱解箱；\n2. StringBuilder 替代 String拼接;\n3. DefineView # onDraw()中避免创建对象造成的内存抖动。\n</code></pre></li>\n<li><p>明明可以复用，却不提取而重复操作；</p>\n<pre><code>1. 相同的代码重复执行 → 抽取函数；\n2. 相同xml的多次填充 → xml转View；\n3. convertView不复用 → ViewHolder。\n</code></pre></li>\n<li><p>明明可以释放，却不释放；</p>\n<pre><code>1. IO流/cursor游标；\n2. Listeners/观察者；\n3. handler.removeCallbacksAndMessages(null)；\n4. 动画(易造成内存泄露)。\n</code></pre></li>\n<li><p>明明可以减少内存占用大小，却不优化；</p>\n<pre><code>1. 静态属性代替枚举，减少内存占用；\n2. bitmap/drawable 处理\n    1. BitmapFactory#decodeResource();\n    2. BitmapFactory.Options;\n    3. Bitmap.Config.RBG_565/ARGB_4444;\n    4. Bitmap#recycle();\n</code></pre></li>\n<li><p>可以使用弱引用代替使用强引用。</p>\n</li>\n</ul>\n<hr>\n"},{"_content":"# 内部存储\n![存储方式](https://i.imgur.com/C9ggy4K.jpg)\n### <font color=\"red\"> 描述&注意事项 </font> ###\n- 内部存储是只有当前应用可以访问到的存储方式,SP有能被外部访问的模式;\n- 应用卸载后内部存储内容都将被删除;\n- 包括`sharedPreferences`,`SQLite`;\n\n\n### <font color=\"red\"> 路径 </font> ###\n\n\n\t- /data/app: \t\t\t\t\t\t\t存放着所有安装的app的apk文件\n\n\t- /data/data/包名/shared_prefs \t\t\t\tAPP的SP信息\n\t- /data/data/包名/databases \t\t\t\t\tAPP的数据库信息\n\t- /data/data/包名/files\t\t\t\t\t\tAPP的文件信息\n\t- /data/data/包名/cache \t\t\t\t\t\tAPP的缓存信息\n\n\n\n注意: 没有root的手机不能打开内部存储的文件夹;\n\n\n### <font color=\"red\"> 使用方式 </font> ###\n\n\n\t内部存储的文件存储位置:\tcontext.getFileDir();\n\t内部存储的缓存存储位置:\tcontext.getCacheDir();\n","source":"_posts/Android之存储——内部存储.md","raw":"# 内部存储\n![存储方式](https://i.imgur.com/C9ggy4K.jpg)\n### <font color=\"red\"> 描述&注意事项 </font> ###\n- 内部存储是只有当前应用可以访问到的存储方式,SP有能被外部访问的模式;\n- 应用卸载后内部存储内容都将被删除;\n- 包括`sharedPreferences`,`SQLite`;\n\n\n### <font color=\"red\"> 路径 </font> ###\n\n\n\t- /data/app: \t\t\t\t\t\t\t存放着所有安装的app的apk文件\n\n\t- /data/data/包名/shared_prefs \t\t\t\tAPP的SP信息\n\t- /data/data/包名/databases \t\t\t\t\tAPP的数据库信息\n\t- /data/data/包名/files\t\t\t\t\t\tAPP的文件信息\n\t- /data/data/包名/cache \t\t\t\t\t\tAPP的缓存信息\n\n\n\n注意: 没有root的手机不能打开内部存储的文件夹;\n\n\n### <font color=\"red\"> 使用方式 </font> ###\n\n\n\t内部存储的文件存储位置:\tcontext.getFileDir();\n\t内部存储的缓存存储位置:\tcontext.getCacheDir();\n","slug":"Android之存储——内部存储","published":1,"date":"2018-03-21T03:22:18.361Z","updated":"2018-01-31T08:30:13.574Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0kjqj4000a0s4lira0cohh","content":"<h1 id=\"内部存储\"><a href=\"#内部存储\" class=\"headerlink\" title=\"内部存储\"></a>内部存储</h1><p><img src=\"https://i.imgur.com/C9ggy4K.jpg\" alt=\"存储方式\"></p>\n<h3 id=\"描述-amp-注意事项\"><a href=\"#描述-amp-注意事项\" class=\"headerlink\" title=\" 描述&amp;注意事项 \"></a><font color=\"red\"> 描述&amp;注意事项 </font></h3><ul>\n<li>内部存储是只有当前应用可以访问到的存储方式,SP有能被外部访问的模式;</li>\n<li>应用卸载后内部存储内容都将被删除;</li>\n<li>包括<code>sharedPreferences</code>,<code>SQLite</code>;</li>\n</ul>\n<h3 id=\"路径\"><a href=\"#路径\" class=\"headerlink\" title=\" 路径 \"></a><font color=\"red\"> 路径 </font></h3><pre><code>- /data/app:                             存放着所有安装的app的apk文件\n\n- /data/data/包名/shared_prefs                 APP的SP信息\n- /data/data/包名/databases                     APP的数据库信息\n- /data/data/包名/files                        APP的文件信息\n- /data/data/包名/cache                         APP的缓存信息\n</code></pre><p>注意: 没有root的手机不能打开内部存储的文件夹;</p>\n<h3 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\" 使用方式 \"></a><font color=\"red\"> 使用方式 </font></h3><pre><code>内部存储的文件存储位置:    context.getFileDir();\n内部存储的缓存存储位置:    context.getCacheDir();\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"内部存储\"><a href=\"#内部存储\" class=\"headerlink\" title=\"内部存储\"></a>内部存储</h1><p><img src=\"https://i.imgur.com/C9ggy4K.jpg\" alt=\"存储方式\"></p>\n<h3 id=\"描述-amp-注意事项\"><a href=\"#描述-amp-注意事项\" class=\"headerlink\" title=\" 描述&amp;注意事项 \"></a><font color=\"red\"> 描述&amp;注意事项 </font></h3><ul>\n<li>内部存储是只有当前应用可以访问到的存储方式,SP有能被外部访问的模式;</li>\n<li>应用卸载后内部存储内容都将被删除;</li>\n<li>包括<code>sharedPreferences</code>,<code>SQLite</code>;</li>\n</ul>\n<h3 id=\"路径\"><a href=\"#路径\" class=\"headerlink\" title=\" 路径 \"></a><font color=\"red\"> 路径 </font></h3><pre><code>- /data/app:                             存放着所有安装的app的apk文件\n\n- /data/data/包名/shared_prefs                 APP的SP信息\n- /data/data/包名/databases                     APP的数据库信息\n- /data/data/包名/files                        APP的文件信息\n- /data/data/包名/cache                         APP的缓存信息\n</code></pre><p>注意: 没有root的手机不能打开内部存储的文件夹;</p>\n<h3 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\" 使用方式 \"></a><font color=\"red\"> 使用方式 </font></h3><pre><code>内部存储的文件存储位置:    context.getFileDir();\n内部存储的缓存存储位置:    context.getCacheDir();\n</code></pre>"},{"分类":["OptionsMenu","SubMenu","PopupMenu & PopupWindow","ContextMenu"],"_content":"\n<font color = \"red\">\n\t**注意:**\n\t<font color = \"Blue\">\n\t\t\t1. **`OptionsMenu`,`ContextMenu`均可以设置`SubMenu`;**\n\t\t\t2. **`ContextMenu`,`PopupMenu` 围绕`View`进行;**\n\t\t\t3. **`ContextMenu`需要注册和解注册;**\n\t\n\t</font>\n</font>\n\n---\n## OptionsMenu(物理菜单按钮触发的菜单)\n1. 旧版本(4.4之前)中最多呈现的item数量为6,其他item为more后;新版本中显示为一个list(即ActionBar);\n2. 创建的方法为onCreateOptionsMenu(),可以用Java代码直接添加item,也可以填充menu.xml文件来完成.\n3. item选中的动作设置需要调用onOptionsItemSelected()完成.\n4. 实现步骤:\n\t\t\t\t\t\n\t\t1. onCreateOptionsMenu()中\n\n\t\t\t\tmenu.add(Menu.NONE, 1, Menu.NONE, \"设置1\").setIcon(R.drawable.ic_launcher);\n    \t\t\tmenu.add(Menu.NONE, 2, Menu.NONE, \"设置2\");\n    \t\t\tmenu.add(Menu.NONE, 3, Menu.NONE, \"设置3\");\n    \t\t\t//参数一：groupId  组id  int 类型  表示添加的item可以分组进行管理。如果不需要分组可以不使用\n    \t\t\t//参数二： itemId  每一个item的id值。 int类型。 非常重要。 用来找到对应的item\n    \t\t\t//参数三：item的排序。 int类型。如果使用none表示按照默认排序\n    \t\t\t//参数四：item上显示的内容\n\n\t\t2. onOptionsItemSelected()中使用Switch分支结构对menu的点击情况进行判断.\n\n\n---\t\t\t    \t\n## SubMenu(其他菜单子菜单)\n1. 在其他menu的某个选项的基础上设置子菜单,不支持图标设置,且子菜单不能二级嵌套,否则直接报告异常.\n2. 以OptionsMenu为父菜单的实现步骤:\n\t1. onCreateOptionsMenu()中,在菜单选项4中,设置子菜单5,6,7,8;\n\t\t\tmenu.add(Menu.NONE, 1, Menu.NONE, \"设置1\").setIcon(R.drawable.ic_launcher);\n    \t\tmenu.add(Menu.NONE, 2, Menu.NONE, \"设置2\");\n    \t\tmenu.add(Menu.NONE, 3, Menu.NONE, \"设置3\");\n\t\t\t\t\n    \t\tSubMenu subMenu = menu.addSubMenu(Menu.NONE, 4, Menu.NONE, \"哈哈\");\n    \t\tsubMenu.setHeaderIcon(R.drawable.ic_launcher);\n    \t\tsubMenu.setHeaderTitle(\"显示标题\");//设置子菜单的标题\n    \t\tsubMenu.add(Menu.NONE, 5, Menu.NONE, \"设置5\").setIcon(R.drawable.ic_launcher);\n    \t\tsubMenu.add(Menu.NONE, 6, Menu.NONE, \"设置6\");\n    \t\tsubMenu.add(Menu.NONE, 7, Menu.NONE, \"设置8\");\n    \t\tsubMenu.add(Menu.NONE, 8, Menu.NONE, \"设置9\");\n\t2. 子菜单的点击事件也是在父菜单的on*****ItemSelected()中分支结构进行.\n\n---\n## ContextMenu(绑定控件或者布局的长按显示菜单)\n1. 该菜单是绑定在view上,长按view弹出的菜单,没有个数限制,没有图标显示.\n2. 实现步骤:\n\n\t1. 注册绑定view ->`registerForContextMenu(View)`;\n\t2. onCreateContextMenu()方法中设置menu菜单项,可以设置子菜单;\n\t3. onContextItemSelected()方法中switch分支结构判断响应事件;\n\t4. onDestroy()中解除注册绑定 ->`unregisterForContextMenu(View)`.\n\n---\n## PopupMenu和PopupWindow\n1. 二者的区别:\n\t1. popPupMenu还是一个Menu菜单的呈现，popupWindow而是一个window窗口的呈现。\n\t2. popupMenu的呈现是围绕着控件呈现在控件的边缘。popupWindow即可以呈现在控件的周围页可以呈现在指定的location。\n2. PopupWindow\n\t1. popupWindow在现实的时候正常显示，但是如果需要让当前的窗口响应了点击之后消失掉，就需要设置setBackgroundDrawable。\n\t2. 实现步骤:\n\t\t1. 在某个点击事件中:\n\t\t\t1. 创建对象\n\t\t\t\t\tPopupWindow popWindow  = new PopupWindow(this);\n\t\t\t2. 指定显示的宽高\n\t\t\t\t\n\t\t\t\t\tpopWindow.setWidth(200);\n\t    \t\t\tpopWindow.setHeight(100);\n\n\t\t\t3. 关联显示的内容xml\n\t\t\t\t\n\t\t\t\t\t    View view = View.inflate(this, R.layout.view_popupwindow, null);\n    \t\t\t\t\tpopWindow.setContentView(view);\n\n\t\t\t4. 设置window的显示位置\n\n\t\t\t\t\t    //popWindow.setBackgroundDrawable(getResources().getDrawable(R.drawable.ic_launcher));\n    \t\t\t\t\t//呈现在某个控件的下方\n    \t\t\t\t\t//popWindow.showAsDropDown(mytv2);\n    \t\t\t\t\t//popWindow.showAsDropDown(tv, 100, 100);\n    \t\t\t\t\t//呈现在具体的位置\n    \t\t\t\t\tpopWindow.showAtLocation(tv, Gravity.CENTER, 100, 200);\n\t\t\t5. 给xml的view设置点击事件\n\n\t\t\t\t\t    TextView hahaTv = (TextView) view.findViewById(R.id.haha);\n    \t\t\t\t\thahaTv.setOnClickListener(new View.OnClickListener() {\n    \t\t\t\t\t\t\n    \t\t\t\t\t\t@Override\n    \t\t\t\t\t\tpublic void onClick(View v) {\n    \t\t\t\t\t\t\tLog.i(\"TAg\", \"点击了\");\n    \t\t\t\t\t\t\t\n    \t\t\t\t\t\t\tpopWindow.dismiss();\n    \t\t\t\t\t\t}\n    \t\t\t\t\t});\n\n\t3. PopupMenu\n\t\t1. 呈现一个可移动的pop菜单，呈现在对应关联的view视图的周围。默认呈现在下方，如果下方不存在空间会above。\n\t\t2. popmenu在呈现之前需要当前的activity首先运行起来。否则拿不到当前的窗口令牌。\n\t\t3. 实现步骤:\n\t\t\t1. 点击事件中\n\t\t\t\t1. 初始化\n\t\t\t\t\t`PopupMenu popupMenu = new PopupMenu(this, tv);`\n\t\t\t\t2. 获取menu\n\n\t\t\t\t\t    Menu menu = popupMenu.getMenu();\n    \t\t\t\t\tmenu.add(Menu.NONE, 1, menu.NONE, \"哈哈\");\n    \t\t\t\t\tmenu.add(Menu.NONE, 2, menu.NONE, \"呵呵\");\n    \t\t\t\t\tmenu.add(Menu.NONE, 3, menu.NONE, \"嘿嘿\");\n\t\t\t\t3. 呈现\n\n\t\t\t\t\t`popupMenu.show();`\n\t\t\t\t4. switch设置菜单项目的点击事件\n\t\t\t\t\t\n5. 注:onCreate****Menu()中均可以通过填充menu.xml来完成设置菜单内容\n\n\t`getMenuInflater().inflate(R.menu.main, menu);`\n\t\n\n----------","source":"_posts/Android之显示——Menu.md","raw":"# Menu\n\n\t分类:\n\t\t- OptionsMenu\n\t\t- SubMenu\n\t\t- PopupMenu & PopupWindow\n\t\t- ContextMenu \n\n\n---\n\n<font color = \"red\">\n\t**注意:**\n\t<font color = \"Blue\">\n\t\t\t1. **`OptionsMenu`,`ContextMenu`均可以设置`SubMenu`;**\n\t\t\t2. **`ContextMenu`,`PopupMenu` 围绕`View`进行;**\n\t\t\t3. **`ContextMenu`需要注册和解注册;**\n\t\n\t</font>\n</font>\n\n---\n## OptionsMenu(物理菜单按钮触发的菜单)\n1. 旧版本(4.4之前)中最多呈现的item数量为6,其他item为more后;新版本中显示为一个list(即ActionBar);\n2. 创建的方法为onCreateOptionsMenu(),可以用Java代码直接添加item,也可以填充menu.xml文件来完成.\n3. item选中的动作设置需要调用onOptionsItemSelected()完成.\n4. 实现步骤:\n\t\t\t\t\t\n\t\t1. onCreateOptionsMenu()中\n\n\t\t\t\tmenu.add(Menu.NONE, 1, Menu.NONE, \"设置1\").setIcon(R.drawable.ic_launcher);\n    \t\t\tmenu.add(Menu.NONE, 2, Menu.NONE, \"设置2\");\n    \t\t\tmenu.add(Menu.NONE, 3, Menu.NONE, \"设置3\");\n    \t\t\t//参数一：groupId  组id  int 类型  表示添加的item可以分组进行管理。如果不需要分组可以不使用\n    \t\t\t//参数二： itemId  每一个item的id值。 int类型。 非常重要。 用来找到对应的item\n    \t\t\t//参数三：item的排序。 int类型。如果使用none表示按照默认排序\n    \t\t\t//参数四：item上显示的内容\n\n\t\t2. onOptionsItemSelected()中使用Switch分支结构对menu的点击情况进行判断.\n\n\n---\t\t\t    \t\n## SubMenu(其他菜单子菜单)\n1. 在其他menu的某个选项的基础上设置子菜单,不支持图标设置,且子菜单不能二级嵌套,否则直接报告异常.\n2. 以OptionsMenu为父菜单的实现步骤:\n\t1. onCreateOptionsMenu()中,在菜单选项4中,设置子菜单5,6,7,8;\n\t\t\tmenu.add(Menu.NONE, 1, Menu.NONE, \"设置1\").setIcon(R.drawable.ic_launcher);\n    \t\tmenu.add(Menu.NONE, 2, Menu.NONE, \"设置2\");\n    \t\tmenu.add(Menu.NONE, 3, Menu.NONE, \"设置3\");\n\t\t\t\t\n    \t\tSubMenu subMenu = menu.addSubMenu(Menu.NONE, 4, Menu.NONE, \"哈哈\");\n    \t\tsubMenu.setHeaderIcon(R.drawable.ic_launcher);\n    \t\tsubMenu.setHeaderTitle(\"显示标题\");//设置子菜单的标题\n    \t\tsubMenu.add(Menu.NONE, 5, Menu.NONE, \"设置5\").setIcon(R.drawable.ic_launcher);\n    \t\tsubMenu.add(Menu.NONE, 6, Menu.NONE, \"设置6\");\n    \t\tsubMenu.add(Menu.NONE, 7, Menu.NONE, \"设置8\");\n    \t\tsubMenu.add(Menu.NONE, 8, Menu.NONE, \"设置9\");\n\t2. 子菜单的点击事件也是在父菜单的on*****ItemSelected()中分支结构进行.\n\n---\n## ContextMenu(绑定控件或者布局的长按显示菜单)\n1. 该菜单是绑定在view上,长按view弹出的菜单,没有个数限制,没有图标显示.\n2. 实现步骤:\n\n\t1. 注册绑定view ->`registerForContextMenu(View)`;\n\t2. onCreateContextMenu()方法中设置menu菜单项,可以设置子菜单;\n\t3. onContextItemSelected()方法中switch分支结构判断响应事件;\n\t4. onDestroy()中解除注册绑定 ->`unregisterForContextMenu(View)`.\n\n---\n## PopupMenu和PopupWindow\n1. 二者的区别:\n\t1. popPupMenu还是一个Menu菜单的呈现，popupWindow而是一个window窗口的呈现。\n\t2. popupMenu的呈现是围绕着控件呈现在控件的边缘。popupWindow即可以呈现在控件的周围页可以呈现在指定的location。\n2. PopupWindow\n\t1. popupWindow在现实的时候正常显示，但是如果需要让当前的窗口响应了点击之后消失掉，就需要设置setBackgroundDrawable。\n\t2. 实现步骤:\n\t\t1. 在某个点击事件中:\n\t\t\t1. 创建对象\n\t\t\t\t\tPopupWindow popWindow  = new PopupWindow(this);\n\t\t\t2. 指定显示的宽高\n\t\t\t\t\n\t\t\t\t\tpopWindow.setWidth(200);\n\t    \t\t\tpopWindow.setHeight(100);\n\n\t\t\t3. 关联显示的内容xml\n\t\t\t\t\n\t\t\t\t\t    View view = View.inflate(this, R.layout.view_popupwindow, null);\n    \t\t\t\t\tpopWindow.setContentView(view);\n\n\t\t\t4. 设置window的显示位置\n\n\t\t\t\t\t    //popWindow.setBackgroundDrawable(getResources().getDrawable(R.drawable.ic_launcher));\n    \t\t\t\t\t//呈现在某个控件的下方\n    \t\t\t\t\t//popWindow.showAsDropDown(mytv2);\n    \t\t\t\t\t//popWindow.showAsDropDown(tv, 100, 100);\n    \t\t\t\t\t//呈现在具体的位置\n    \t\t\t\t\tpopWindow.showAtLocation(tv, Gravity.CENTER, 100, 200);\n\t\t\t5. 给xml的view设置点击事件\n\n\t\t\t\t\t    TextView hahaTv = (TextView) view.findViewById(R.id.haha);\n    \t\t\t\t\thahaTv.setOnClickListener(new View.OnClickListener() {\n    \t\t\t\t\t\t\n    \t\t\t\t\t\t@Override\n    \t\t\t\t\t\tpublic void onClick(View v) {\n    \t\t\t\t\t\t\tLog.i(\"TAg\", \"点击了\");\n    \t\t\t\t\t\t\t\n    \t\t\t\t\t\t\tpopWindow.dismiss();\n    \t\t\t\t\t\t}\n    \t\t\t\t\t});\n\n\t3. PopupMenu\n\t\t1. 呈现一个可移动的pop菜单，呈现在对应关联的view视图的周围。默认呈现在下方，如果下方不存在空间会above。\n\t\t2. popmenu在呈现之前需要当前的activity首先运行起来。否则拿不到当前的窗口令牌。\n\t\t3. 实现步骤:\n\t\t\t1. 点击事件中\n\t\t\t\t1. 初始化\n\t\t\t\t\t`PopupMenu popupMenu = new PopupMenu(this, tv);`\n\t\t\t\t2. 获取menu\n\n\t\t\t\t\t    Menu menu = popupMenu.getMenu();\n    \t\t\t\t\tmenu.add(Menu.NONE, 1, menu.NONE, \"哈哈\");\n    \t\t\t\t\tmenu.add(Menu.NONE, 2, menu.NONE, \"呵呵\");\n    \t\t\t\t\tmenu.add(Menu.NONE, 3, menu.NONE, \"嘿嘿\");\n\t\t\t\t3. 呈现\n\n\t\t\t\t\t`popupMenu.show();`\n\t\t\t\t4. switch设置菜单项目的点击事件\n\t\t\t\t\t\n5. 注:onCreate****Menu()中均可以通过填充menu.xml来完成设置菜单内容\n\n\t`getMenuInflater().inflate(R.menu.main, menu);`\n\t\n\n----------","slug":"Android之显示——Menu","published":1,"date":"2018-03-21T03:22:18.419Z","updated":"2017-10-13T03:52:56.873Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0kjqj6000b0s4lybdhixss","content":"<font color=\"red\"><br>    <strong>注意:</strong><br>    <font color=\"Blue\"><br>            1. <strong><code>OptionsMenu</code>,<code>ContextMenu</code>均可以设置<code>SubMenu</code>;</strong><br>            2. <strong><code>ContextMenu</code>,<code>PopupMenu</code> 围绕<code>View</code>进行;</strong><br>            3. <strong><code>ContextMenu</code>需要注册和解注册;</strong><br><br>    </font><br></font>\n\n<hr>\n<h2 id=\"OptionsMenu-物理菜单按钮触发的菜单\"><a href=\"#OptionsMenu-物理菜单按钮触发的菜单\" class=\"headerlink\" title=\"OptionsMenu(物理菜单按钮触发的菜单)\"></a>OptionsMenu(物理菜单按钮触发的菜单)</h2><ol>\n<li>旧版本(4.4之前)中最多呈现的item数量为6,其他item为more后;新版本中显示为一个list(即ActionBar);</li>\n<li>创建的方法为onCreateOptionsMenu(),可以用Java代码直接添加item,也可以填充menu.xml文件来完成.</li>\n<li>item选中的动作设置需要调用onOptionsItemSelected()完成.</li>\n<li><p>实现步骤:</p>\n<pre><code>1. onCreateOptionsMenu()中\n\n        menu.add(Menu.NONE, 1, Menu.NONE, &quot;设置1&quot;).setIcon(R.drawable.ic_launcher);\n        menu.add(Menu.NONE, 2, Menu.NONE, &quot;设置2&quot;);\n        menu.add(Menu.NONE, 3, Menu.NONE, &quot;设置3&quot;);\n        //参数一：groupId  组id  int 类型  表示添加的item可以分组进行管理。如果不需要分组可以不使用\n        //参数二： itemId  每一个item的id值。 int类型。 非常重要。 用来找到对应的item\n        //参数三：item的排序。 int类型。如果使用none表示按照默认排序\n        //参数四：item上显示的内容\n\n2. onOptionsItemSelected()中使用Switch分支结构对menu的点击情况进行判断.\n</code></pre></li>\n</ol>\n<hr>\n<h2 id=\"SubMenu-其他菜单子菜单\"><a href=\"#SubMenu-其他菜单子菜单\" class=\"headerlink\" title=\"SubMenu(其他菜单子菜单)\"></a>SubMenu(其他菜单子菜单)</h2><ol>\n<li>在其他menu的某个选项的基础上设置子菜单,不支持图标设置,且子菜单不能二级嵌套,否则直接报告异常.</li>\n<li><p>以OptionsMenu为父菜单的实现步骤:</p>\n<ol>\n<li><p>onCreateOptionsMenu()中,在菜单选项4中,设置子菜单5,6,7,8;</p>\n<pre><code>menu.add(Menu.NONE, 1, Menu.NONE, &quot;设置1&quot;).setIcon(R.drawable.ic_launcher);\nmenu.add(Menu.NONE, 2, Menu.NONE, &quot;设置2&quot;);\nmenu.add(Menu.NONE, 3, Menu.NONE, &quot;设置3&quot;);\n\nSubMenu subMenu = menu.addSubMenu(Menu.NONE, 4, Menu.NONE, &quot;哈哈&quot;);\nsubMenu.setHeaderIcon(R.drawable.ic_launcher);\nsubMenu.setHeaderTitle(&quot;显示标题&quot;);//设置子菜单的标题\nsubMenu.add(Menu.NONE, 5, Menu.NONE, &quot;设置5&quot;).setIcon(R.drawable.ic_launcher);\nsubMenu.add(Menu.NONE, 6, Menu.NONE, &quot;设置6&quot;);\nsubMenu.add(Menu.NONE, 7, Menu.NONE, &quot;设置8&quot;);\nsubMenu.add(Menu.NONE, 8, Menu.NONE, &quot;设置9&quot;);\n</code></pre></li>\n<li>子菜单的点击事件也是在父菜单的on<strong>*</strong>ItemSelected()中分支结构进行.</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"ContextMenu-绑定控件或者布局的长按显示菜单\"><a href=\"#ContextMenu-绑定控件或者布局的长按显示菜单\" class=\"headerlink\" title=\"ContextMenu(绑定控件或者布局的长按显示菜单)\"></a>ContextMenu(绑定控件或者布局的长按显示菜单)</h2><ol>\n<li>该菜单是绑定在view上,长按view弹出的菜单,没有个数限制,没有图标显示.</li>\n<li><p>实现步骤:</p>\n<ol>\n<li>注册绑定view -&gt;<code>registerForContextMenu(View)</code>;</li>\n<li>onCreateContextMenu()方法中设置menu菜单项,可以设置子菜单;</li>\n<li>onContextItemSelected()方法中switch分支结构判断响应事件;</li>\n<li>onDestroy()中解除注册绑定 -&gt;<code>unregisterForContextMenu(View)</code>.</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"PopupMenu和PopupWindow\"><a href=\"#PopupMenu和PopupWindow\" class=\"headerlink\" title=\"PopupMenu和PopupWindow\"></a>PopupMenu和PopupWindow</h2><ol>\n<li>二者的区别:<ol>\n<li>popPupMenu还是一个Menu菜单的呈现，popupWindow而是一个window窗口的呈现。</li>\n<li>popupMenu的呈现是围绕着控件呈现在控件的边缘。popupWindow即可以呈现在控件的周围页可以呈现在指定的location。</li>\n</ol>\n</li>\n<li><p>PopupWindow</p>\n<ol>\n<li>popupWindow在现实的时候正常显示，但是如果需要让当前的窗口响应了点击之后消失掉，就需要设置setBackgroundDrawable。</li>\n<li><p>实现步骤:</p>\n<ol>\n<li><p>在某个点击事件中:</p>\n<ol>\n<li>创建对象<pre><code>PopupWindow popWindow  = new PopupWindow(this);\n</code></pre></li>\n<li><p>指定显示的宽高</p>\n<pre><code>popWindow.setWidth(200);\npopWindow.setHeight(100);\n</code></pre></li>\n<li><p>关联显示的内容xml</p>\n<pre><code>View view = View.inflate(this, R.layout.view_popupwindow, null);\npopWindow.setContentView(view);\n</code></pre></li>\n<li><p>设置window的显示位置</p>\n<pre><code>//popWindow.setBackgroundDrawable(getResources().getDrawable(R.drawable.ic_launcher));\n//呈现在某个控件的下方\n//popWindow.showAsDropDown(mytv2);\n//popWindow.showAsDropDown(tv, 100, 100);\n//呈现在具体的位置\npopWindow.showAtLocation(tv, Gravity.CENTER, 100, 200);\n</code></pre></li>\n<li><p>给xml的view设置点击事件</p>\n<pre><code>TextView hahaTv = (TextView) view.findViewById(R.id.haha);\nhahaTv.setOnClickListener(new View.OnClickListener() {\n\n    @Override\n    public void onClick(View v) {\n        Log.i(&quot;TAg&quot;, &quot;点击了&quot;);\n\n        popWindow.dismiss();\n    }\n});\n</code></pre></li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>PopupMenu</p>\n<ol>\n<li>呈现一个可移动的pop菜单，呈现在对应关联的view视图的周围。默认呈现在下方，如果下方不存在空间会above。</li>\n<li>popmenu在呈现之前需要当前的activity首先运行起来。否则拿不到当前的窗口令牌。</li>\n<li><p>实现步骤:</p>\n<ol>\n<li><p>点击事件中</p>\n<ol>\n<li>初始化<br> <code>PopupMenu popupMenu = new PopupMenu(this, tv);</code></li>\n<li><p>获取menu</p>\n<pre><code>Menu menu = popupMenu.getMenu();\nmenu.add(Menu.NONE, 1, menu.NONE, &quot;哈哈&quot;);\nmenu.add(Menu.NONE, 2, menu.NONE, &quot;呵呵&quot;);\nmenu.add(Menu.NONE, 3, menu.NONE, &quot;嘿嘿&quot;);\n</code></pre></li>\n<li><p>呈现</p>\n<p> <code>popupMenu.show();</code></p>\n</li>\n<li>switch设置菜单项目的点击事件</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>注:onCreate<em>**</em>Menu()中均可以通过填充menu.xml来完成设置菜单内容</p>\n<p> <code>getMenuInflater().inflate(R.menu.main, menu);</code></p>\n</li>\n</ol>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<font color=\"red\"><br>    <strong>注意:</strong><br>    <font color=\"Blue\"><br>            1. <strong><code>OptionsMenu</code>,<code>ContextMenu</code>均可以设置<code>SubMenu</code>;</strong><br>            2. <strong><code>ContextMenu</code>,<code>PopupMenu</code> 围绕<code>View</code>进行;</strong><br>            3. <strong><code>ContextMenu</code>需要注册和解注册;</strong><br><br>    </font><br></font>\n\n<hr>\n<h2 id=\"OptionsMenu-物理菜单按钮触发的菜单\"><a href=\"#OptionsMenu-物理菜单按钮触发的菜单\" class=\"headerlink\" title=\"OptionsMenu(物理菜单按钮触发的菜单)\"></a>OptionsMenu(物理菜单按钮触发的菜单)</h2><ol>\n<li>旧版本(4.4之前)中最多呈现的item数量为6,其他item为more后;新版本中显示为一个list(即ActionBar);</li>\n<li>创建的方法为onCreateOptionsMenu(),可以用Java代码直接添加item,也可以填充menu.xml文件来完成.</li>\n<li>item选中的动作设置需要调用onOptionsItemSelected()完成.</li>\n<li><p>实现步骤:</p>\n<pre><code>1. onCreateOptionsMenu()中\n\n        menu.add(Menu.NONE, 1, Menu.NONE, &quot;设置1&quot;).setIcon(R.drawable.ic_launcher);\n        menu.add(Menu.NONE, 2, Menu.NONE, &quot;设置2&quot;);\n        menu.add(Menu.NONE, 3, Menu.NONE, &quot;设置3&quot;);\n        //参数一：groupId  组id  int 类型  表示添加的item可以分组进行管理。如果不需要分组可以不使用\n        //参数二： itemId  每一个item的id值。 int类型。 非常重要。 用来找到对应的item\n        //参数三：item的排序。 int类型。如果使用none表示按照默认排序\n        //参数四：item上显示的内容\n\n2. onOptionsItemSelected()中使用Switch分支结构对menu的点击情况进行判断.\n</code></pre></li>\n</ol>\n<hr>\n<h2 id=\"SubMenu-其他菜单子菜单\"><a href=\"#SubMenu-其他菜单子菜单\" class=\"headerlink\" title=\"SubMenu(其他菜单子菜单)\"></a>SubMenu(其他菜单子菜单)</h2><ol>\n<li>在其他menu的某个选项的基础上设置子菜单,不支持图标设置,且子菜单不能二级嵌套,否则直接报告异常.</li>\n<li><p>以OptionsMenu为父菜单的实现步骤:</p>\n<ol>\n<li><p>onCreateOptionsMenu()中,在菜单选项4中,设置子菜单5,6,7,8;</p>\n<pre><code>menu.add(Menu.NONE, 1, Menu.NONE, &quot;设置1&quot;).setIcon(R.drawable.ic_launcher);\nmenu.add(Menu.NONE, 2, Menu.NONE, &quot;设置2&quot;);\nmenu.add(Menu.NONE, 3, Menu.NONE, &quot;设置3&quot;);\n\nSubMenu subMenu = menu.addSubMenu(Menu.NONE, 4, Menu.NONE, &quot;哈哈&quot;);\nsubMenu.setHeaderIcon(R.drawable.ic_launcher);\nsubMenu.setHeaderTitle(&quot;显示标题&quot;);//设置子菜单的标题\nsubMenu.add(Menu.NONE, 5, Menu.NONE, &quot;设置5&quot;).setIcon(R.drawable.ic_launcher);\nsubMenu.add(Menu.NONE, 6, Menu.NONE, &quot;设置6&quot;);\nsubMenu.add(Menu.NONE, 7, Menu.NONE, &quot;设置8&quot;);\nsubMenu.add(Menu.NONE, 8, Menu.NONE, &quot;设置9&quot;);\n</code></pre></li>\n<li>子菜单的点击事件也是在父菜单的on<strong>*</strong>ItemSelected()中分支结构进行.</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"ContextMenu-绑定控件或者布局的长按显示菜单\"><a href=\"#ContextMenu-绑定控件或者布局的长按显示菜单\" class=\"headerlink\" title=\"ContextMenu(绑定控件或者布局的长按显示菜单)\"></a>ContextMenu(绑定控件或者布局的长按显示菜单)</h2><ol>\n<li>该菜单是绑定在view上,长按view弹出的菜单,没有个数限制,没有图标显示.</li>\n<li><p>实现步骤:</p>\n<ol>\n<li>注册绑定view -&gt;<code>registerForContextMenu(View)</code>;</li>\n<li>onCreateContextMenu()方法中设置menu菜单项,可以设置子菜单;</li>\n<li>onContextItemSelected()方法中switch分支结构判断响应事件;</li>\n<li>onDestroy()中解除注册绑定 -&gt;<code>unregisterForContextMenu(View)</code>.</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"PopupMenu和PopupWindow\"><a href=\"#PopupMenu和PopupWindow\" class=\"headerlink\" title=\"PopupMenu和PopupWindow\"></a>PopupMenu和PopupWindow</h2><ol>\n<li>二者的区别:<ol>\n<li>popPupMenu还是一个Menu菜单的呈现，popupWindow而是一个window窗口的呈现。</li>\n<li>popupMenu的呈现是围绕着控件呈现在控件的边缘。popupWindow即可以呈现在控件的周围页可以呈现在指定的location。</li>\n</ol>\n</li>\n<li><p>PopupWindow</p>\n<ol>\n<li>popupWindow在现实的时候正常显示，但是如果需要让当前的窗口响应了点击之后消失掉，就需要设置setBackgroundDrawable。</li>\n<li><p>实现步骤:</p>\n<ol>\n<li><p>在某个点击事件中:</p>\n<ol>\n<li>创建对象<pre><code>PopupWindow popWindow  = new PopupWindow(this);\n</code></pre></li>\n<li><p>指定显示的宽高</p>\n<pre><code>popWindow.setWidth(200);\npopWindow.setHeight(100);\n</code></pre></li>\n<li><p>关联显示的内容xml</p>\n<pre><code>View view = View.inflate(this, R.layout.view_popupwindow, null);\npopWindow.setContentView(view);\n</code></pre></li>\n<li><p>设置window的显示位置</p>\n<pre><code>//popWindow.setBackgroundDrawable(getResources().getDrawable(R.drawable.ic_launcher));\n//呈现在某个控件的下方\n//popWindow.showAsDropDown(mytv2);\n//popWindow.showAsDropDown(tv, 100, 100);\n//呈现在具体的位置\npopWindow.showAtLocation(tv, Gravity.CENTER, 100, 200);\n</code></pre></li>\n<li><p>给xml的view设置点击事件</p>\n<pre><code>TextView hahaTv = (TextView) view.findViewById(R.id.haha);\nhahaTv.setOnClickListener(new View.OnClickListener() {\n\n    @Override\n    public void onClick(View v) {\n        Log.i(&quot;TAg&quot;, &quot;点击了&quot;);\n\n        popWindow.dismiss();\n    }\n});\n</code></pre></li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>PopupMenu</p>\n<ol>\n<li>呈现一个可移动的pop菜单，呈现在对应关联的view视图的周围。默认呈现在下方，如果下方不存在空间会above。</li>\n<li>popmenu在呈现之前需要当前的activity首先运行起来。否则拿不到当前的窗口令牌。</li>\n<li><p>实现步骤:</p>\n<ol>\n<li><p>点击事件中</p>\n<ol>\n<li>初始化<br> <code>PopupMenu popupMenu = new PopupMenu(this, tv);</code></li>\n<li><p>获取menu</p>\n<pre><code>Menu menu = popupMenu.getMenu();\nmenu.add(Menu.NONE, 1, menu.NONE, &quot;哈哈&quot;);\nmenu.add(Menu.NONE, 2, menu.NONE, &quot;呵呵&quot;);\nmenu.add(Menu.NONE, 3, menu.NONE, &quot;嘿嘿&quot;);\n</code></pre></li>\n<li><p>呈现</p>\n<p> <code>popupMenu.show();</code></p>\n</li>\n<li>switch设置菜单项目的点击事件</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>注:onCreate<em>**</em>Menu()中均可以通过填充menu.xml来完成设置菜单内容</p>\n<p> <code>getMenuInflater().inflate(R.menu.main, menu);</code></p>\n</li>\n</ol>\n<hr>\n"},{"_content":"# PopupWindow #\n\n---\n\n\t细节:\n\t\t1. popupWindow内容中的EditText因window层级高而不能弹出粘贴复制菜单;\n\n\n\n---\n","source":"_posts/Android之显示——PopupWindow.md","raw":"# PopupWindow #\n\n---\n\n\t细节:\n\t\t1. popupWindow内容中的EditText因window层级高而不能弹出粘贴复制菜单;\n\n\n\n---\n","slug":"Android之显示——PopupWindow","published":1,"date":"2018-03-21T03:22:18.423Z","updated":"2017-09-27T08:19:25.085Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0kjqj7000c0s4lqelbdzgv","content":"<h1 id=\"PopupWindow\"><a href=\"#PopupWindow\" class=\"headerlink\" title=\"PopupWindow\"></a>PopupWindow</h1><hr>\n<pre><code>细节:\n    1. popupWindow内容中的EditText因window层级高而不能弹出粘贴复制菜单;\n</code></pre><hr>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"PopupWindow\"><a href=\"#PopupWindow\" class=\"headerlink\" title=\"PopupWindow\"></a>PopupWindow</h1><hr>\n<pre><code>细节:\n    1. popupWindow内容中的EditText因window层级高而不能弹出粘贴复制菜单;\n</code></pre><hr>\n"},{"_content":"# Surface & SurfaceView #\n\n\n---\n## Surface ##\n- surface对应一个图层,原始图像缓冲区(由屏幕图像合成器管理)的句柄,\n- surface可以理解为用于显示的一段内存;\n- surface持有一定量的像素点,每一个Window都对应一个surface来将自己的内容进行绘制;\n- surface的双缓冲区的作用: 在绘制16ms后显示的内容的同时,可以将当前时刻的所有像素根据z轴上的位置渲染到屏幕上.\n\n简要理解:\n\t\n```java\n1. updateWindow()中IWindowSession(≈ViewRootImpl)创建surface\n2. 跨进程调用WindowManagerService重绘surface并更新(mSurface.transferFrom(mNewSurface))\n3. 返回surface给SurfaceView\n```\n\n\n---\n\n\n\n\n## SurfaceView ##\n- View适用于对于用户的操作做出一定的响应,较为被动;\n- SurfaceView较为主动,不会阻塞UI,需要不同的线程和surface来动态更新;\n\n\n### 和View的区别\n1. View通过刷新来重绘视图，Android系统通过发出VSYNC信号来进行屏幕的重绘，刷新的时间间隔为16ms,超出就会卡顿;\n2. SurfaceView继承于View,拥有独立的绘制表面,不与宿主窗口共享一个绘制表面,单独在一个线程中绘制,不占用主线程的资源,主要用到的位置是游戏和视频播放,直播;\n\t* 每一个SurfaceView在SurfaceFlinger服务中还对应有一个独立的Layer或者LayerBuffer，用来单独描述它的绘图表面，以区别于它的宿主窗口的绘图表面。\n3. SurfaceView有两个子类GLSurfaceView和VideoView;\n4. [其他区别](http://www.jianshu.com/p/15060fc9ef18):\n\t- View--主动更新，SurfaceView--被动更新，例如频繁地刷新;\n\t- View--主线程，而SurfaceView--子线程刷新页面;\n\t- SufaceView实现双缓冲机制;\n\n\n\n\n### View的缺陷\n\n- View没有双缓冲机制\n- View更新图像必须重新绘制\n- View的更新必须在定义线程中进行,由于使用的是UI中公用的surface\n\n\n\n\n## SurfaceView基本使用 ##\n1. 创建\n\t\t\n\t\t* extends SurfaceView implements SurfaceHolder.Callback\n\t\t* 实现函数有:\n\t\t\t* 创建--surfaceCreated(SurfaceHolder holder)\n\t\t\t* 更新--surfaceChanged(SurfaceHolder holder, int format, int width, int height)\n\t\t\t* 销毁--surfaceDestroyed(SurfaceHolder holder) \n\t\t* SurfaceHolder.CallBack还有一个子Callback2接口，\n\t\t  里面添加了一个surfaceRedrawNeeded (SurfaceHolder holder)方法,\n\t\t  当需要重绘SurfaceView中的内容使用.\n\t\t\n2. 初始化\n\t\t\n\t- 初始化可以控制大小,格式,监控或改变SurfaceView的surfaceHolder;\n\t- 设置是否可以获取焦点和触摸获取焦点信息,是否保持屏幕长亮;(一般上对EditText设置,设置了focusableInTouchMode(true)的editText才能在弹出键盘的时候得到输入的内容)\n\t```java\n\t\tmSurfaceHolder = getHolder();//得到SurfaceHolder对象\n\t\tmSurfaceHolder.addCallback(this);//注册SurfaceHolder\n\t\tsetFocusable(true);\n\t\tsetFocusableInTouchMode(true);\n\t\tthis.setKeepScreenOn(true);//保持屏幕长亮\t\t\n\t```\n\n3. 使用\n```java\t\n\t* 在开启的线程中使用SurfaceHolder#lockCanvas()获取canvas进行绘制;\n\t* 创建之后循环绘制,使用unlockCanvasAndPost(mCanvas)进行画布的提交;\n\t* canvas的擦除内容,需要使用drawColor();\n```\t\n\n\n### SurfaceHolder\n\n- 与SurfaceView结合使用\n- 调用SurfaceView的getHolder()获得关联的SurfaceHolder\n- SurfaceHolder设置监听Callback\n\t- surfaceChanged(SurfaceHolder holder, int format\n\t\t, int width, int height)\n\t\t- 格式大小发生改变时被调用\n\t- surfaceCreated(SurfaceHolder holder)\n\t\t- 创建时被调用\n\t- surfaceDestroyed(SurfaceHolder holder)\n\t\t- 销毁前被调用\n- getSurface()\n\t- 对surface持有管理 \n- 更新参数得到新的surface的函数\n\t- setFixedSize()\n\t- setSizeFromLayout()\n\t- setFormat()\n\n### SurfaceView的绘制过程\n\n- 绘制之前需要**锁定绘制区域**选取来得到Canvas:\n\t\t\n\t\tcanvas = holder.lockCanvas(new Rect(lt_x,lt_y,rb_x,rb_y));\n\t\t\n\t\t* 注:lockCanvas()无参时绘制所有区域,有参绘制效率更高;\n\n- 绘制结束释放Canvas提交修改内容\n\n\t\tholder.unlockCanvasAndPost(canvas);\n\n\n### 其他理解\n\n\t1. SurfaceView所做的全部就是要求WindowManager创建一个window，并告诉Window Manager所创建的window的Z轴顺序（Z-order）\n\t2. 这个Z轴顺序可以帮助Window Manager决定将新建的window置于SurfaceView所属window的前面还是后面。\n\t3. WindowManager会将新建的window放置到SurfaceView在所属window中的位置。如果新建window在SurfaceView所属window后面，SurfaceView会将它在所属window中占据的部分变透明，以便让后面的window显示出来。\n\n\nSurfaceView和DecorView根节点视图一样,能对WMS可见.虽然在Server端（WMS和SF）中，但是与宿主窗口是分离的.在WMS中有对应的WindowState,对应SurfaceFlinger的Layer(图层).\n\n\t- 优点:Surface可以放到单独的线程做,渲染自己对应的GL Context.\n\t- 缺点:不在View树型结构中,不受View的属性控制,不能进行各种变换,一些属性也无法使用.\n\n\n---\n\n","source":"_posts/Android之显示——Surface,SurfaceView.md","raw":"# Surface & SurfaceView #\n\n\n---\n## Surface ##\n- surface对应一个图层,原始图像缓冲区(由屏幕图像合成器管理)的句柄,\n- surface可以理解为用于显示的一段内存;\n- surface持有一定量的像素点,每一个Window都对应一个surface来将自己的内容进行绘制;\n- surface的双缓冲区的作用: 在绘制16ms后显示的内容的同时,可以将当前时刻的所有像素根据z轴上的位置渲染到屏幕上.\n\n简要理解:\n\t\n```java\n1. updateWindow()中IWindowSession(≈ViewRootImpl)创建surface\n2. 跨进程调用WindowManagerService重绘surface并更新(mSurface.transferFrom(mNewSurface))\n3. 返回surface给SurfaceView\n```\n\n\n---\n\n\n\n\n## SurfaceView ##\n- View适用于对于用户的操作做出一定的响应,较为被动;\n- SurfaceView较为主动,不会阻塞UI,需要不同的线程和surface来动态更新;\n\n\n### 和View的区别\n1. View通过刷新来重绘视图，Android系统通过发出VSYNC信号来进行屏幕的重绘，刷新的时间间隔为16ms,超出就会卡顿;\n2. SurfaceView继承于View,拥有独立的绘制表面,不与宿主窗口共享一个绘制表面,单独在一个线程中绘制,不占用主线程的资源,主要用到的位置是游戏和视频播放,直播;\n\t* 每一个SurfaceView在SurfaceFlinger服务中还对应有一个独立的Layer或者LayerBuffer，用来单独描述它的绘图表面，以区别于它的宿主窗口的绘图表面。\n3. SurfaceView有两个子类GLSurfaceView和VideoView;\n4. [其他区别](http://www.jianshu.com/p/15060fc9ef18):\n\t- View--主动更新，SurfaceView--被动更新，例如频繁地刷新;\n\t- View--主线程，而SurfaceView--子线程刷新页面;\n\t- SufaceView实现双缓冲机制;\n\n\n\n\n### View的缺陷\n\n- View没有双缓冲机制\n- View更新图像必须重新绘制\n- View的更新必须在定义线程中进行,由于使用的是UI中公用的surface\n\n\n\n\n## SurfaceView基本使用 ##\n1. 创建\n\t\t\n\t\t* extends SurfaceView implements SurfaceHolder.Callback\n\t\t* 实现函数有:\n\t\t\t* 创建--surfaceCreated(SurfaceHolder holder)\n\t\t\t* 更新--surfaceChanged(SurfaceHolder holder, int format, int width, int height)\n\t\t\t* 销毁--surfaceDestroyed(SurfaceHolder holder) \n\t\t* SurfaceHolder.CallBack还有一个子Callback2接口，\n\t\t  里面添加了一个surfaceRedrawNeeded (SurfaceHolder holder)方法,\n\t\t  当需要重绘SurfaceView中的内容使用.\n\t\t\n2. 初始化\n\t\t\n\t- 初始化可以控制大小,格式,监控或改变SurfaceView的surfaceHolder;\n\t- 设置是否可以获取焦点和触摸获取焦点信息,是否保持屏幕长亮;(一般上对EditText设置,设置了focusableInTouchMode(true)的editText才能在弹出键盘的时候得到输入的内容)\n\t```java\n\t\tmSurfaceHolder = getHolder();//得到SurfaceHolder对象\n\t\tmSurfaceHolder.addCallback(this);//注册SurfaceHolder\n\t\tsetFocusable(true);\n\t\tsetFocusableInTouchMode(true);\n\t\tthis.setKeepScreenOn(true);//保持屏幕长亮\t\t\n\t```\n\n3. 使用\n```java\t\n\t* 在开启的线程中使用SurfaceHolder#lockCanvas()获取canvas进行绘制;\n\t* 创建之后循环绘制,使用unlockCanvasAndPost(mCanvas)进行画布的提交;\n\t* canvas的擦除内容,需要使用drawColor();\n```\t\n\n\n### SurfaceHolder\n\n- 与SurfaceView结合使用\n- 调用SurfaceView的getHolder()获得关联的SurfaceHolder\n- SurfaceHolder设置监听Callback\n\t- surfaceChanged(SurfaceHolder holder, int format\n\t\t, int width, int height)\n\t\t- 格式大小发生改变时被调用\n\t- surfaceCreated(SurfaceHolder holder)\n\t\t- 创建时被调用\n\t- surfaceDestroyed(SurfaceHolder holder)\n\t\t- 销毁前被调用\n- getSurface()\n\t- 对surface持有管理 \n- 更新参数得到新的surface的函数\n\t- setFixedSize()\n\t- setSizeFromLayout()\n\t- setFormat()\n\n### SurfaceView的绘制过程\n\n- 绘制之前需要**锁定绘制区域**选取来得到Canvas:\n\t\t\n\t\tcanvas = holder.lockCanvas(new Rect(lt_x,lt_y,rb_x,rb_y));\n\t\t\n\t\t* 注:lockCanvas()无参时绘制所有区域,有参绘制效率更高;\n\n- 绘制结束释放Canvas提交修改内容\n\n\t\tholder.unlockCanvasAndPost(canvas);\n\n\n### 其他理解\n\n\t1. SurfaceView所做的全部就是要求WindowManager创建一个window，并告诉Window Manager所创建的window的Z轴顺序（Z-order）\n\t2. 这个Z轴顺序可以帮助Window Manager决定将新建的window置于SurfaceView所属window的前面还是后面。\n\t3. WindowManager会将新建的window放置到SurfaceView在所属window中的位置。如果新建window在SurfaceView所属window后面，SurfaceView会将它在所属window中占据的部分变透明，以便让后面的window显示出来。\n\n\nSurfaceView和DecorView根节点视图一样,能对WMS可见.虽然在Server端（WMS和SF）中，但是与宿主窗口是分离的.在WMS中有对应的WindowState,对应SurfaceFlinger的Layer(图层).\n\n\t- 优点:Surface可以放到单独的线程做,渲染自己对应的GL Context.\n\t- 缺点:不在View树型结构中,不受View的属性控制,不能进行各种变换,一些属性也无法使用.\n\n\n---\n\n","slug":"Android之显示——Surface,SurfaceView","published":1,"date":"2018-03-21T03:22:18.424Z","updated":"2018-01-26T06:56:43.968Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0kjqj8000d0s4lbyt3xjq7","content":"<h1 id=\"Surface-amp-SurfaceView\"><a href=\"#Surface-amp-SurfaceView\" class=\"headerlink\" title=\"Surface &amp; SurfaceView\"></a>Surface &amp; SurfaceView</h1><hr>\n<h2 id=\"Surface\"><a href=\"#Surface\" class=\"headerlink\" title=\"Surface\"></a>Surface</h2><ul>\n<li>surface对应一个图层,原始图像缓冲区(由屏幕图像合成器管理)的句柄,</li>\n<li>surface可以理解为用于显示的一段内存;</li>\n<li>surface持有一定量的像素点,每一个Window都对应一个surface来将自己的内容进行绘制;</li>\n<li>surface的双缓冲区的作用: 在绘制16ms后显示的内容的同时,可以将当前时刻的所有像素根据z轴上的位置渲染到屏幕上.</li>\n</ul>\n<p>简要理解:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>. updateWindow()中IWindowSession(≈ViewRootImpl)创建surface</span><br><span class=\"line\"><span class=\"number\">2</span>. 跨进程调用WindowManagerService重绘surface并更新(mSurface.transferFrom(mNewSurface))</span><br><span class=\"line\"><span class=\"number\">3</span>. 返回surface给SurfaceView</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"SurfaceView\"><a href=\"#SurfaceView\" class=\"headerlink\" title=\"SurfaceView\"></a>SurfaceView</h2><ul>\n<li>View适用于对于用户的操作做出一定的响应,较为被动;</li>\n<li>SurfaceView较为主动,不会阻塞UI,需要不同的线程和surface来动态更新;</li>\n</ul>\n<h3 id=\"和View的区别\"><a href=\"#和View的区别\" class=\"headerlink\" title=\"和View的区别\"></a>和View的区别</h3><ol>\n<li>View通过刷新来重绘视图，Android系统通过发出VSYNC信号来进行屏幕的重绘，刷新的时间间隔为16ms,超出就会卡顿;</li>\n<li>SurfaceView继承于View,拥有独立的绘制表面,不与宿主窗口共享一个绘制表面,单独在一个线程中绘制,不占用主线程的资源,主要用到的位置是游戏和视频播放,直播;<ul>\n<li>每一个SurfaceView在SurfaceFlinger服务中还对应有一个独立的Layer或者LayerBuffer，用来单独描述它的绘图表面，以区别于它的宿主窗口的绘图表面。</li>\n</ul>\n</li>\n<li>SurfaceView有两个子类GLSurfaceView和VideoView;</li>\n<li><a href=\"http://www.jianshu.com/p/15060fc9ef18\" target=\"_blank\" rel=\"noopener\">其他区别</a>:<ul>\n<li>View–主动更新，SurfaceView–被动更新，例如频繁地刷新;</li>\n<li>View–主线程，而SurfaceView–子线程刷新页面;</li>\n<li>SufaceView实现双缓冲机制;</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"View的缺陷\"><a href=\"#View的缺陷\" class=\"headerlink\" title=\"View的缺陷\"></a>View的缺陷</h3><ul>\n<li>View没有双缓冲机制</li>\n<li>View更新图像必须重新绘制</li>\n<li>View的更新必须在定义线程中进行,由于使用的是UI中公用的surface</li>\n</ul>\n<h2 id=\"SurfaceView基本使用\"><a href=\"#SurfaceView基本使用\" class=\"headerlink\" title=\"SurfaceView基本使用\"></a>SurfaceView基本使用</h2><ol>\n<li><p>创建</p>\n<pre><code>* extends SurfaceView implements SurfaceHolder.Callback\n* 实现函数有:\n    * 创建--surfaceCreated(SurfaceHolder holder)\n    * 更新--surfaceChanged(SurfaceHolder holder, int format, int width, int height)\n    * 销毁--surfaceDestroyed(SurfaceHolder holder) \n* SurfaceHolder.CallBack还有一个子Callback2接口，\n  里面添加了一个surfaceRedrawNeeded (SurfaceHolder holder)方法,\n  当需要重绘SurfaceView中的内容使用.\n</code></pre></li>\n<li><p>初始化</p>\n<ul>\n<li>初始化可以控制大小,格式,监控或改变SurfaceView的surfaceHolder;</li>\n<li>设置是否可以获取焦点和触摸获取焦点信息,是否保持屏幕长亮;(一般上对EditText设置,设置了focusableInTouchMode(true)的editText才能在弹出键盘的时候得到输入的内容)<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mSurfaceHolder = getHolder();<span class=\"comment\">//得到SurfaceHolder对象</span></span><br><span class=\"line\">mSurfaceHolder.addCallback(<span class=\"keyword\">this</span>);<span class=\"comment\">//注册SurfaceHolder</span></span><br><span class=\"line\">setFocusable(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">setFocusableInTouchMode(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"><span class=\"keyword\">this</span>.setKeepScreenOn(<span class=\"keyword\">true</span>);<span class=\"comment\">//保持屏幕长亮</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>使用</p>\n<pre><code class=\"java\">* 在开启的线程中使用SurfaceHolder#lockCanvas()获取canvas进行绘制;\n* 创建之后循环绘制,使用unlockCanvasAndPost(mCanvas)进行画布的提交;\n* canvas的擦除内容,需要使用drawColor();\n</code></pre>\n</li>\n</ol>\n<h3 id=\"SurfaceHolder\"><a href=\"#SurfaceHolder\" class=\"headerlink\" title=\"SurfaceHolder\"></a>SurfaceHolder</h3><ul>\n<li>与SurfaceView结合使用</li>\n<li>调用SurfaceView的getHolder()获得关联的SurfaceHolder</li>\n<li>SurfaceHolder设置监听Callback<ul>\n<li>surfaceChanged(SurfaceHolder holder, int format<br>  , int width, int height)<ul>\n<li>格式大小发生改变时被调用</li>\n</ul>\n</li>\n<li>surfaceCreated(SurfaceHolder holder)<ul>\n<li>创建时被调用</li>\n</ul>\n</li>\n<li>surfaceDestroyed(SurfaceHolder holder)<ul>\n<li>销毁前被调用</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>getSurface()<ul>\n<li>对surface持有管理 </li>\n</ul>\n</li>\n<li>更新参数得到新的surface的函数<ul>\n<li>setFixedSize()</li>\n<li>setSizeFromLayout()</li>\n<li>setFormat()</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"SurfaceView的绘制过程\"><a href=\"#SurfaceView的绘制过程\" class=\"headerlink\" title=\"SurfaceView的绘制过程\"></a>SurfaceView的绘制过程</h3><ul>\n<li><p>绘制之前需要<strong>锁定绘制区域</strong>选取来得到Canvas:</p>\n<pre><code>canvas = holder.lockCanvas(new Rect(lt_x,lt_y,rb_x,rb_y));\n\n* 注:lockCanvas()无参时绘制所有区域,有参绘制效率更高;\n</code></pre></li>\n<li><p>绘制结束释放Canvas提交修改内容</p>\n<pre><code>holder.unlockCanvasAndPost(canvas);\n</code></pre></li>\n</ul>\n<h3 id=\"其他理解\"><a href=\"#其他理解\" class=\"headerlink\" title=\"其他理解\"></a>其他理解</h3><pre><code>1. SurfaceView所做的全部就是要求WindowManager创建一个window，并告诉Window Manager所创建的window的Z轴顺序（Z-order）\n2. 这个Z轴顺序可以帮助Window Manager决定将新建的window置于SurfaceView所属window的前面还是后面。\n3. WindowManager会将新建的window放置到SurfaceView在所属window中的位置。如果新建window在SurfaceView所属window后面，SurfaceView会将它在所属window中占据的部分变透明，以便让后面的window显示出来。\n</code></pre><p>SurfaceView和DecorView根节点视图一样,能对WMS可见.虽然在Server端（WMS和SF）中，但是与宿主窗口是分离的.在WMS中有对应的WindowState,对应SurfaceFlinger的Layer(图层).</p>\n<pre><code>- 优点:Surface可以放到单独的线程做,渲染自己对应的GL Context.\n- 缺点:不在View树型结构中,不受View的属性控制,不能进行各种变换,一些属性也无法使用.\n</code></pre><hr>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Surface-amp-SurfaceView\"><a href=\"#Surface-amp-SurfaceView\" class=\"headerlink\" title=\"Surface &amp; SurfaceView\"></a>Surface &amp; SurfaceView</h1><hr>\n<h2 id=\"Surface\"><a href=\"#Surface\" class=\"headerlink\" title=\"Surface\"></a>Surface</h2><ul>\n<li>surface对应一个图层,原始图像缓冲区(由屏幕图像合成器管理)的句柄,</li>\n<li>surface可以理解为用于显示的一段内存;</li>\n<li>surface持有一定量的像素点,每一个Window都对应一个surface来将自己的内容进行绘制;</li>\n<li>surface的双缓冲区的作用: 在绘制16ms后显示的内容的同时,可以将当前时刻的所有像素根据z轴上的位置渲染到屏幕上.</li>\n</ul>\n<p>简要理解:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>. updateWindow()中IWindowSession(≈ViewRootImpl)创建surface</span><br><span class=\"line\"><span class=\"number\">2</span>. 跨进程调用WindowManagerService重绘surface并更新(mSurface.transferFrom(mNewSurface))</span><br><span class=\"line\"><span class=\"number\">3</span>. 返回surface给SurfaceView</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"SurfaceView\"><a href=\"#SurfaceView\" class=\"headerlink\" title=\"SurfaceView\"></a>SurfaceView</h2><ul>\n<li>View适用于对于用户的操作做出一定的响应,较为被动;</li>\n<li>SurfaceView较为主动,不会阻塞UI,需要不同的线程和surface来动态更新;</li>\n</ul>\n<h3 id=\"和View的区别\"><a href=\"#和View的区别\" class=\"headerlink\" title=\"和View的区别\"></a>和View的区别</h3><ol>\n<li>View通过刷新来重绘视图，Android系统通过发出VSYNC信号来进行屏幕的重绘，刷新的时间间隔为16ms,超出就会卡顿;</li>\n<li>SurfaceView继承于View,拥有独立的绘制表面,不与宿主窗口共享一个绘制表面,单独在一个线程中绘制,不占用主线程的资源,主要用到的位置是游戏和视频播放,直播;<ul>\n<li>每一个SurfaceView在SurfaceFlinger服务中还对应有一个独立的Layer或者LayerBuffer，用来单独描述它的绘图表面，以区别于它的宿主窗口的绘图表面。</li>\n</ul>\n</li>\n<li>SurfaceView有两个子类GLSurfaceView和VideoView;</li>\n<li><a href=\"http://www.jianshu.com/p/15060fc9ef18\" target=\"_blank\" rel=\"noopener\">其他区别</a>:<ul>\n<li>View–主动更新，SurfaceView–被动更新，例如频繁地刷新;</li>\n<li>View–主线程，而SurfaceView–子线程刷新页面;</li>\n<li>SufaceView实现双缓冲机制;</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"View的缺陷\"><a href=\"#View的缺陷\" class=\"headerlink\" title=\"View的缺陷\"></a>View的缺陷</h3><ul>\n<li>View没有双缓冲机制</li>\n<li>View更新图像必须重新绘制</li>\n<li>View的更新必须在定义线程中进行,由于使用的是UI中公用的surface</li>\n</ul>\n<h2 id=\"SurfaceView基本使用\"><a href=\"#SurfaceView基本使用\" class=\"headerlink\" title=\"SurfaceView基本使用\"></a>SurfaceView基本使用</h2><ol>\n<li><p>创建</p>\n<pre><code>* extends SurfaceView implements SurfaceHolder.Callback\n* 实现函数有:\n    * 创建--surfaceCreated(SurfaceHolder holder)\n    * 更新--surfaceChanged(SurfaceHolder holder, int format, int width, int height)\n    * 销毁--surfaceDestroyed(SurfaceHolder holder) \n* SurfaceHolder.CallBack还有一个子Callback2接口，\n  里面添加了一个surfaceRedrawNeeded (SurfaceHolder holder)方法,\n  当需要重绘SurfaceView中的内容使用.\n</code></pre></li>\n<li><p>初始化</p>\n<ul>\n<li>初始化可以控制大小,格式,监控或改变SurfaceView的surfaceHolder;</li>\n<li>设置是否可以获取焦点和触摸获取焦点信息,是否保持屏幕长亮;(一般上对EditText设置,设置了focusableInTouchMode(true)的editText才能在弹出键盘的时候得到输入的内容)<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mSurfaceHolder = getHolder();<span class=\"comment\">//得到SurfaceHolder对象</span></span><br><span class=\"line\">mSurfaceHolder.addCallback(<span class=\"keyword\">this</span>);<span class=\"comment\">//注册SurfaceHolder</span></span><br><span class=\"line\">setFocusable(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">setFocusableInTouchMode(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"><span class=\"keyword\">this</span>.setKeepScreenOn(<span class=\"keyword\">true</span>);<span class=\"comment\">//保持屏幕长亮</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>使用</p>\n<pre><code class=\"java\">* 在开启的线程中使用SurfaceHolder#lockCanvas()获取canvas进行绘制;\n* 创建之后循环绘制,使用unlockCanvasAndPost(mCanvas)进行画布的提交;\n* canvas的擦除内容,需要使用drawColor();\n</code></pre>\n</li>\n</ol>\n<h3 id=\"SurfaceHolder\"><a href=\"#SurfaceHolder\" class=\"headerlink\" title=\"SurfaceHolder\"></a>SurfaceHolder</h3><ul>\n<li>与SurfaceView结合使用</li>\n<li>调用SurfaceView的getHolder()获得关联的SurfaceHolder</li>\n<li>SurfaceHolder设置监听Callback<ul>\n<li>surfaceChanged(SurfaceHolder holder, int format<br>  , int width, int height)<ul>\n<li>格式大小发生改变时被调用</li>\n</ul>\n</li>\n<li>surfaceCreated(SurfaceHolder holder)<ul>\n<li>创建时被调用</li>\n</ul>\n</li>\n<li>surfaceDestroyed(SurfaceHolder holder)<ul>\n<li>销毁前被调用</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>getSurface()<ul>\n<li>对surface持有管理 </li>\n</ul>\n</li>\n<li>更新参数得到新的surface的函数<ul>\n<li>setFixedSize()</li>\n<li>setSizeFromLayout()</li>\n<li>setFormat()</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"SurfaceView的绘制过程\"><a href=\"#SurfaceView的绘制过程\" class=\"headerlink\" title=\"SurfaceView的绘制过程\"></a>SurfaceView的绘制过程</h3><ul>\n<li><p>绘制之前需要<strong>锁定绘制区域</strong>选取来得到Canvas:</p>\n<pre><code>canvas = holder.lockCanvas(new Rect(lt_x,lt_y,rb_x,rb_y));\n\n* 注:lockCanvas()无参时绘制所有区域,有参绘制效率更高;\n</code></pre></li>\n<li><p>绘制结束释放Canvas提交修改内容</p>\n<pre><code>holder.unlockCanvasAndPost(canvas);\n</code></pre></li>\n</ul>\n<h3 id=\"其他理解\"><a href=\"#其他理解\" class=\"headerlink\" title=\"其他理解\"></a>其他理解</h3><pre><code>1. SurfaceView所做的全部就是要求WindowManager创建一个window，并告诉Window Manager所创建的window的Z轴顺序（Z-order）\n2. 这个Z轴顺序可以帮助Window Manager决定将新建的window置于SurfaceView所属window的前面还是后面。\n3. WindowManager会将新建的window放置到SurfaceView在所属window中的位置。如果新建window在SurfaceView所属window后面，SurfaceView会将它在所属window中占据的部分变透明，以便让后面的window显示出来。\n</code></pre><p>SurfaceView和DecorView根节点视图一样,能对WMS可见.虽然在Server端（WMS和SF）中，但是与宿主窗口是分离的.在WMS中有对应的WindowState,对应SurfaceFlinger的Layer(图层).</p>\n<pre><code>- 优点:Surface可以放到单独的线程做,渲染自己对应的GL Context.\n- 缺点:不在View树型结构中,不受View的属性控制,不能进行各种变换,一些属性也无法使用.\n</code></pre><hr>\n"},{"_content":"# Notification & RemoteViews\n\n<font color=\"red\">** `Notification` 与 `AppwidgetProvider`桌面控件 均运行在`SystemServer`进程中.**</font>\n\n---\n### 1. PendingIntent\nPendingIntent.Flag | Define\n-|-\nFLAG_CANCEL_CURRENT|如果要创建的PI**已经**存在，**重新创建**之前，已存PI中的**intent将不能使用 → 之前通知点击无法打开**\nFLAG_NO_CREATE|如果要创建的PI**尚未**存在，**不创建而直接返回null，不单独使用**\nFLAG_ONE_SHOT|相同的PI**只能使用一次**，存在相同的PI时**不会更新，后续通知点击无法打开**\nFLAG_UPDATE_CURRENT|<font color=\"red\">**相同 → 保留 → 替换原extra**</font>\n\n\t注: \n\t\t1. 判断PI是否相等的依据:\n\t\t\t1. Intent是否\"相同\"(相同的components和intent-filter(action、data、categories、type和flags));\n\t\t\t2. requestCode是否一致;\n\n\n---\n### 2. RemoteViews\n\n1. 支持并设置View\n\n\t\tLayout:\n\t\t\tFrameLayout,LinearLayout,RelativeLayout,GridLayout\n\t\tView:\n\t\t\tTextView,Button,ImageButton,ImageView,ProgressBar,\n\t\t\tViewFlipper,ListView,GridView,ViewStub,\n\t\t\tAnalogClock,Chronometer,StackView,AdapterViewFlipper\n\n\t除了TextView,ImageView之外,可反射设置其他属性\n\t\tsetInt/Long/Boolean(int,methodName,value)\n\n2. <font color=\"green\">**内部机制**\t\n\n\t1. **`RemoteViews`被应用于通知和桌面小部件,分别使用`NotificationManager(NM)`和`AppWidgetManager(AWM)`进行管理,分别在`(SystemServer中的)NotificationManagerService(NMS)`和`AppWidgetService(AWS)`中加载;**\n\n\t2. **封装好的设置View的方法内部调用`setAction()`将View操作作为Action操作对象,之后会被跨进程传输到远程进程;**\n\n\t3. **所有Action存储到`RemoteViews`的`mActions[ArrayList类型]`中;**\n\n\t4. **所有Action并没有立即更新界面,在`NM # notify()`和`AWM # updateAppwidget()`中 调用 `RemoteViews # apply/reApply() `来加载或更新布局;**\t</font>\n\n\n3. IPC操作中两个应用进程的资源id不相同**可以使用id名称进行加载;**\n\n\t\tint layoutId = getResources().getIdentifier(\"layout_name\",\"layout\",getPackageName());\n\t\t//相当于获得了R.layout.layout_name的id\n\t\tView view = getLayoutInflater().inflate(layoutId,mRemoteViewsContent,false);\n\t\tremoteViews.reapply(this,view);\n\t\t//mRemoteViewsContent.addView(view);\n\t\t\t\n\n---\n### 3. Notification\n<font color=\"red\">**Notification使用NotificationManger创建.**</font>\n1. Flags\n\nFlags|define\n:-|:-\nFLAG_SHOW_LIGHTS|三色灯提醒\nFLAG_ONGOING_EVENT|\t发起正在运行事件（活动中）\nFLAG_INSISTENT|声音振动无限循环，直到响应 （取消或者打开）\nFLAG_ONLY_ALERT_ONCE|铃声和震动均只执行一次\nFLAG_AUTO_CANCEL|点击自动消失\nFLAG_NO_CLEAR|只有全部清除时才会清除 \nFLAG_FOREGROUND_SERVICE|表示正在运行的服务\n\n2.Default\n\ndefault|define\n:-|:-\nDEFAULT_VIBRATE | 添加默认震动提醒 需要 VIBRATE permission\nDEFAULT_SOUND | 添加默认声音提醒\nDEFAULT_LIGHTS| 添加默认三色灯提醒\nDEFAULT_ALL| 添加默认以上3种全部提醒\n\n\n---","source":"_posts/Android之显示——Notification.md","raw":"# Notification & RemoteViews\n\n<font color=\"red\">** `Notification` 与 `AppwidgetProvider`桌面控件 均运行在`SystemServer`进程中.**</font>\n\n---\n### 1. PendingIntent\nPendingIntent.Flag | Define\n-|-\nFLAG_CANCEL_CURRENT|如果要创建的PI**已经**存在，**重新创建**之前，已存PI中的**intent将不能使用 → 之前通知点击无法打开**\nFLAG_NO_CREATE|如果要创建的PI**尚未**存在，**不创建而直接返回null，不单独使用**\nFLAG_ONE_SHOT|相同的PI**只能使用一次**，存在相同的PI时**不会更新，后续通知点击无法打开**\nFLAG_UPDATE_CURRENT|<font color=\"red\">**相同 → 保留 → 替换原extra**</font>\n\n\t注: \n\t\t1. 判断PI是否相等的依据:\n\t\t\t1. Intent是否\"相同\"(相同的components和intent-filter(action、data、categories、type和flags));\n\t\t\t2. requestCode是否一致;\n\n\n---\n### 2. RemoteViews\n\n1. 支持并设置View\n\n\t\tLayout:\n\t\t\tFrameLayout,LinearLayout,RelativeLayout,GridLayout\n\t\tView:\n\t\t\tTextView,Button,ImageButton,ImageView,ProgressBar,\n\t\t\tViewFlipper,ListView,GridView,ViewStub,\n\t\t\tAnalogClock,Chronometer,StackView,AdapterViewFlipper\n\n\t除了TextView,ImageView之外,可反射设置其他属性\n\t\tsetInt/Long/Boolean(int,methodName,value)\n\n2. <font color=\"green\">**内部机制**\t\n\n\t1. **`RemoteViews`被应用于通知和桌面小部件,分别使用`NotificationManager(NM)`和`AppWidgetManager(AWM)`进行管理,分别在`(SystemServer中的)NotificationManagerService(NMS)`和`AppWidgetService(AWS)`中加载;**\n\n\t2. **封装好的设置View的方法内部调用`setAction()`将View操作作为Action操作对象,之后会被跨进程传输到远程进程;**\n\n\t3. **所有Action存储到`RemoteViews`的`mActions[ArrayList类型]`中;**\n\n\t4. **所有Action并没有立即更新界面,在`NM # notify()`和`AWM # updateAppwidget()`中 调用 `RemoteViews # apply/reApply() `来加载或更新布局;**\t</font>\n\n\n3. IPC操作中两个应用进程的资源id不相同**可以使用id名称进行加载;**\n\n\t\tint layoutId = getResources().getIdentifier(\"layout_name\",\"layout\",getPackageName());\n\t\t//相当于获得了R.layout.layout_name的id\n\t\tView view = getLayoutInflater().inflate(layoutId,mRemoteViewsContent,false);\n\t\tremoteViews.reapply(this,view);\n\t\t//mRemoteViewsContent.addView(view);\n\t\t\t\n\n---\n### 3. Notification\n<font color=\"red\">**Notification使用NotificationManger创建.**</font>\n1. Flags\n\nFlags|define\n:-|:-\nFLAG_SHOW_LIGHTS|三色灯提醒\nFLAG_ONGOING_EVENT|\t发起正在运行事件（活动中）\nFLAG_INSISTENT|声音振动无限循环，直到响应 （取消或者打开）\nFLAG_ONLY_ALERT_ONCE|铃声和震动均只执行一次\nFLAG_AUTO_CANCEL|点击自动消失\nFLAG_NO_CLEAR|只有全部清除时才会清除 \nFLAG_FOREGROUND_SERVICE|表示正在运行的服务\n\n2.Default\n\ndefault|define\n:-|:-\nDEFAULT_VIBRATE | 添加默认震动提醒 需要 VIBRATE permission\nDEFAULT_SOUND | 添加默认声音提醒\nDEFAULT_LIGHTS| 添加默认三色灯提醒\nDEFAULT_ALL| 添加默认以上3种全部提醒\n\n\n---","slug":"Android之显示——Notification","published":1,"date":"2018-03-21T03:22:18.421Z","updated":"2017-12-04T03:18:58.036Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0kjqj9000e0s4l6jy33i4g","content":"<h1 id=\"Notification-amp-RemoteViews\"><a href=\"#Notification-amp-RemoteViews\" class=\"headerlink\" title=\"Notification &amp; RemoteViews\"></a>Notification &amp; RemoteViews</h1><font color=\"red\"><strong> <code>Notification</code> 与 <code>AppwidgetProvider</code>桌面控件 均运行在<code>SystemServer</code>进程中.</strong></font>\n\n<hr>\n<h3 id=\"1-PendingIntent\"><a href=\"#1-PendingIntent\" class=\"headerlink\" title=\"1. PendingIntent\"></a>1. PendingIntent</h3><table>\n<thead>\n<tr>\n<th>PendingIntent.Flag</th>\n<th>Define</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>FLAG_CANCEL_CURRENT</td>\n<td>如果要创建的PI<strong>已经</strong>存在，<strong>重新创建</strong>之前，已存PI中的<strong>intent将不能使用 → 之前通知点击无法打开</strong></td>\n</tr>\n<tr>\n<td>FLAG_NO_CREATE</td>\n<td>如果要创建的PI<strong>尚未</strong>存在，<strong>不创建而直接返回null，不单独使用</strong></td>\n</tr>\n<tr>\n<td>FLAG_ONE_SHOT</td>\n<td>相同的PI<strong>只能使用一次</strong>，存在相同的PI时<strong>不会更新，后续通知点击无法打开</strong></td>\n</tr>\n<tr>\n<td>FLAG_UPDATE_CURRENT</td>\n<td><font color=\"red\"><strong>相同 → 保留 → 替换原extra</strong></font></td>\n</tr>\n</tbody>\n</table>\n<pre><code>注: \n    1. 判断PI是否相等的依据:\n        1. Intent是否&quot;相同&quot;(相同的components和intent-filter(action、data、categories、type和flags));\n        2. requestCode是否一致;\n</code></pre><hr>\n<h3 id=\"2-RemoteViews\"><a href=\"#2-RemoteViews\" class=\"headerlink\" title=\"2. RemoteViews\"></a>2. RemoteViews</h3><ol>\n<li><p>支持并设置View</p>\n<pre><code>Layout:\n    FrameLayout,LinearLayout,RelativeLayout,GridLayout\nView:\n    TextView,Button,ImageButton,ImageView,ProgressBar,\n    ViewFlipper,ListView,GridView,ViewStub,\n    AnalogClock,Chronometer,StackView,AdapterViewFlipper\n</code></pre><p> 除了TextView,ImageView之外,可反射设置其他属性</p>\n<pre><code>setInt/Long/Boolean(int,methodName,value)\n</code></pre></li>\n<li><font color=\"green\"><strong>内部机制</strong><br><br> 1. <strong><code>RemoteViews</code>被应用于通知和桌面小部件,分别使用<code>NotificationManager(NM)</code>和<code>AppWidgetManager(AWM)</code>进行管理,分别在<code>(SystemServer中的)NotificationManagerService(NMS)</code>和<code>AppWidgetService(AWS)</code>中加载;</strong><br><br> 2. <strong>封装好的设置View的方法内部调用<code>setAction()</code>将View操作作为Action操作对象,之后会被跨进程传输到远程进程;</strong><br><br> 3. <strong>所有Action存储到<code>RemoteViews</code>的<code>mActions[ArrayList类型]</code>中;</strong><br><br> 4. <strong>所有Action并没有立即更新界面,在<code>NM # notify()</code>和<code>AWM # updateAppwidget()</code>中 调用 <code>RemoteViews # apply/reApply()</code>来加载或更新布局;</strong>    </font>\n\n\n</li>\n</ol>\n<ol>\n<li><p>IPC操作中两个应用进程的资源id不相同<strong>可以使用id名称进行加载;</strong></p>\n<pre><code>int layoutId = getResources().getIdentifier(&quot;layout_name&quot;,&quot;layout&quot;,getPackageName());\n//相当于获得了R.layout.layout_name的id\nView view = getLayoutInflater().inflate(layoutId,mRemoteViewsContent,false);\nremoteViews.reapply(this,view);\n//mRemoteViewsContent.addView(view);\n</code></pre></li>\n</ol>\n<hr>\n<h3 id=\"3-Notification\"><a href=\"#3-Notification\" class=\"headerlink\" title=\"3. Notification\"></a>3. Notification</h3><p><font color=\"red\"><strong>Notification使用NotificationManger创建.</strong></font></p>\n<ol>\n<li>Flags</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Flags</th>\n<th style=\"text-align:left\">define</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">FLAG_SHOW_LIGHTS</td>\n<td style=\"text-align:left\">三色灯提醒</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FLAG_ONGOING_EVENT</td>\n<td style=\"text-align:left\">发起正在运行事件（活动中）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FLAG_INSISTENT</td>\n<td style=\"text-align:left\">声音振动无限循环，直到响应 （取消或者打开）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FLAG_ONLY_ALERT_ONCE</td>\n<td style=\"text-align:left\">铃声和震动均只执行一次</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FLAG_AUTO_CANCEL</td>\n<td style=\"text-align:left\">点击自动消失</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FLAG_NO_CLEAR</td>\n<td style=\"text-align:left\">只有全部清除时才会清除 </td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FLAG_FOREGROUND_SERVICE</td>\n<td style=\"text-align:left\">表示正在运行的服务</td>\n</tr>\n</tbody>\n</table>\n<p>2.Default</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">default</th>\n<th style=\"text-align:left\">define</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">DEFAULT_VIBRATE</td>\n<td style=\"text-align:left\">添加默认震动提醒 需要 VIBRATE permission</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DEFAULT_SOUND</td>\n<td style=\"text-align:left\">添加默认声音提醒</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DEFAULT_LIGHTS</td>\n<td style=\"text-align:left\">添加默认三色灯提醒</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DEFAULT_ALL</td>\n<td style=\"text-align:left\">添加默认以上3种全部提醒</td>\n</tr>\n</tbody>\n</table>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Notification-amp-RemoteViews\"><a href=\"#Notification-amp-RemoteViews\" class=\"headerlink\" title=\"Notification &amp; RemoteViews\"></a>Notification &amp; RemoteViews</h1><font color=\"red\"><strong> <code>Notification</code> 与 <code>AppwidgetProvider</code>桌面控件 均运行在<code>SystemServer</code>进程中.</strong></font>\n\n<hr>\n<h3 id=\"1-PendingIntent\"><a href=\"#1-PendingIntent\" class=\"headerlink\" title=\"1. PendingIntent\"></a>1. PendingIntent</h3><table>\n<thead>\n<tr>\n<th>PendingIntent.Flag</th>\n<th>Define</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>FLAG_CANCEL_CURRENT</td>\n<td>如果要创建的PI<strong>已经</strong>存在，<strong>重新创建</strong>之前，已存PI中的<strong>intent将不能使用 → 之前通知点击无法打开</strong></td>\n</tr>\n<tr>\n<td>FLAG_NO_CREATE</td>\n<td>如果要创建的PI<strong>尚未</strong>存在，<strong>不创建而直接返回null，不单独使用</strong></td>\n</tr>\n<tr>\n<td>FLAG_ONE_SHOT</td>\n<td>相同的PI<strong>只能使用一次</strong>，存在相同的PI时<strong>不会更新，后续通知点击无法打开</strong></td>\n</tr>\n<tr>\n<td>FLAG_UPDATE_CURRENT</td>\n<td><font color=\"red\"><strong>相同 → 保留 → 替换原extra</strong></font></td>\n</tr>\n</tbody>\n</table>\n<pre><code>注: \n    1. 判断PI是否相等的依据:\n        1. Intent是否&quot;相同&quot;(相同的components和intent-filter(action、data、categories、type和flags));\n        2. requestCode是否一致;\n</code></pre><hr>\n<h3 id=\"2-RemoteViews\"><a href=\"#2-RemoteViews\" class=\"headerlink\" title=\"2. RemoteViews\"></a>2. RemoteViews</h3><ol>\n<li><p>支持并设置View</p>\n<pre><code>Layout:\n    FrameLayout,LinearLayout,RelativeLayout,GridLayout\nView:\n    TextView,Button,ImageButton,ImageView,ProgressBar,\n    ViewFlipper,ListView,GridView,ViewStub,\n    AnalogClock,Chronometer,StackView,AdapterViewFlipper\n</code></pre><p> 除了TextView,ImageView之外,可反射设置其他属性</p>\n<pre><code>setInt/Long/Boolean(int,methodName,value)\n</code></pre></li>\n<li><font color=\"green\"><strong>内部机制</strong><br><br> 1. <strong><code>RemoteViews</code>被应用于通知和桌面小部件,分别使用<code>NotificationManager(NM)</code>和<code>AppWidgetManager(AWM)</code>进行管理,分别在<code>(SystemServer中的)NotificationManagerService(NMS)</code>和<code>AppWidgetService(AWS)</code>中加载;</strong><br><br> 2. <strong>封装好的设置View的方法内部调用<code>setAction()</code>将View操作作为Action操作对象,之后会被跨进程传输到远程进程;</strong><br><br> 3. <strong>所有Action存储到<code>RemoteViews</code>的<code>mActions[ArrayList类型]</code>中;</strong><br><br> 4. <strong>所有Action并没有立即更新界面,在<code>NM # notify()</code>和<code>AWM # updateAppwidget()</code>中 调用 <code>RemoteViews # apply/reApply()</code>来加载或更新布局;</strong>    </font>\n\n\n</li>\n</ol>\n<ol>\n<li><p>IPC操作中两个应用进程的资源id不相同<strong>可以使用id名称进行加载;</strong></p>\n<pre><code>int layoutId = getResources().getIdentifier(&quot;layout_name&quot;,&quot;layout&quot;,getPackageName());\n//相当于获得了R.layout.layout_name的id\nView view = getLayoutInflater().inflate(layoutId,mRemoteViewsContent,false);\nremoteViews.reapply(this,view);\n//mRemoteViewsContent.addView(view);\n</code></pre></li>\n</ol>\n<hr>\n<h3 id=\"3-Notification\"><a href=\"#3-Notification\" class=\"headerlink\" title=\"3. Notification\"></a>3. Notification</h3><p><font color=\"red\"><strong>Notification使用NotificationManger创建.</strong></font></p>\n<ol>\n<li>Flags</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Flags</th>\n<th style=\"text-align:left\">define</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">FLAG_SHOW_LIGHTS</td>\n<td style=\"text-align:left\">三色灯提醒</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FLAG_ONGOING_EVENT</td>\n<td style=\"text-align:left\">发起正在运行事件（活动中）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FLAG_INSISTENT</td>\n<td style=\"text-align:left\">声音振动无限循环，直到响应 （取消或者打开）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FLAG_ONLY_ALERT_ONCE</td>\n<td style=\"text-align:left\">铃声和震动均只执行一次</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FLAG_AUTO_CANCEL</td>\n<td style=\"text-align:left\">点击自动消失</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FLAG_NO_CLEAR</td>\n<td style=\"text-align:left\">只有全部清除时才会清除 </td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FLAG_FOREGROUND_SERVICE</td>\n<td style=\"text-align:left\">表示正在运行的服务</td>\n</tr>\n</tbody>\n</table>\n<p>2.Default</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">default</th>\n<th style=\"text-align:left\">define</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">DEFAULT_VIBRATE</td>\n<td style=\"text-align:left\">添加默认震动提醒 需要 VIBRATE permission</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DEFAULT_SOUND</td>\n<td style=\"text-align:left\">添加默认声音提醒</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DEFAULT_LIGHTS</td>\n<td style=\"text-align:left\">添加默认三色灯提醒</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DEFAULT_ALL</td>\n<td style=\"text-align:left\">添加默认以上3种全部提醒</td>\n</tr>\n</tbody>\n</table>\n<hr>\n"},{"_content":"# Android权限的了解和处理 #\n\n---\n\n\t目录:\n\t\t1. 权限的了解\n\n\t\t\t- 危险权限\n\t\t\t- 危险权限自定义申请断后\n\n\t\t2. 权限处理\n\n\t\t\t1. android 6.0\n\t\t\t2. android 7.0\n\t\t\t3. android 8.0\n\n\t\t3. 权限的授权\n\t\t4. 其他权限\n\n\n---\n\n\n### 权限的了解\n\n- 注意:\n\t- Android 6.0 之前的权限机制是**安装时永久性授权**;\n\t- 并不是所有的权限都需要运行时申请才能使用;\n\t- 危险权限在授予一个权限组的权限之后,组内所有的权限都被授权;\n\n####  1. 危险权限\n\n危险权限包含以下权限组:\n\n\n\t- 日历\n\t\t- READ_CALENDAR\n\t\t- WRITE_CALENDAR\n\t- 相机\n\t\t- CAMERA\n\t- 联系人\n\t\t- READ_CONTACTS\n\t\t- WRITE_CONTACTS\n\t\t- GET_ACCOUNTS\n\t- 定位\n\t\t- ACCESS_FINE_LOCATION\n\t\t- ACCESS_COARSE_LOCATION\n\t- 麦克风\n\t\t- RECORD_AUDIO\n\t- 电话\n\t\t- READ_PHONE_STATE\n\t\t- CALL_PHONE\n\t\t- READ_CALL_LOG\n\t\t- WRITE_CALL_LOG\n\t\t- ADD_VOICEMAIL\n\t\t- USE_SIP\n\t\t- PROCESS_OUTGOING_CALLS\n\t- 传感器\n\t\t- BODY_SENSORS\n\t- 短信\n\t\t- SEND_SMS\n\t\t- RECEIVE_SMS\n\t\t- READ_SMS\n\t\t- RECEIVE_WAP_PUSH\n\t\t- RECEIVE_MMS\n\t- 存储\n\t\t- READ_EXTERNAL_STORAGE\n\t\t- WRITE_EXTERNAL_STORAGE\n\n\n1. 检测权限是否为允许:**返回值为0时为已允许,1时为拒绝或未申请**;\n\t\n\t\t- Activity#checkSelfPermission(permission)\n\t\t- PackageManager#checkPermission(permission, getPackageName()))\n\t\t\n2. 申请权限\n\n\t\t- Activity#requestPermissions(permissions, requestCode);\n\t\t- ActivityCompat.requestPermissions(this, permissions, requestCode);\n\n3. 权限请求结果返回\n\n\t\t- Activity#onRequestPermissionsResult(int requestCode,\n\t\t\t @NonNull String[] permissions,\n\t\t\t @NonNull int[] grantResults) \n\n\n4. 权限说明:只有当用户拒绝时没有选中\"不在提示\"时才会返回true;\n\n\n\t\t- Activity#shouldShowRequestPermissionRationale(@NonNull String permission)\n\t\t- ActivityCompat.shouldShowRequestPermissionRationale(this, permissions[0])\n\n\n#### 2. 危险权限自定义申请断后 \n\n\tString[] dangerousPermissions = {\n            Manifest.permission.WRITE_EXTERNAL_STORAGE//读写权限0\n            , Manifest.permission.CAMERA//相机权限1\n            , Manifest.permission.WRITE_CONTACTS//写入联系人2\n            , Manifest.permission.CALL_PHONE//打电话3\n            , Manifest.permission.SEND_SMS//发送短信4\n            , Manifest.permission.RECORD_AUDIO//麦克风打开5\n            , Manifest.permission.ACCESS_FINE_LOCATION//定位相关6\n            , Manifest.permission.BODY_SENSORS//传感器 7  最小使用SDK 20\n            , Manifest.permission.WRITE_CALENDAR//日历写入8\n    };\n\n     void requestPermission(String... permissions) {\n        if (permissions.length > 1) {\n            ActivityCompat.requestPermissions(this, permissions, REQUEST_CODE_PERMISSIONS);\n        } else {\n            ActivityCompat.requestPermissions(this, permissions, REQUEST_CODE_PERMISSION);\n        }\n    }\n\n    /**\n     * 请求运行时权限\n     *\n     * @param listener\n     * @param permissions\n     */\n    protected void requestPermission(PermissionResultListener listener, String... permissions) {\n        permissionResultListener = listener;\n        requestPermission(permissions);\n    }\n\n    @Override\n    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n        if (requestCode == REQUEST_CODE_PERMISSION) {//单个权限申请结果\n            if (grantResults.length == 0) return;\n            if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {//权限申请成功\n                if (permissionResultListener != null)\n                    permissionResultListener.onSinglePermissionGranted(permissions[0]);\n            } else {//权限申请失败\n                if (!ActivityCompat.shouldShowRequestPermissionRationale(this, permissions[0])) {//已点不再询问\n                    showSnackbar(\"权限已被禁止,并不再询问,请在设置中打开\", Snackbar.LENGTH_LONG);\n                    AlertDialog.Builder builder = new AlertDialog.Builder(this);\n                    builder.setMessage(\"是否打开应用设置页面?\").setPositiveButton(\"确定\", new DialogInterface.OnClickListener() {\n                        @Override\n                        public void onClick(DialogInterface dialog, int which) {\n                            getAppDetailSettingIntent();\n                        }\n                    }).setNegativeButton(\"取消\", null).create().show();\n                } else {//再次询问?\n                    if (permissionResultListener != null)\n                        permissionResultListener.onSinglePermissionDenied(permissions[0]);\n                }\n            }\n        }\n        if (requestCode == REQUEST_CODE_PERMISSIONS) {//多个权限申请结果\n            if (grantResults.length == 0) return;\n            List<String> deniedPermissions = new ArrayList<>();\n            for (int i = 0; i < permissions.length; i++) {\n                if (grantResults[i] != PackageManager.PERMISSION_GRANTED) {\n                    deniedPermissions.add(permissions[i]);\n                }\n            }\n            if (deniedPermissions.size() != 0) {//有权限未允许\n                if (permissionResultListener != null)\n                    permissionResultListener.onPermissionsDenied(deniedPermissions);\n            } else {//权限已被完全允许\n                if (permissionResultListener != null)\n                    permissionResultListener.onPermissionsGrantedAll();\n            }\n        }\n    }\n\n    PermissionResultListener permissionResultListener;\n\n    interface PermissionResultListener {\n        void onSinglePermissionDenied(String permission);\n\n        void onSinglePermissionGranted(String permission);\n\n        void onPermissionsGrantedAll();\n\n        void onPermissionsDenied(List<String> deniedPermissions);\n\n    }\n\n\n    /**\n     * 打开应用设置界面\n     */\n    private void getAppDetailSettingIntent() {\n        Intent localIntent = new Intent();\n        localIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        if (Build.VERSION.SDK_INT >= 9) {\n            localIntent.setAction(\"android.settings.APPLICATION_DETAILS_SETTINGS\");\n            localIntent.setData(Uri.fromParts(\"package\", getPackageName(), null));\n        } else if (Build.VERSION.SDK_INT <= 8) {\n            localIntent.setAction(Intent.ACTION_VIEW);\n            localIntent.setClassName(\"com.android.settings\", \"com.android.settings.InstalledAppDetails\");\n            localIntent.putExtra(\"com.android.settings.ApplicationPkgName\", getPackageName());\n        }\n        startActivity(localIntent);\n    }\n\n\t@Override\n    protected void onDestroy() {\n        super.onDestroy();\n\n        //...其他操作\n\n    }\n\n\n#### 3. 特殊权限\n\n- SYSTEM_ ALERT_ WINDOW\n\n\t在 android api 23以上需要判断是否可以在其他应用上层显示弹框,需要手动申请跳转界面\n\n\t\t//判断是否可以上层显示并跳转\n\t\t if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M&& !Settings.canDrawOverlays(this)) {\n            Intent intent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION,\n                    Uri.parse(\"package:\" + getPackageName()));\n            startActivityForResult(intent,10);\n        }\n\n\n\t\t\n\t\t\n\t\t\n- WRITE_ SETTINGS\n\t\n\n\n### 权限处理\n\n####  android 6.0\n####  android 7.0\n####  android 8.0\n\n\n### 权限的授权\n\n\n\n### 其他权限 ###\n","source":"_posts/Android之权限.md","raw":"# Android权限的了解和处理 #\n\n---\n\n\t目录:\n\t\t1. 权限的了解\n\n\t\t\t- 危险权限\n\t\t\t- 危险权限自定义申请断后\n\n\t\t2. 权限处理\n\n\t\t\t1. android 6.0\n\t\t\t2. android 7.0\n\t\t\t3. android 8.0\n\n\t\t3. 权限的授权\n\t\t4. 其他权限\n\n\n---\n\n\n### 权限的了解\n\n- 注意:\n\t- Android 6.0 之前的权限机制是**安装时永久性授权**;\n\t- 并不是所有的权限都需要运行时申请才能使用;\n\t- 危险权限在授予一个权限组的权限之后,组内所有的权限都被授权;\n\n####  1. 危险权限\n\n危险权限包含以下权限组:\n\n\n\t- 日历\n\t\t- READ_CALENDAR\n\t\t- WRITE_CALENDAR\n\t- 相机\n\t\t- CAMERA\n\t- 联系人\n\t\t- READ_CONTACTS\n\t\t- WRITE_CONTACTS\n\t\t- GET_ACCOUNTS\n\t- 定位\n\t\t- ACCESS_FINE_LOCATION\n\t\t- ACCESS_COARSE_LOCATION\n\t- 麦克风\n\t\t- RECORD_AUDIO\n\t- 电话\n\t\t- READ_PHONE_STATE\n\t\t- CALL_PHONE\n\t\t- READ_CALL_LOG\n\t\t- WRITE_CALL_LOG\n\t\t- ADD_VOICEMAIL\n\t\t- USE_SIP\n\t\t- PROCESS_OUTGOING_CALLS\n\t- 传感器\n\t\t- BODY_SENSORS\n\t- 短信\n\t\t- SEND_SMS\n\t\t- RECEIVE_SMS\n\t\t- READ_SMS\n\t\t- RECEIVE_WAP_PUSH\n\t\t- RECEIVE_MMS\n\t- 存储\n\t\t- READ_EXTERNAL_STORAGE\n\t\t- WRITE_EXTERNAL_STORAGE\n\n\n1. 检测权限是否为允许:**返回值为0时为已允许,1时为拒绝或未申请**;\n\t\n\t\t- Activity#checkSelfPermission(permission)\n\t\t- PackageManager#checkPermission(permission, getPackageName()))\n\t\t\n2. 申请权限\n\n\t\t- Activity#requestPermissions(permissions, requestCode);\n\t\t- ActivityCompat.requestPermissions(this, permissions, requestCode);\n\n3. 权限请求结果返回\n\n\t\t- Activity#onRequestPermissionsResult(int requestCode,\n\t\t\t @NonNull String[] permissions,\n\t\t\t @NonNull int[] grantResults) \n\n\n4. 权限说明:只有当用户拒绝时没有选中\"不在提示\"时才会返回true;\n\n\n\t\t- Activity#shouldShowRequestPermissionRationale(@NonNull String permission)\n\t\t- ActivityCompat.shouldShowRequestPermissionRationale(this, permissions[0])\n\n\n#### 2. 危险权限自定义申请断后 \n\n\tString[] dangerousPermissions = {\n            Manifest.permission.WRITE_EXTERNAL_STORAGE//读写权限0\n            , Manifest.permission.CAMERA//相机权限1\n            , Manifest.permission.WRITE_CONTACTS//写入联系人2\n            , Manifest.permission.CALL_PHONE//打电话3\n            , Manifest.permission.SEND_SMS//发送短信4\n            , Manifest.permission.RECORD_AUDIO//麦克风打开5\n            , Manifest.permission.ACCESS_FINE_LOCATION//定位相关6\n            , Manifest.permission.BODY_SENSORS//传感器 7  最小使用SDK 20\n            , Manifest.permission.WRITE_CALENDAR//日历写入8\n    };\n\n     void requestPermission(String... permissions) {\n        if (permissions.length > 1) {\n            ActivityCompat.requestPermissions(this, permissions, REQUEST_CODE_PERMISSIONS);\n        } else {\n            ActivityCompat.requestPermissions(this, permissions, REQUEST_CODE_PERMISSION);\n        }\n    }\n\n    /**\n     * 请求运行时权限\n     *\n     * @param listener\n     * @param permissions\n     */\n    protected void requestPermission(PermissionResultListener listener, String... permissions) {\n        permissionResultListener = listener;\n        requestPermission(permissions);\n    }\n\n    @Override\n    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n        if (requestCode == REQUEST_CODE_PERMISSION) {//单个权限申请结果\n            if (grantResults.length == 0) return;\n            if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {//权限申请成功\n                if (permissionResultListener != null)\n                    permissionResultListener.onSinglePermissionGranted(permissions[0]);\n            } else {//权限申请失败\n                if (!ActivityCompat.shouldShowRequestPermissionRationale(this, permissions[0])) {//已点不再询问\n                    showSnackbar(\"权限已被禁止,并不再询问,请在设置中打开\", Snackbar.LENGTH_LONG);\n                    AlertDialog.Builder builder = new AlertDialog.Builder(this);\n                    builder.setMessage(\"是否打开应用设置页面?\").setPositiveButton(\"确定\", new DialogInterface.OnClickListener() {\n                        @Override\n                        public void onClick(DialogInterface dialog, int which) {\n                            getAppDetailSettingIntent();\n                        }\n                    }).setNegativeButton(\"取消\", null).create().show();\n                } else {//再次询问?\n                    if (permissionResultListener != null)\n                        permissionResultListener.onSinglePermissionDenied(permissions[0]);\n                }\n            }\n        }\n        if (requestCode == REQUEST_CODE_PERMISSIONS) {//多个权限申请结果\n            if (grantResults.length == 0) return;\n            List<String> deniedPermissions = new ArrayList<>();\n            for (int i = 0; i < permissions.length; i++) {\n                if (grantResults[i] != PackageManager.PERMISSION_GRANTED) {\n                    deniedPermissions.add(permissions[i]);\n                }\n            }\n            if (deniedPermissions.size() != 0) {//有权限未允许\n                if (permissionResultListener != null)\n                    permissionResultListener.onPermissionsDenied(deniedPermissions);\n            } else {//权限已被完全允许\n                if (permissionResultListener != null)\n                    permissionResultListener.onPermissionsGrantedAll();\n            }\n        }\n    }\n\n    PermissionResultListener permissionResultListener;\n\n    interface PermissionResultListener {\n        void onSinglePermissionDenied(String permission);\n\n        void onSinglePermissionGranted(String permission);\n\n        void onPermissionsGrantedAll();\n\n        void onPermissionsDenied(List<String> deniedPermissions);\n\n    }\n\n\n    /**\n     * 打开应用设置界面\n     */\n    private void getAppDetailSettingIntent() {\n        Intent localIntent = new Intent();\n        localIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        if (Build.VERSION.SDK_INT >= 9) {\n            localIntent.setAction(\"android.settings.APPLICATION_DETAILS_SETTINGS\");\n            localIntent.setData(Uri.fromParts(\"package\", getPackageName(), null));\n        } else if (Build.VERSION.SDK_INT <= 8) {\n            localIntent.setAction(Intent.ACTION_VIEW);\n            localIntent.setClassName(\"com.android.settings\", \"com.android.settings.InstalledAppDetails\");\n            localIntent.putExtra(\"com.android.settings.ApplicationPkgName\", getPackageName());\n        }\n        startActivity(localIntent);\n    }\n\n\t@Override\n    protected void onDestroy() {\n        super.onDestroy();\n\n        //...其他操作\n\n    }\n\n\n#### 3. 特殊权限\n\n- SYSTEM_ ALERT_ WINDOW\n\n\t在 android api 23以上需要判断是否可以在其他应用上层显示弹框,需要手动申请跳转界面\n\n\t\t//判断是否可以上层显示并跳转\n\t\t if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M&& !Settings.canDrawOverlays(this)) {\n            Intent intent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION,\n                    Uri.parse(\"package:\" + getPackageName()));\n            startActivityForResult(intent,10);\n        }\n\n\n\t\t\n\t\t\n\t\t\n- WRITE_ SETTINGS\n\t\n\n\n### 权限处理\n\n####  android 6.0\n####  android 7.0\n####  android 8.0\n\n\n### 权限的授权\n\n\n\n### 其他权限 ###\n","slug":"Android之权限","published":1,"date":"2018-03-21T03:22:18.399Z","updated":"2017-08-28T06:37:53.844Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0kjqja000f0s4l2h9fcu19","content":"<h1 id=\"Android权限的了解和处理\"><a href=\"#Android权限的了解和处理\" class=\"headerlink\" title=\"Android权限的了解和处理\"></a>Android权限的了解和处理</h1><hr>\n<pre><code>目录:\n    1. 权限的了解\n\n        - 危险权限\n        - 危险权限自定义申请断后\n\n    2. 权限处理\n\n        1. android 6.0\n        2. android 7.0\n        3. android 8.0\n\n    3. 权限的授权\n    4. 其他权限\n</code></pre><hr>\n<h3 id=\"权限的了解\"><a href=\"#权限的了解\" class=\"headerlink\" title=\"权限的了解\"></a>权限的了解</h3><ul>\n<li>注意:<ul>\n<li>Android 6.0 之前的权限机制是<strong>安装时永久性授权</strong>;</li>\n<li>并不是所有的权限都需要运行时申请才能使用;</li>\n<li>危险权限在授予一个权限组的权限之后,组内所有的权限都被授权;</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-危险权限\"><a href=\"#1-危险权限\" class=\"headerlink\" title=\"1. 危险权限\"></a>1. 危险权限</h4><p>危险权限包含以下权限组:</p>\n<pre><code>- 日历\n    - READ_CALENDAR\n    - WRITE_CALENDAR\n- 相机\n    - CAMERA\n- 联系人\n    - READ_CONTACTS\n    - WRITE_CONTACTS\n    - GET_ACCOUNTS\n- 定位\n    - ACCESS_FINE_LOCATION\n    - ACCESS_COARSE_LOCATION\n- 麦克风\n    - RECORD_AUDIO\n- 电话\n    - READ_PHONE_STATE\n    - CALL_PHONE\n    - READ_CALL_LOG\n    - WRITE_CALL_LOG\n    - ADD_VOICEMAIL\n    - USE_SIP\n    - PROCESS_OUTGOING_CALLS\n- 传感器\n    - BODY_SENSORS\n- 短信\n    - SEND_SMS\n    - RECEIVE_SMS\n    - READ_SMS\n    - RECEIVE_WAP_PUSH\n    - RECEIVE_MMS\n- 存储\n    - READ_EXTERNAL_STORAGE\n    - WRITE_EXTERNAL_STORAGE\n</code></pre><ol>\n<li><p>检测权限是否为允许:<strong>返回值为0时为已允许,1时为拒绝或未申请</strong>;</p>\n<pre><code>- Activity#checkSelfPermission(permission)\n- PackageManager#checkPermission(permission, getPackageName()))\n</code></pre></li>\n<li><p>申请权限</p>\n<pre><code>- Activity#requestPermissions(permissions, requestCode);\n- ActivityCompat.requestPermissions(this, permissions, requestCode);\n</code></pre></li>\n<li><p>权限请求结果返回</p>\n<pre><code>- Activity#onRequestPermissionsResult(int requestCode,\n     @NonNull String[] permissions,\n     @NonNull int[] grantResults) \n</code></pre></li>\n</ol>\n<ol>\n<li>权限说明:只有当用户拒绝时没有选中”不在提示”时才会返回true;</li>\n</ol>\n<pre><code>- Activity#shouldShowRequestPermissionRationale(@NonNull String permission)\n- ActivityCompat.shouldShowRequestPermissionRationale(this, permissions[0])\n</code></pre><h4 id=\"2-危险权限自定义申请断后\"><a href=\"#2-危险权限自定义申请断后\" class=\"headerlink\" title=\"2. 危险权限自定义申请断后\"></a>2. 危险权限自定义申请断后</h4><pre><code>String[] dangerousPermissions = {\n        Manifest.permission.WRITE_EXTERNAL_STORAGE//读写权限0\n        , Manifest.permission.CAMERA//相机权限1\n        , Manifest.permission.WRITE_CONTACTS//写入联系人2\n        , Manifest.permission.CALL_PHONE//打电话3\n        , Manifest.permission.SEND_SMS//发送短信4\n        , Manifest.permission.RECORD_AUDIO//麦克风打开5\n        , Manifest.permission.ACCESS_FINE_LOCATION//定位相关6\n        , Manifest.permission.BODY_SENSORS//传感器 7  最小使用SDK 20\n        , Manifest.permission.WRITE_CALENDAR//日历写入8\n};\n\n void requestPermission(String... permissions) {\n    if (permissions.length &gt; 1) {\n        ActivityCompat.requestPermissions(this, permissions, REQUEST_CODE_PERMISSIONS);\n    } else {\n        ActivityCompat.requestPermissions(this, permissions, REQUEST_CODE_PERMISSION);\n    }\n}\n\n/**\n * 请求运行时权限\n *\n * @param listener\n * @param permissions\n */\nprotected void requestPermission(PermissionResultListener listener, String... permissions) {\n    permissionResultListener = listener;\n    requestPermission(permissions);\n}\n\n@Override\npublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\n    super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n    if (requestCode == REQUEST_CODE_PERMISSION) {//单个权限申请结果\n        if (grantResults.length == 0) return;\n        if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {//权限申请成功\n            if (permissionResultListener != null)\n                permissionResultListener.onSinglePermissionGranted(permissions[0]);\n        } else {//权限申请失败\n            if (!ActivityCompat.shouldShowRequestPermissionRationale(this, permissions[0])) {//已点不再询问\n                showSnackbar(&quot;权限已被禁止,并不再询问,请在设置中打开&quot;, Snackbar.LENGTH_LONG);\n                AlertDialog.Builder builder = new AlertDialog.Builder(this);\n                builder.setMessage(&quot;是否打开应用设置页面?&quot;).setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int which) {\n                        getAppDetailSettingIntent();\n                    }\n                }).setNegativeButton(&quot;取消&quot;, null).create().show();\n            } else {//再次询问?\n                if (permissionResultListener != null)\n                    permissionResultListener.onSinglePermissionDenied(permissions[0]);\n            }\n        }\n    }\n    if (requestCode == REQUEST_CODE_PERMISSIONS) {//多个权限申请结果\n        if (grantResults.length == 0) return;\n        List&lt;String&gt; deniedPermissions = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; permissions.length; i++) {\n            if (grantResults[i] != PackageManager.PERMISSION_GRANTED) {\n                deniedPermissions.add(permissions[i]);\n            }\n        }\n        if (deniedPermissions.size() != 0) {//有权限未允许\n            if (permissionResultListener != null)\n                permissionResultListener.onPermissionsDenied(deniedPermissions);\n        } else {//权限已被完全允许\n            if (permissionResultListener != null)\n                permissionResultListener.onPermissionsGrantedAll();\n        }\n    }\n}\n\nPermissionResultListener permissionResultListener;\n\ninterface PermissionResultListener {\n    void onSinglePermissionDenied(String permission);\n\n    void onSinglePermissionGranted(String permission);\n\n    void onPermissionsGrantedAll();\n\n    void onPermissionsDenied(List&lt;String&gt; deniedPermissions);\n\n}\n\n\n/**\n * 打开应用设置界面\n */\nprivate void getAppDetailSettingIntent() {\n    Intent localIntent = new Intent();\n    localIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n    if (Build.VERSION.SDK_INT &gt;= 9) {\n        localIntent.setAction(&quot;android.settings.APPLICATION_DETAILS_SETTINGS&quot;);\n        localIntent.setData(Uri.fromParts(&quot;package&quot;, getPackageName(), null));\n    } else if (Build.VERSION.SDK_INT &lt;= 8) {\n        localIntent.setAction(Intent.ACTION_VIEW);\n        localIntent.setClassName(&quot;com.android.settings&quot;, &quot;com.android.settings.InstalledAppDetails&quot;);\n        localIntent.putExtra(&quot;com.android.settings.ApplicationPkgName&quot;, getPackageName());\n    }\n    startActivity(localIntent);\n}\n\n@Override\nprotected void onDestroy() {\n    super.onDestroy();\n\n    //...其他操作\n\n}\n</code></pre><h4 id=\"3-特殊权限\"><a href=\"#3-特殊权限\" class=\"headerlink\" title=\"3. 特殊权限\"></a>3. 特殊权限</h4><ul>\n<li><p>SYSTEM_ ALERT_ WINDOW</p>\n<p>  在 android api 23以上需要判断是否可以在其他应用上层显示弹框,需要手动申请跳转界面</p>\n<pre><code>//判断是否可以上层显示并跳转\n if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M&amp;&amp; !Settings.canDrawOverlays(this)) {\n    Intent intent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION,\n            Uri.parse(&quot;package:&quot; + getPackageName()));\n    startActivityForResult(intent,10);\n}\n</code></pre></li>\n</ul>\n<ul>\n<li>WRITE_ SETTINGS</li>\n</ul>\n<h3 id=\"权限处理\"><a href=\"#权限处理\" class=\"headerlink\" title=\"权限处理\"></a>权限处理</h3><h4 id=\"android-6-0\"><a href=\"#android-6-0\" class=\"headerlink\" title=\"android 6.0\"></a>android 6.0</h4><h4 id=\"android-7-0\"><a href=\"#android-7-0\" class=\"headerlink\" title=\"android 7.0\"></a>android 7.0</h4><h4 id=\"android-8-0\"><a href=\"#android-8-0\" class=\"headerlink\" title=\"android 8.0\"></a>android 8.0</h4><h3 id=\"权限的授权\"><a href=\"#权限的授权\" class=\"headerlink\" title=\"权限的授权\"></a>权限的授权</h3><h3 id=\"其他权限\"><a href=\"#其他权限\" class=\"headerlink\" title=\"其他权限\"></a>其他权限</h3>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Android权限的了解和处理\"><a href=\"#Android权限的了解和处理\" class=\"headerlink\" title=\"Android权限的了解和处理\"></a>Android权限的了解和处理</h1><hr>\n<pre><code>目录:\n    1. 权限的了解\n\n        - 危险权限\n        - 危险权限自定义申请断后\n\n    2. 权限处理\n\n        1. android 6.0\n        2. android 7.0\n        3. android 8.0\n\n    3. 权限的授权\n    4. 其他权限\n</code></pre><hr>\n<h3 id=\"权限的了解\"><a href=\"#权限的了解\" class=\"headerlink\" title=\"权限的了解\"></a>权限的了解</h3><ul>\n<li>注意:<ul>\n<li>Android 6.0 之前的权限机制是<strong>安装时永久性授权</strong>;</li>\n<li>并不是所有的权限都需要运行时申请才能使用;</li>\n<li>危险权限在授予一个权限组的权限之后,组内所有的权限都被授权;</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-危险权限\"><a href=\"#1-危险权限\" class=\"headerlink\" title=\"1. 危险权限\"></a>1. 危险权限</h4><p>危险权限包含以下权限组:</p>\n<pre><code>- 日历\n    - READ_CALENDAR\n    - WRITE_CALENDAR\n- 相机\n    - CAMERA\n- 联系人\n    - READ_CONTACTS\n    - WRITE_CONTACTS\n    - GET_ACCOUNTS\n- 定位\n    - ACCESS_FINE_LOCATION\n    - ACCESS_COARSE_LOCATION\n- 麦克风\n    - RECORD_AUDIO\n- 电话\n    - READ_PHONE_STATE\n    - CALL_PHONE\n    - READ_CALL_LOG\n    - WRITE_CALL_LOG\n    - ADD_VOICEMAIL\n    - USE_SIP\n    - PROCESS_OUTGOING_CALLS\n- 传感器\n    - BODY_SENSORS\n- 短信\n    - SEND_SMS\n    - RECEIVE_SMS\n    - READ_SMS\n    - RECEIVE_WAP_PUSH\n    - RECEIVE_MMS\n- 存储\n    - READ_EXTERNAL_STORAGE\n    - WRITE_EXTERNAL_STORAGE\n</code></pre><ol>\n<li><p>检测权限是否为允许:<strong>返回值为0时为已允许,1时为拒绝或未申请</strong>;</p>\n<pre><code>- Activity#checkSelfPermission(permission)\n- PackageManager#checkPermission(permission, getPackageName()))\n</code></pre></li>\n<li><p>申请权限</p>\n<pre><code>- Activity#requestPermissions(permissions, requestCode);\n- ActivityCompat.requestPermissions(this, permissions, requestCode);\n</code></pre></li>\n<li><p>权限请求结果返回</p>\n<pre><code>- Activity#onRequestPermissionsResult(int requestCode,\n     @NonNull String[] permissions,\n     @NonNull int[] grantResults) \n</code></pre></li>\n</ol>\n<ol>\n<li>权限说明:只有当用户拒绝时没有选中”不在提示”时才会返回true;</li>\n</ol>\n<pre><code>- Activity#shouldShowRequestPermissionRationale(@NonNull String permission)\n- ActivityCompat.shouldShowRequestPermissionRationale(this, permissions[0])\n</code></pre><h4 id=\"2-危险权限自定义申请断后\"><a href=\"#2-危险权限自定义申请断后\" class=\"headerlink\" title=\"2. 危险权限自定义申请断后\"></a>2. 危险权限自定义申请断后</h4><pre><code>String[] dangerousPermissions = {\n        Manifest.permission.WRITE_EXTERNAL_STORAGE//读写权限0\n        , Manifest.permission.CAMERA//相机权限1\n        , Manifest.permission.WRITE_CONTACTS//写入联系人2\n        , Manifest.permission.CALL_PHONE//打电话3\n        , Manifest.permission.SEND_SMS//发送短信4\n        , Manifest.permission.RECORD_AUDIO//麦克风打开5\n        , Manifest.permission.ACCESS_FINE_LOCATION//定位相关6\n        , Manifest.permission.BODY_SENSORS//传感器 7  最小使用SDK 20\n        , Manifest.permission.WRITE_CALENDAR//日历写入8\n};\n\n void requestPermission(String... permissions) {\n    if (permissions.length &gt; 1) {\n        ActivityCompat.requestPermissions(this, permissions, REQUEST_CODE_PERMISSIONS);\n    } else {\n        ActivityCompat.requestPermissions(this, permissions, REQUEST_CODE_PERMISSION);\n    }\n}\n\n/**\n * 请求运行时权限\n *\n * @param listener\n * @param permissions\n */\nprotected void requestPermission(PermissionResultListener listener, String... permissions) {\n    permissionResultListener = listener;\n    requestPermission(permissions);\n}\n\n@Override\npublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\n    super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n    if (requestCode == REQUEST_CODE_PERMISSION) {//单个权限申请结果\n        if (grantResults.length == 0) return;\n        if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {//权限申请成功\n            if (permissionResultListener != null)\n                permissionResultListener.onSinglePermissionGranted(permissions[0]);\n        } else {//权限申请失败\n            if (!ActivityCompat.shouldShowRequestPermissionRationale(this, permissions[0])) {//已点不再询问\n                showSnackbar(&quot;权限已被禁止,并不再询问,请在设置中打开&quot;, Snackbar.LENGTH_LONG);\n                AlertDialog.Builder builder = new AlertDialog.Builder(this);\n                builder.setMessage(&quot;是否打开应用设置页面?&quot;).setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int which) {\n                        getAppDetailSettingIntent();\n                    }\n                }).setNegativeButton(&quot;取消&quot;, null).create().show();\n            } else {//再次询问?\n                if (permissionResultListener != null)\n                    permissionResultListener.onSinglePermissionDenied(permissions[0]);\n            }\n        }\n    }\n    if (requestCode == REQUEST_CODE_PERMISSIONS) {//多个权限申请结果\n        if (grantResults.length == 0) return;\n        List&lt;String&gt; deniedPermissions = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; permissions.length; i++) {\n            if (grantResults[i] != PackageManager.PERMISSION_GRANTED) {\n                deniedPermissions.add(permissions[i]);\n            }\n        }\n        if (deniedPermissions.size() != 0) {//有权限未允许\n            if (permissionResultListener != null)\n                permissionResultListener.onPermissionsDenied(deniedPermissions);\n        } else {//权限已被完全允许\n            if (permissionResultListener != null)\n                permissionResultListener.onPermissionsGrantedAll();\n        }\n    }\n}\n\nPermissionResultListener permissionResultListener;\n\ninterface PermissionResultListener {\n    void onSinglePermissionDenied(String permission);\n\n    void onSinglePermissionGranted(String permission);\n\n    void onPermissionsGrantedAll();\n\n    void onPermissionsDenied(List&lt;String&gt; deniedPermissions);\n\n}\n\n\n/**\n * 打开应用设置界面\n */\nprivate void getAppDetailSettingIntent() {\n    Intent localIntent = new Intent();\n    localIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n    if (Build.VERSION.SDK_INT &gt;= 9) {\n        localIntent.setAction(&quot;android.settings.APPLICATION_DETAILS_SETTINGS&quot;);\n        localIntent.setData(Uri.fromParts(&quot;package&quot;, getPackageName(), null));\n    } else if (Build.VERSION.SDK_INT &lt;= 8) {\n        localIntent.setAction(Intent.ACTION_VIEW);\n        localIntent.setClassName(&quot;com.android.settings&quot;, &quot;com.android.settings.InstalledAppDetails&quot;);\n        localIntent.putExtra(&quot;com.android.settings.ApplicationPkgName&quot;, getPackageName());\n    }\n    startActivity(localIntent);\n}\n\n@Override\nprotected void onDestroy() {\n    super.onDestroy();\n\n    //...其他操作\n\n}\n</code></pre><h4 id=\"3-特殊权限\"><a href=\"#3-特殊权限\" class=\"headerlink\" title=\"3. 特殊权限\"></a>3. 特殊权限</h4><ul>\n<li><p>SYSTEM_ ALERT_ WINDOW</p>\n<p>  在 android api 23以上需要判断是否可以在其他应用上层显示弹框,需要手动申请跳转界面</p>\n<pre><code>//判断是否可以上层显示并跳转\n if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M&amp;&amp; !Settings.canDrawOverlays(this)) {\n    Intent intent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION,\n            Uri.parse(&quot;package:&quot; + getPackageName()));\n    startActivityForResult(intent,10);\n}\n</code></pre></li>\n</ul>\n<ul>\n<li>WRITE_ SETTINGS</li>\n</ul>\n<h3 id=\"权限处理\"><a href=\"#权限处理\" class=\"headerlink\" title=\"权限处理\"></a>权限处理</h3><h4 id=\"android-6-0\"><a href=\"#android-6-0\" class=\"headerlink\" title=\"android 6.0\"></a>android 6.0</h4><h4 id=\"android-7-0\"><a href=\"#android-7-0\" class=\"headerlink\" title=\"android 7.0\"></a>android 7.0</h4><h4 id=\"android-8-0\"><a href=\"#android-8-0\" class=\"headerlink\" title=\"android 8.0\"></a>android 8.0</h4><h3 id=\"权限的授权\"><a href=\"#权限的授权\" class=\"headerlink\" title=\"权限的授权\"></a>权限的授权</h3><h3 id=\"其他权限\"><a href=\"#其他权限\" class=\"headerlink\" title=\"其他权限\"></a>其他权限</h3>"},{"_content":"# 框架源码原理分析 #\n\n\n### `Multidex` ###\n\n\n---\n### `Glide` ###\n- 参考:\n\t- [ ** 一篇文章带你完全掌握Glide图片加载框架 ** ](http://mp.weixin.qq.com/s/SoqLK7eoJYT15sSDorpr9g)\n\t- [ ** 带你全面了解Glide 4的用法 ** ](http://mp.weixin.qq.com/s/p5mIA6nuVEWZsWPHOCHcYw)\n\t- [ **实战，实现带进度的Glide图片加载功能 ** ](http://mp.weixin.qq.com/s/ANc7ZJRe7UjpD0v8ioz0yA)\n\t- [ ** 来学习一下Glide强大的图片变换功能吧 ** ](http://mp.weixin.qq.com/s/M12AzUNSeLq202GV5h_4PQ)\n\t- [ ** Android图片加载框架最全解析（二），从源码的角度理解Glide的执行流程 ** ](http://blog.csdn.net/guolin_blog/article/details/53939176)\n\t\n---\n### `Gson` ###\n- 参考:\n\t- [ **推酷 - Gson源码设计学习** ](https://www.tuicool.com/articles/bAn6zu7)\n\t- [ **掘金 - Gson 源码解析** ](https://juejin.im/entry/59376ff9a22b9d00580d3d7d)\n\t- [ **CSDN - Google官方Gson解析** ](http://blog.csdn.net/Jsagacity/article/details/78123410)\n\n- `json to JavaBean`\n\n![1](https://upload-images.jianshu.io/upload_images/6193428-e97afe8385100aeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- `JavaBean to json`\t\n\n\n---\n### `Retrofit & OkHttp` ###\n- 参考:\n\t- [ **retrofit源码分析 ** ](http://blog.csdn.net/qq_24675479/article/details/79493948)\n\n\n\n- retrofit网络通信八步\n\t1. 创建retrofit实例\n\t2. 定义一个网络请求接口中的方法添加注解\n\t3. 通过动态代理生成网络请求对象\n\t4. 通过网络请求适配器将网络请求对象进行平台适配(android ,java,IOS)\n\t5. 通过网络请求执行器 发起网络请求\n\t6. 通过数据转换器 解析数据\n\t7. 通过回调执行器，切换主线程\n\t8. 用户在主线程处理结果\n\n---\n### `Rxjava` ###\n- 参考:\n\t- [ ** ** ]()\n\t- [ ** ** ]()\n\t- [ ** ** ]()\n\n---\n### `EventBus` ###\n- 参考:\n\t- [ ** ** ]()\n\t- [ ** ** ]()\n\t- [ ** ** ]()\n\n---\n### 热更新`bugly / tinker` ###\n- 参考:\n\t- [ **Android热更新实现原理** ](http://blog.csdn.net/lzyzsd/article/details/49843581/)\n\t- [ ** ** ]()\n\t- [ ** ** ]()\n\njava运行时加载的类是通过ClassLoader来实现的,Android中使用PathClassLoader类作为Android的默认的类加载器， `PathClassLoader`其实实现的就是简单的从文件系统中加载类文件。BaseDexClassLoader将findClass方法委托给了pathList对象的findClass方法，pathList对象是在BaseDexClassLoader的构造函数中new出来的， 它的类型是`DexPathList`。\n\n**一旦有类被成功加载，那么它的dex一定会出现在dexElements所对应的dex文件中**，并且dexElements中出现的顺序也很重要，在dexElements前面出现的dex会被优先加载，一旦Class被加载成功，就会立即返回，也就是说，**如果想做hotpatch，一定要保证我们的hotpacth dex文件出现在dexElements列表的前面。**\n\n\n由于PathClassLoader.pathList.dexElements是private,就需要**反射**来修改。\n构造我们自己的dex文件所对应的dexElements数组的时候，我们也可以采取一个比较取巧的方式，就是通过构造一个DexClassLoader对象来加载我们的dex文件，并且调用一次`dexClassLoader.loadClass(dummyClassName)`; \n方法，这样，`dexClassLoader.pathList.dexElements`中，就会包含我们的dex，**通过把`dexClassLoader.pathList.dexElements`插入到系统默认的`classLoader.pathList.dexElements`列表前面，就可以让系统优先加载我们的dex中的类**，从而可以实现热更新了。\n\n---","source":"_posts/Android之源码——框架源码分析.md","raw":"# 框架源码原理分析 #\n\n\n### `Multidex` ###\n\n\n---\n### `Glide` ###\n- 参考:\n\t- [ ** 一篇文章带你完全掌握Glide图片加载框架 ** ](http://mp.weixin.qq.com/s/SoqLK7eoJYT15sSDorpr9g)\n\t- [ ** 带你全面了解Glide 4的用法 ** ](http://mp.weixin.qq.com/s/p5mIA6nuVEWZsWPHOCHcYw)\n\t- [ **实战，实现带进度的Glide图片加载功能 ** ](http://mp.weixin.qq.com/s/ANc7ZJRe7UjpD0v8ioz0yA)\n\t- [ ** 来学习一下Glide强大的图片变换功能吧 ** ](http://mp.weixin.qq.com/s/M12AzUNSeLq202GV5h_4PQ)\n\t- [ ** Android图片加载框架最全解析（二），从源码的角度理解Glide的执行流程 ** ](http://blog.csdn.net/guolin_blog/article/details/53939176)\n\t\n---\n### `Gson` ###\n- 参考:\n\t- [ **推酷 - Gson源码设计学习** ](https://www.tuicool.com/articles/bAn6zu7)\n\t- [ **掘金 - Gson 源码解析** ](https://juejin.im/entry/59376ff9a22b9d00580d3d7d)\n\t- [ **CSDN - Google官方Gson解析** ](http://blog.csdn.net/Jsagacity/article/details/78123410)\n\n- `json to JavaBean`\n\n![1](https://upload-images.jianshu.io/upload_images/6193428-e97afe8385100aeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- `JavaBean to json`\t\n\n\n---\n### `Retrofit & OkHttp` ###\n- 参考:\n\t- [ **retrofit源码分析 ** ](http://blog.csdn.net/qq_24675479/article/details/79493948)\n\n\n\n- retrofit网络通信八步\n\t1. 创建retrofit实例\n\t2. 定义一个网络请求接口中的方法添加注解\n\t3. 通过动态代理生成网络请求对象\n\t4. 通过网络请求适配器将网络请求对象进行平台适配(android ,java,IOS)\n\t5. 通过网络请求执行器 发起网络请求\n\t6. 通过数据转换器 解析数据\n\t7. 通过回调执行器，切换主线程\n\t8. 用户在主线程处理结果\n\n---\n### `Rxjava` ###\n- 参考:\n\t- [ ** ** ]()\n\t- [ ** ** ]()\n\t- [ ** ** ]()\n\n---\n### `EventBus` ###\n- 参考:\n\t- [ ** ** ]()\n\t- [ ** ** ]()\n\t- [ ** ** ]()\n\n---\n### 热更新`bugly / tinker` ###\n- 参考:\n\t- [ **Android热更新实现原理** ](http://blog.csdn.net/lzyzsd/article/details/49843581/)\n\t- [ ** ** ]()\n\t- [ ** ** ]()\n\njava运行时加载的类是通过ClassLoader来实现的,Android中使用PathClassLoader类作为Android的默认的类加载器， `PathClassLoader`其实实现的就是简单的从文件系统中加载类文件。BaseDexClassLoader将findClass方法委托给了pathList对象的findClass方法，pathList对象是在BaseDexClassLoader的构造函数中new出来的， 它的类型是`DexPathList`。\n\n**一旦有类被成功加载，那么它的dex一定会出现在dexElements所对应的dex文件中**，并且dexElements中出现的顺序也很重要，在dexElements前面出现的dex会被优先加载，一旦Class被加载成功，就会立即返回，也就是说，**如果想做hotpatch，一定要保证我们的hotpacth dex文件出现在dexElements列表的前面。**\n\n\n由于PathClassLoader.pathList.dexElements是private,就需要**反射**来修改。\n构造我们自己的dex文件所对应的dexElements数组的时候，我们也可以采取一个比较取巧的方式，就是通过构造一个DexClassLoader对象来加载我们的dex文件，并且调用一次`dexClassLoader.loadClass(dummyClassName)`; \n方法，这样，`dexClassLoader.pathList.dexElements`中，就会包含我们的dex，**通过把`dexClassLoader.pathList.dexElements`插入到系统默认的`classLoader.pathList.dexElements`列表前面，就可以让系统优先加载我们的dex中的类**，从而可以实现热更新了。\n\n---","slug":"Android之源码——框架源码分析","published":1,"date":"2018-03-21T03:22:18.433Z","updated":"2018-03-15T02:44:27.502Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0kjqjb000g0s4lz2varbcv","content":"<h1 id=\"框架源码原理分析\"><a href=\"#框架源码原理分析\" class=\"headerlink\" title=\"框架源码原理分析\"></a>框架源码原理分析</h1><h3 id=\"Multidex\"><a href=\"#Multidex\" class=\"headerlink\" title=\"Multidex\"></a><code>Multidex</code></h3><hr>\n<h3 id=\"Glide\"><a href=\"#Glide\" class=\"headerlink\" title=\"Glide\"></a><code>Glide</code></h3><ul>\n<li>参考:<ul>\n<li><a href=\"http://mp.weixin.qq.com/s/SoqLK7eoJYT15sSDorpr9g\" target=\"_blank\" rel=\"noopener\"> <strong> 一篇文章带你完全掌握Glide图片加载框架 </strong> </a></li>\n<li><a href=\"http://mp.weixin.qq.com/s/p5mIA6nuVEWZsWPHOCHcYw\" target=\"_blank\" rel=\"noopener\"> <strong> 带你全面了解Glide 4的用法 </strong> </a></li>\n<li><a href=\"http://mp.weixin.qq.com/s/ANc7ZJRe7UjpD0v8ioz0yA\" target=\"_blank\" rel=\"noopener\"> <strong>实战，实现带进度的Glide图片加载功能 </strong> </a></li>\n<li><a href=\"http://mp.weixin.qq.com/s/M12AzUNSeLq202GV5h_4PQ\" target=\"_blank\" rel=\"noopener\"> <strong> 来学习一下Glide强大的图片变换功能吧 </strong> </a></li>\n<li><a href=\"http://blog.csdn.net/guolin_blog/article/details/53939176\" target=\"_blank\" rel=\"noopener\"> <strong> Android图片加载框架最全解析（二），从源码的角度理解Glide的执行流程 </strong> </a></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"Gson\"><a href=\"#Gson\" class=\"headerlink\" title=\"Gson\"></a><code>Gson</code></h3><ul>\n<li><p>参考:</p>\n<ul>\n<li><a href=\"https://www.tuicool.com/articles/bAn6zu7\" target=\"_blank\" rel=\"noopener\"> <strong>推酷 - Gson源码设计学习</strong> </a></li>\n<li><a href=\"https://juejin.im/entry/59376ff9a22b9d00580d3d7d\" target=\"_blank\" rel=\"noopener\"> <strong>掘金 - Gson 源码解析</strong> </a></li>\n<li><a href=\"http://blog.csdn.net/Jsagacity/article/details/78123410\" target=\"_blank\" rel=\"noopener\"> <strong>CSDN - Google官方Gson解析</strong> </a></li>\n</ul>\n</li>\n<li><p><code>json to JavaBean</code></p>\n</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6193428-e97afe8385100aeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"1\"></p>\n<ul>\n<li><code>JavaBean to json</code>    </li>\n</ul>\n<hr>\n<h3 id=\"Retrofit-amp-OkHttp\"><a href=\"#Retrofit-amp-OkHttp\" class=\"headerlink\" title=\"Retrofit &amp; OkHttp\"></a><code>Retrofit &amp; OkHttp</code></h3><ul>\n<li>参考:<ul>\n<li><a href=\"http://blog.csdn.net/qq_24675479/article/details/79493948\" target=\"_blank\" rel=\"noopener\"> <strong>retrofit源码分析 </strong> </a></li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>retrofit网络通信八步<ol>\n<li>创建retrofit实例</li>\n<li>定义一个网络请求接口中的方法添加注解</li>\n<li>通过动态代理生成网络请求对象</li>\n<li>通过网络请求适配器将网络请求对象进行平台适配(android ,java,IOS)</li>\n<li>通过网络请求执行器 发起网络请求</li>\n<li>通过数据转换器 解析数据</li>\n<li>通过回调执行器，切换主线程</li>\n<li>用户在主线程处理结果</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h3 id=\"Rxjava\"><a href=\"#Rxjava\" class=\"headerlink\" title=\"Rxjava\"></a><code>Rxjava</code></h3><ul>\n<li>参考:<ul>\n<li><a href=\"\"> <strong> </strong> </a></li>\n<li><a href=\"\"> <strong> </strong> </a></li>\n<li><a href=\"\"> <strong> </strong> </a></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"EventBus\"><a href=\"#EventBus\" class=\"headerlink\" title=\"EventBus\"></a><code>EventBus</code></h3><ul>\n<li>参考:<ul>\n<li><a href=\"\"> <strong> </strong> </a></li>\n<li><a href=\"\"> <strong> </strong> </a></li>\n<li><a href=\"\"> <strong> </strong> </a></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"热更新bugly-tinker\"><a href=\"#热更新bugly-tinker\" class=\"headerlink\" title=\"热更新bugly / tinker\"></a>热更新<code>bugly / tinker</code></h3><ul>\n<li>参考:<ul>\n<li><a href=\"http://blog.csdn.net/lzyzsd/article/details/49843581/\" target=\"_blank\" rel=\"noopener\"> <strong>Android热更新实现原理</strong> </a></li>\n<li><a href=\"\"> <strong> </strong> </a></li>\n<li><a href=\"\"> <strong> </strong> </a></li>\n</ul>\n</li>\n</ul>\n<p>java运行时加载的类是通过ClassLoader来实现的,Android中使用PathClassLoader类作为Android的默认的类加载器， <code>PathClassLoader</code>其实实现的就是简单的从文件系统中加载类文件。BaseDexClassLoader将findClass方法委托给了pathList对象的findClass方法，pathList对象是在BaseDexClassLoader的构造函数中new出来的， 它的类型是<code>DexPathList</code>。</p>\n<p><strong>一旦有类被成功加载，那么它的dex一定会出现在dexElements所对应的dex文件中</strong>，并且dexElements中出现的顺序也很重要，在dexElements前面出现的dex会被优先加载，一旦Class被加载成功，就会立即返回，也就是说，<strong>如果想做hotpatch，一定要保证我们的hotpacth dex文件出现在dexElements列表的前面。</strong></p>\n<p>由于PathClassLoader.pathList.dexElements是private,就需要<strong>反射</strong>来修改。<br>构造我们自己的dex文件所对应的dexElements数组的时候，我们也可以采取一个比较取巧的方式，就是通过构造一个DexClassLoader对象来加载我们的dex文件，并且调用一次<code>dexClassLoader.loadClass(dummyClassName)</code>;<br>方法，这样，<code>dexClassLoader.pathList.dexElements</code>中，就会包含我们的dex，<strong>通过把<code>dexClassLoader.pathList.dexElements</code>插入到系统默认的<code>classLoader.pathList.dexElements</code>列表前面，就可以让系统优先加载我们的dex中的类</strong>，从而可以实现热更新了。</p>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"框架源码原理分析\"><a href=\"#框架源码原理分析\" class=\"headerlink\" title=\"框架源码原理分析\"></a>框架源码原理分析</h1><h3 id=\"Multidex\"><a href=\"#Multidex\" class=\"headerlink\" title=\"Multidex\"></a><code>Multidex</code></h3><hr>\n<h3 id=\"Glide\"><a href=\"#Glide\" class=\"headerlink\" title=\"Glide\"></a><code>Glide</code></h3><ul>\n<li>参考:<ul>\n<li><a href=\"http://mp.weixin.qq.com/s/SoqLK7eoJYT15sSDorpr9g\" target=\"_blank\" rel=\"noopener\"> <strong> 一篇文章带你完全掌握Glide图片加载框架 </strong> </a></li>\n<li><a href=\"http://mp.weixin.qq.com/s/p5mIA6nuVEWZsWPHOCHcYw\" target=\"_blank\" rel=\"noopener\"> <strong> 带你全面了解Glide 4的用法 </strong> </a></li>\n<li><a href=\"http://mp.weixin.qq.com/s/ANc7ZJRe7UjpD0v8ioz0yA\" target=\"_blank\" rel=\"noopener\"> <strong>实战，实现带进度的Glide图片加载功能 </strong> </a></li>\n<li><a href=\"http://mp.weixin.qq.com/s/M12AzUNSeLq202GV5h_4PQ\" target=\"_blank\" rel=\"noopener\"> <strong> 来学习一下Glide强大的图片变换功能吧 </strong> </a></li>\n<li><a href=\"http://blog.csdn.net/guolin_blog/article/details/53939176\" target=\"_blank\" rel=\"noopener\"> <strong> Android图片加载框架最全解析（二），从源码的角度理解Glide的执行流程 </strong> </a></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"Gson\"><a href=\"#Gson\" class=\"headerlink\" title=\"Gson\"></a><code>Gson</code></h3><ul>\n<li><p>参考:</p>\n<ul>\n<li><a href=\"https://www.tuicool.com/articles/bAn6zu7\" target=\"_blank\" rel=\"noopener\"> <strong>推酷 - Gson源码设计学习</strong> </a></li>\n<li><a href=\"https://juejin.im/entry/59376ff9a22b9d00580d3d7d\" target=\"_blank\" rel=\"noopener\"> <strong>掘金 - Gson 源码解析</strong> </a></li>\n<li><a href=\"http://blog.csdn.net/Jsagacity/article/details/78123410\" target=\"_blank\" rel=\"noopener\"> <strong>CSDN - Google官方Gson解析</strong> </a></li>\n</ul>\n</li>\n<li><p><code>json to JavaBean</code></p>\n</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6193428-e97afe8385100aeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"1\"></p>\n<ul>\n<li><code>JavaBean to json</code>    </li>\n</ul>\n<hr>\n<h3 id=\"Retrofit-amp-OkHttp\"><a href=\"#Retrofit-amp-OkHttp\" class=\"headerlink\" title=\"Retrofit &amp; OkHttp\"></a><code>Retrofit &amp; OkHttp</code></h3><ul>\n<li>参考:<ul>\n<li><a href=\"http://blog.csdn.net/qq_24675479/article/details/79493948\" target=\"_blank\" rel=\"noopener\"> <strong>retrofit源码分析 </strong> </a></li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>retrofit网络通信八步<ol>\n<li>创建retrofit实例</li>\n<li>定义一个网络请求接口中的方法添加注解</li>\n<li>通过动态代理生成网络请求对象</li>\n<li>通过网络请求适配器将网络请求对象进行平台适配(android ,java,IOS)</li>\n<li>通过网络请求执行器 发起网络请求</li>\n<li>通过数据转换器 解析数据</li>\n<li>通过回调执行器，切换主线程</li>\n<li>用户在主线程处理结果</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h3 id=\"Rxjava\"><a href=\"#Rxjava\" class=\"headerlink\" title=\"Rxjava\"></a><code>Rxjava</code></h3><ul>\n<li>参考:<ul>\n<li><a href=\"\"> <strong> </strong> </a></li>\n<li><a href=\"\"> <strong> </strong> </a></li>\n<li><a href=\"\"> <strong> </strong> </a></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"EventBus\"><a href=\"#EventBus\" class=\"headerlink\" title=\"EventBus\"></a><code>EventBus</code></h3><ul>\n<li>参考:<ul>\n<li><a href=\"\"> <strong> </strong> </a></li>\n<li><a href=\"\"> <strong> </strong> </a></li>\n<li><a href=\"\"> <strong> </strong> </a></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"热更新bugly-tinker\"><a href=\"#热更新bugly-tinker\" class=\"headerlink\" title=\"热更新bugly / tinker\"></a>热更新<code>bugly / tinker</code></h3><ul>\n<li>参考:<ul>\n<li><a href=\"http://blog.csdn.net/lzyzsd/article/details/49843581/\" target=\"_blank\" rel=\"noopener\"> <strong>Android热更新实现原理</strong> </a></li>\n<li><a href=\"\"> <strong> </strong> </a></li>\n<li><a href=\"\"> <strong> </strong> </a></li>\n</ul>\n</li>\n</ul>\n<p>java运行时加载的类是通过ClassLoader来实现的,Android中使用PathClassLoader类作为Android的默认的类加载器， <code>PathClassLoader</code>其实实现的就是简单的从文件系统中加载类文件。BaseDexClassLoader将findClass方法委托给了pathList对象的findClass方法，pathList对象是在BaseDexClassLoader的构造函数中new出来的， 它的类型是<code>DexPathList</code>。</p>\n<p><strong>一旦有类被成功加载，那么它的dex一定会出现在dexElements所对应的dex文件中</strong>，并且dexElements中出现的顺序也很重要，在dexElements前面出现的dex会被优先加载，一旦Class被加载成功，就会立即返回，也就是说，<strong>如果想做hotpatch，一定要保证我们的hotpacth dex文件出现在dexElements列表的前面。</strong></p>\n<p>由于PathClassLoader.pathList.dexElements是private,就需要<strong>反射</strong>来修改。<br>构造我们自己的dex文件所对应的dexElements数组的时候，我们也可以采取一个比较取巧的方式，就是通过构造一个DexClassLoader对象来加载我们的dex文件，并且调用一次<code>dexClassLoader.loadClass(dummyClassName)</code>;<br>方法，这样，<code>dexClassLoader.pathList.dexElements</code>中，就会包含我们的dex，<strong>通过把<code>dexClassLoader.pathList.dexElements</code>插入到系统默认的<code>classLoader.pathList.dexElements</code>列表前面，就可以让系统优先加载我们的dex中的类</strong>，从而可以实现热更新了。</p>\n<hr>\n"},{"目录":"1. 图片文字绘制 2. 零散内容绘制和画布调整","_content":"## Canvas图片文字绘制\n\n    概要:\n        1. 绘制图片\n        2. 绘制文字\n\n### 1. 绘制图片\n\n#### -   矢量(drawPicture)\n警告:需要关闭硬件加速.\n\n- 矢量图绘制就是记录Canvas绘制的内容. \n- Picture的相关函数\n\n        - getWidth\\height():得到宽高\n        - beginRecording(int width,int height):开始录制,return Canvas;\n        - endRecording():结束录制;\n        - draw(Canvas canvas):绘制矢量图;\n    \n- 矢量图的绘制有以下三种方式:\n    1. mPic.draw(canvas);\n\n        - 低版本**影响canvas的状态**,一般不使用;\n\n    2. canvas.drawPicture(mPic);\n        - **不影响canvas状态,可以设置显示矢量图的区域矩形大小,完全压缩显示.**\n                \n                public void drawPicture (Picture picture)\n                \n                public void drawPicture (Picture picture, Rect dst)\n                \n                public void drawPicture (Picture picture, RectF dst)                \n                \n    3. picture → pictureDrawable → pictureDrawable.draw(canvas),**不会缩放,按显示区域大小显示一部分**;\n\n            // 包装成为Drawable\n            PictureDrawable drawable = new PictureDrawable(mPicture);\n            // 设置绘制区域 -- 注意此处所绘制的实际内容不会缩放\n            drawable.setBounds(0,0,250,mPicture.getHeight());\n            // 绘制\n            drawable.draw(canvas);\n            \n\n#### -   位图(drawBitmap)\n可能会消耗大量的内存,或者会造成内存泄露;\n首先获得bitmap,然后进行绘制.\n\n1. 获取\n    1. 资源文件(drawable/mipmap/raw):\n            \n            Bitmap bitmap = BitmapFactory.decodeResource\n            (mContext.getResources(),R.raw.bitmap);\n    2. 资源文件(assets):\n    \n            Bitmap bitmap=null;\n            try {\n                InputStream is = mContext.getAssets()\n                .open(\"bitmap.png\");\n                bitmap = BitmapFactory.decodeStream(is);\n                is.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n    3. 内存卡文件:\n    \n            Bitmap bitmap = BitmapFactory\n                .decodeFile(\"/sdcard/.../bitmap.png\");\n    4. 网络文件:\n    \n            // 此处省略了获取网络输入流的代码\n            Bitmap bitmap = BitmapFactory.decodeStream(is);\n            is.close();\n\n2. 绘制\n    \n        public void drawBitmap \n        1. (Bitmap bitmap, Matrix matrix, Paint paint)\n        2. (Bitmap bitmap, float left, float top, Paint paint)\n        3. (Bitmap bitmap, Rect src, Rect dst, Paint paint)\n        4. (Bitmap bitmap, Rect src, RectF dst, Paint paint)\n\t\n\t    1. 默认绘制起点为原点.\n\t        `canvas.drawBitmap(bitmap,new Matrix(),new Paint());`\n\t    2. 确定一个绘制起点坐标.\n\t    3. 4.指定图片的绘制矩形区域和图片在屏幕上的绘制矩形区域,当前者宽/高度>后者宽/高度的情况下会压缩.\n\n        canvas.translate(mWidth/2,mHeight/2);\n        // 指定图片绘制区域(左上角的四分之一)\n        Rect src = new Rect(0,0,bitmap.getWidth()/2,bitmap.getHeight()/2);\n        // 指定图片在屏幕上显示的区域\n        Rect dst = new Rect(0,0,200,400);\n        // 绘制图片\n        canvas.drawBitmap(bitmap,src,dst,null);\n\n    \t4. 注:可以控制两个区域的大小来完成某个动画.\n\n### 2. 绘制文字\n    \n    画笔Paint文本相关函数:\n    色彩\tsetColor,setARGB,setAlpha  设置颜色，透明度\n    大小\tsetTextSize\t               设置文本字体大小\n    字体\tsetTypeface\t               设置或清除字体样式\n    样式\tsetStyle\t               填充描边等\n    对齐\tsetTextAlign\t           左,居中,右\n    测量\tmeasureText\t               测量文本大小\n    \n    (注意:measureText()在设置完文本各项参数后调用)\n   \n1. 指定文本基线位置(x,y)\n\n\n        public void drawText \n        (String text, float x, float y, Paint paint)\n        (String text, int start, int end, float x, float y, Paint paint)\n        (CharSequence text, int start, int end, float x, float y, Paint paint)\n        (char[] text, int index, int count, float x, float y, Paint paint)\n\n\n    * 截取的字符串的index∈[start,end),index从0开始,\n    * count指截取的char字符数;\n    \n2. 指定每个文字的位置(不建议使用)\n\n        public void drawPosText \n        (String text, float[] pos, Paint paint)\n        (char[] text, int index, int count, float[] pos, Paint paint)\n        \n    * 例:\n        \n            canvas.drawPosText(str,new float[]{\n                  100,100,    // 第一个字符位置\n                  200,200,    // 第二个字符位置\n                  300,300,    // ...\n                  400,400,\n                  500,500},\n            textPaint);\n    \n    * 缺点:\n        1. 必须指定所有字符位置，否则直接crash掉，反人类设计\n        2. 性能不佳，在大量使用的时候可能导致卡顿\n        3. 不支持emoji等特殊字符，不支持字形组合与分解        \n       \n       \n3. 指定路径来绘制文字\n\n        public void drawTextOnPath \n        (String text, Path path, float hOffset, float vOffset, Paint paint)\n        (char[] text, int index, int count, Path path, float hOffset, float vOffset, Paint paint)\n\n---\n## Canvas内容绘制\n\n\t- 绘制颜色\n\t\t- 主要函数:drawColor, drawRGB, drawARGB\n\t\t- 使用单一颜色填充整个画布\n\t- 绘制基本形状\n\t\t- 主要函数:drawPoint, drawPoints, drawLine, drawLines, drawRect, drawRoundRect, drawOval, drawCircle, drawArc\t\n\t\t- 依次为 点、线、矩形、圆角矩形、椭圆、圆、圆弧\n\t- 绘制图片\n\t\t- 主要函数:drawBitmap, drawPicture\n\t\t- 绘制位图和图片\n\t- 绘制文本\t\n\t\t- drawText, drawPosText, drawTextOnPath\t\n\t\t- 依次为 绘制文字、绘制文字时指定每个文字位置、根据路径绘制文字\n\t- 绘制路径\t\n\t\t- drawPath\t\n\t\t- 绘制路径，绘制贝塞尔曲线时也需要用到该函数\n\t- 顶点操作\t\n\t\t- drawVertices, drawBitmapMesh\t\n\t\t- 通过对顶点操作可以使图像形变，drawVertices直接对画布作用、 drawBitmapMesh只对绘制的Bitmap作用\n\t- 画布剪裁\t\n\t\t- clipPath, clipRect\t\n\t\t- 设置画布的显示区域\n\t- 画布快照\t\n\t\t- save, restore, saveLayerXxx, restoreToCount, getSaveCount\t\n\t\t- 依次为 保存当前状态、回滚到上一次保存的状态、 保存图层状态、 回滚到指定状态、 获取保存次数\n\t- 画布变换\t\n\t\t- translate, scale, rotate, skew\t\n\t\t- 依次为 位移、缩放、 旋转、错切\n\t- Matrix(矩阵)\t\n\t\t- getMatrix, setMatrix, concat\t\n\t\t- 实际上画布的位移，缩放等操作的都是图像矩阵Matrix， 只不过Matrix比较难以理解和使用，故封装了一些常用的方法。\n\n\n### 绘制画布颜色\n\n\tcanvas.drawColor(int color);\n\n#### 绘制一个或者多个坐标点\n\n\tcanvas.drawPoint(200, 200, mPaint);    \n\t //在坐标(200,200)位置绘制一个点\n\tcanvas.drawPoints(new float[]{          \n\t//绘制一组点，坐标位置由float数组指定\n\t      500,500,\n\t      500,600,\n\t      500,700\n\t},mPaint);\n\n### 绘制形状\n\t\n#### 1. 线 ---- 每两个点确定一条线段\n\n\tcanvas.drawLine(300,300,500,600,mPaint);    \n\t// 在坐标(300,300)(500,600)之间绘制一条直线\n\tcanvas.drawLines(new float[]{               \n\t// 绘制一组线 每四数字(两个点的坐标)确定一条线\n\t    100,200,200,200,\n\t    100,300,200,300\n\t},mPaint);\n#### 2. 矩形 ---- 两个对角线确定一个矩形\n\n\t// 第一种\n\tcanvas.drawRect(100,100,800,400,mPaint);\n\t\n\t// 第二种\n\tRect rect = new Rect(100,100,800,400);\n\tcanvas.drawRect(rect,mPaint);\n\t\n\t// 第三种\n\tRectF rectF = new RectF(100,100,800,400);\n\tcanvas.drawRect(rectF,mPaint);\n\n\tRect和RectF的区别在于int 和 float精度,方法也不相同;\n\n#### 3. 圆角矩形 ---- 矩形 + 内切椭圆的两个半径(半径大于矩形一半的宽度按一半来算)\n\n\t// 第一种\n\tRectF rectF = new RectF(100,100,800,400);\n\tcanvas.drawRoundRect(rectF,30,30,mPaint);\n\t\n\t// 第二种\n\tcanvas.drawRoundRect(100,100,800,400,30,30,mPaint);\n\n\n#### 4. 椭圆 ---- 矩形的内切椭圆,只需给定矩形\n\n\t// 第一种\n\tRectF rectF = new RectF(100,100,800,400);\n\tcanvas.drawOval(rectF,mPaint);\n\t\n\t// 第二种\n\tcanvas.drawOval(100,100,800,400,mPaint);\n\n\n#### 5. 圆 ---- 圆心 + 半径\n\n\tcanvas.drawCircle(500,500,400,mPaint);  \n\t// 绘制一个圆心坐标在(500,500)，半径为400 的圆。\n\n#### 6. 圆弧 ---- 矩形内切椭圆 + 开始角度 + 结束角度 + 是否使用中心\n\t// 第一种\n\tpublic void drawArc(@NonNull RectF oval, float startAngle, float sweepAngle, boolean useCenter, @NonNull Paint paint)\n\t    \n\t// 第二种\n\tpublic void drawArc(float left, float top, float right, float bottom, float startAngle,\n\tfloat sweepAngle, boolean useCenter, @NonNull Paint paint)\n\n### Paint\n\n1. 类型setStyle(int style)\n\t1. Paint.Style.STROKE:描边 \n\t2. Paint.Style.FILL:填充\n\t3. Paint.Style.FILL_AND_STROKE:描边+填充\n2. 描边宽度\n\n\t\tpaint.setStrokeWidth(40);\n3. 抗锯齿\n\n\t\tsetAntiAlias(true);\n\n\n### Canvas\n\n\n1. 快照和回滚\n    1. 基础\n\n\t\t快照 : save();\t\t\t//保存画布状态\n\t\t回滚 : restore();\t\t//取出最后一次入栈的图层\n\n\t\tsave就是图层入栈,restore就是图层出栈;\t\n\t\n\t2. 对应的API:\n\t\t\n    \t\tsave()\t\t\t\t把当前的画布的状态进行保存，\n    \t\t或save(saveFlags)\t然后放入特定的栈中\n\n        \t\tALL_SAVE_FLAG\t\t\t\t默认，保存全部状态\n        \t\tCLIP_SAVE_FLAG\t\t\t\t保存剪辑区\n        \t\tCLIP_TO_LAYER_SAVE_FLAG\t\t剪裁区作为图层保存\n        \t\tFULL_COLOR_LAYER_SAVE_FLAG\t保存图层的全部色彩通道\n        \t\tHAS_ALPHA_LAYER_SAVE_FLAG\t保存图层的alpha(不透明度)通道\n        \t\tMATRIX_SAVE_FLAG\t\t\t保存Matrix信息( translate, rotate, scale, skew)\n    \n    \t\tsaveLayerXxx\t\t新建一个图层，并放入特定的栈中\n    \n\t\t\t\tsaveLayerXxx,导致图层叠加造成计算量增倍而过度渲染.\n\n                // 无图层alpha(不透明度)通道\n                public int saveLayer \n                (RectF bounds, Paint paint)\n                (RectF bounds, Paint paint, int saveFlags)\n                (float left, float top, float right, float bottom, Paint paint)\n                (float left, float top, float right, float bottom, Paint paint, int saveFlags)\n                // 有图层alpha(不透明度)通道\n                public int saveLayerAlpha (....,int alpha)\n\n    \t\trestore\t\t\t\t把栈中最顶层的画布状态取出来，\n    \t\t\t\t\t\t\t并按照这个状态恢复当前的画布\n    \n    \t\trestoreToCount\t\t弹出指定位置及其以上所有的状态，\n    \t\t\t\t\t\t\t并按照指定位置的状态进行恢复\n    \n    \t\tgetSaveCount\t\t获取栈中内容的数量(即保存次数)\n\n2. 位移(不断叠加),基于上一次位置的移动.\n\n\t\tcanvas.translate(200,200);\n\t\n3. 旋转(不断叠加),根据**某个中心位置或者原点**旋转**某个角度**;\n\t\t\n\t\tpublic void rotate \n\t\t(float degrees)\n        (float degrees, float px, float py)\n\n4. 缩放(不断叠加),**根据原点位置对x,y方向上的缩放比例,或者根据某个缩放中心的位置控制缩放比例;当缩放比例sx or sy < 0时,会进行翻转相当于中心对称翻转;**\n\n\t\tpublic void scale (float sx, float sy)\n\n\t\tpublic final void scale (float sx, float sy, float px, float py)\n\n\n5. 错切(不断叠加) - skew,**在某个方向上倾斜对应的角度,填入的值为角度对应的tan值.**\n\n\t\tpublic void skew (float sx, float sy)\n\t\t\n\t\t变换之后的值:\n\t\t\tX = x + sx * y\n\t\t\tY = sy * x + y\n\n\n","source":"_posts/Android之自定义控件——Canvas绘制参考.md","raw":"# Canvas 绘制 #\n\n\t目录:\n\t\t1. 图片文字绘制\n\t\t2. 零散内容绘制和画布调整\n\n\n---\n## Canvas图片文字绘制\n\n    概要:\n        1. 绘制图片\n        2. 绘制文字\n\n### 1. 绘制图片\n\n#### -   矢量(drawPicture)\n警告:需要关闭硬件加速.\n\n- 矢量图绘制就是记录Canvas绘制的内容. \n- Picture的相关函数\n\n        - getWidth\\height():得到宽高\n        - beginRecording(int width,int height):开始录制,return Canvas;\n        - endRecording():结束录制;\n        - draw(Canvas canvas):绘制矢量图;\n    \n- 矢量图的绘制有以下三种方式:\n    1. mPic.draw(canvas);\n\n        - 低版本**影响canvas的状态**,一般不使用;\n\n    2. canvas.drawPicture(mPic);\n        - **不影响canvas状态,可以设置显示矢量图的区域矩形大小,完全压缩显示.**\n                \n                public void drawPicture (Picture picture)\n                \n                public void drawPicture (Picture picture, Rect dst)\n                \n                public void drawPicture (Picture picture, RectF dst)                \n                \n    3. picture → pictureDrawable → pictureDrawable.draw(canvas),**不会缩放,按显示区域大小显示一部分**;\n\n            // 包装成为Drawable\n            PictureDrawable drawable = new PictureDrawable(mPicture);\n            // 设置绘制区域 -- 注意此处所绘制的实际内容不会缩放\n            drawable.setBounds(0,0,250,mPicture.getHeight());\n            // 绘制\n            drawable.draw(canvas);\n            \n\n#### -   位图(drawBitmap)\n可能会消耗大量的内存,或者会造成内存泄露;\n首先获得bitmap,然后进行绘制.\n\n1. 获取\n    1. 资源文件(drawable/mipmap/raw):\n            \n            Bitmap bitmap = BitmapFactory.decodeResource\n            (mContext.getResources(),R.raw.bitmap);\n    2. 资源文件(assets):\n    \n            Bitmap bitmap=null;\n            try {\n                InputStream is = mContext.getAssets()\n                .open(\"bitmap.png\");\n                bitmap = BitmapFactory.decodeStream(is);\n                is.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n    3. 内存卡文件:\n    \n            Bitmap bitmap = BitmapFactory\n                .decodeFile(\"/sdcard/.../bitmap.png\");\n    4. 网络文件:\n    \n            // 此处省略了获取网络输入流的代码\n            Bitmap bitmap = BitmapFactory.decodeStream(is);\n            is.close();\n\n2. 绘制\n    \n        public void drawBitmap \n        1. (Bitmap bitmap, Matrix matrix, Paint paint)\n        2. (Bitmap bitmap, float left, float top, Paint paint)\n        3. (Bitmap bitmap, Rect src, Rect dst, Paint paint)\n        4. (Bitmap bitmap, Rect src, RectF dst, Paint paint)\n\t\n\t    1. 默认绘制起点为原点.\n\t        `canvas.drawBitmap(bitmap,new Matrix(),new Paint());`\n\t    2. 确定一个绘制起点坐标.\n\t    3. 4.指定图片的绘制矩形区域和图片在屏幕上的绘制矩形区域,当前者宽/高度>后者宽/高度的情况下会压缩.\n\n        canvas.translate(mWidth/2,mHeight/2);\n        // 指定图片绘制区域(左上角的四分之一)\n        Rect src = new Rect(0,0,bitmap.getWidth()/2,bitmap.getHeight()/2);\n        // 指定图片在屏幕上显示的区域\n        Rect dst = new Rect(0,0,200,400);\n        // 绘制图片\n        canvas.drawBitmap(bitmap,src,dst,null);\n\n    \t4. 注:可以控制两个区域的大小来完成某个动画.\n\n### 2. 绘制文字\n    \n    画笔Paint文本相关函数:\n    色彩\tsetColor,setARGB,setAlpha  设置颜色，透明度\n    大小\tsetTextSize\t               设置文本字体大小\n    字体\tsetTypeface\t               设置或清除字体样式\n    样式\tsetStyle\t               填充描边等\n    对齐\tsetTextAlign\t           左,居中,右\n    测量\tmeasureText\t               测量文本大小\n    \n    (注意:measureText()在设置完文本各项参数后调用)\n   \n1. 指定文本基线位置(x,y)\n\n\n        public void drawText \n        (String text, float x, float y, Paint paint)\n        (String text, int start, int end, float x, float y, Paint paint)\n        (CharSequence text, int start, int end, float x, float y, Paint paint)\n        (char[] text, int index, int count, float x, float y, Paint paint)\n\n\n    * 截取的字符串的index∈[start,end),index从0开始,\n    * count指截取的char字符数;\n    \n2. 指定每个文字的位置(不建议使用)\n\n        public void drawPosText \n        (String text, float[] pos, Paint paint)\n        (char[] text, int index, int count, float[] pos, Paint paint)\n        \n    * 例:\n        \n            canvas.drawPosText(str,new float[]{\n                  100,100,    // 第一个字符位置\n                  200,200,    // 第二个字符位置\n                  300,300,    // ...\n                  400,400,\n                  500,500},\n            textPaint);\n    \n    * 缺点:\n        1. 必须指定所有字符位置，否则直接crash掉，反人类设计\n        2. 性能不佳，在大量使用的时候可能导致卡顿\n        3. 不支持emoji等特殊字符，不支持字形组合与分解        \n       \n       \n3. 指定路径来绘制文字\n\n        public void drawTextOnPath \n        (String text, Path path, float hOffset, float vOffset, Paint paint)\n        (char[] text, int index, int count, Path path, float hOffset, float vOffset, Paint paint)\n\n---\n## Canvas内容绘制\n\n\t- 绘制颜色\n\t\t- 主要函数:drawColor, drawRGB, drawARGB\n\t\t- 使用单一颜色填充整个画布\n\t- 绘制基本形状\n\t\t- 主要函数:drawPoint, drawPoints, drawLine, drawLines, drawRect, drawRoundRect, drawOval, drawCircle, drawArc\t\n\t\t- 依次为 点、线、矩形、圆角矩形、椭圆、圆、圆弧\n\t- 绘制图片\n\t\t- 主要函数:drawBitmap, drawPicture\n\t\t- 绘制位图和图片\n\t- 绘制文本\t\n\t\t- drawText, drawPosText, drawTextOnPath\t\n\t\t- 依次为 绘制文字、绘制文字时指定每个文字位置、根据路径绘制文字\n\t- 绘制路径\t\n\t\t- drawPath\t\n\t\t- 绘制路径，绘制贝塞尔曲线时也需要用到该函数\n\t- 顶点操作\t\n\t\t- drawVertices, drawBitmapMesh\t\n\t\t- 通过对顶点操作可以使图像形变，drawVertices直接对画布作用、 drawBitmapMesh只对绘制的Bitmap作用\n\t- 画布剪裁\t\n\t\t- clipPath, clipRect\t\n\t\t- 设置画布的显示区域\n\t- 画布快照\t\n\t\t- save, restore, saveLayerXxx, restoreToCount, getSaveCount\t\n\t\t- 依次为 保存当前状态、回滚到上一次保存的状态、 保存图层状态、 回滚到指定状态、 获取保存次数\n\t- 画布变换\t\n\t\t- translate, scale, rotate, skew\t\n\t\t- 依次为 位移、缩放、 旋转、错切\n\t- Matrix(矩阵)\t\n\t\t- getMatrix, setMatrix, concat\t\n\t\t- 实际上画布的位移，缩放等操作的都是图像矩阵Matrix， 只不过Matrix比较难以理解和使用，故封装了一些常用的方法。\n\n\n### 绘制画布颜色\n\n\tcanvas.drawColor(int color);\n\n#### 绘制一个或者多个坐标点\n\n\tcanvas.drawPoint(200, 200, mPaint);    \n\t //在坐标(200,200)位置绘制一个点\n\tcanvas.drawPoints(new float[]{          \n\t//绘制一组点，坐标位置由float数组指定\n\t      500,500,\n\t      500,600,\n\t      500,700\n\t},mPaint);\n\n### 绘制形状\n\t\n#### 1. 线 ---- 每两个点确定一条线段\n\n\tcanvas.drawLine(300,300,500,600,mPaint);    \n\t// 在坐标(300,300)(500,600)之间绘制一条直线\n\tcanvas.drawLines(new float[]{               \n\t// 绘制一组线 每四数字(两个点的坐标)确定一条线\n\t    100,200,200,200,\n\t    100,300,200,300\n\t},mPaint);\n#### 2. 矩形 ---- 两个对角线确定一个矩形\n\n\t// 第一种\n\tcanvas.drawRect(100,100,800,400,mPaint);\n\t\n\t// 第二种\n\tRect rect = new Rect(100,100,800,400);\n\tcanvas.drawRect(rect,mPaint);\n\t\n\t// 第三种\n\tRectF rectF = new RectF(100,100,800,400);\n\tcanvas.drawRect(rectF,mPaint);\n\n\tRect和RectF的区别在于int 和 float精度,方法也不相同;\n\n#### 3. 圆角矩形 ---- 矩形 + 内切椭圆的两个半径(半径大于矩形一半的宽度按一半来算)\n\n\t// 第一种\n\tRectF rectF = new RectF(100,100,800,400);\n\tcanvas.drawRoundRect(rectF,30,30,mPaint);\n\t\n\t// 第二种\n\tcanvas.drawRoundRect(100,100,800,400,30,30,mPaint);\n\n\n#### 4. 椭圆 ---- 矩形的内切椭圆,只需给定矩形\n\n\t// 第一种\n\tRectF rectF = new RectF(100,100,800,400);\n\tcanvas.drawOval(rectF,mPaint);\n\t\n\t// 第二种\n\tcanvas.drawOval(100,100,800,400,mPaint);\n\n\n#### 5. 圆 ---- 圆心 + 半径\n\n\tcanvas.drawCircle(500,500,400,mPaint);  \n\t// 绘制一个圆心坐标在(500,500)，半径为400 的圆。\n\n#### 6. 圆弧 ---- 矩形内切椭圆 + 开始角度 + 结束角度 + 是否使用中心\n\t// 第一种\n\tpublic void drawArc(@NonNull RectF oval, float startAngle, float sweepAngle, boolean useCenter, @NonNull Paint paint)\n\t    \n\t// 第二种\n\tpublic void drawArc(float left, float top, float right, float bottom, float startAngle,\n\tfloat sweepAngle, boolean useCenter, @NonNull Paint paint)\n\n### Paint\n\n1. 类型setStyle(int style)\n\t1. Paint.Style.STROKE:描边 \n\t2. Paint.Style.FILL:填充\n\t3. Paint.Style.FILL_AND_STROKE:描边+填充\n2. 描边宽度\n\n\t\tpaint.setStrokeWidth(40);\n3. 抗锯齿\n\n\t\tsetAntiAlias(true);\n\n\n### Canvas\n\n\n1. 快照和回滚\n    1. 基础\n\n\t\t快照 : save();\t\t\t//保存画布状态\n\t\t回滚 : restore();\t\t//取出最后一次入栈的图层\n\n\t\tsave就是图层入栈,restore就是图层出栈;\t\n\t\n\t2. 对应的API:\n\t\t\n    \t\tsave()\t\t\t\t把当前的画布的状态进行保存，\n    \t\t或save(saveFlags)\t然后放入特定的栈中\n\n        \t\tALL_SAVE_FLAG\t\t\t\t默认，保存全部状态\n        \t\tCLIP_SAVE_FLAG\t\t\t\t保存剪辑区\n        \t\tCLIP_TO_LAYER_SAVE_FLAG\t\t剪裁区作为图层保存\n        \t\tFULL_COLOR_LAYER_SAVE_FLAG\t保存图层的全部色彩通道\n        \t\tHAS_ALPHA_LAYER_SAVE_FLAG\t保存图层的alpha(不透明度)通道\n        \t\tMATRIX_SAVE_FLAG\t\t\t保存Matrix信息( translate, rotate, scale, skew)\n    \n    \t\tsaveLayerXxx\t\t新建一个图层，并放入特定的栈中\n    \n\t\t\t\tsaveLayerXxx,导致图层叠加造成计算量增倍而过度渲染.\n\n                // 无图层alpha(不透明度)通道\n                public int saveLayer \n                (RectF bounds, Paint paint)\n                (RectF bounds, Paint paint, int saveFlags)\n                (float left, float top, float right, float bottom, Paint paint)\n                (float left, float top, float right, float bottom, Paint paint, int saveFlags)\n                // 有图层alpha(不透明度)通道\n                public int saveLayerAlpha (....,int alpha)\n\n    \t\trestore\t\t\t\t把栈中最顶层的画布状态取出来，\n    \t\t\t\t\t\t\t并按照这个状态恢复当前的画布\n    \n    \t\trestoreToCount\t\t弹出指定位置及其以上所有的状态，\n    \t\t\t\t\t\t\t并按照指定位置的状态进行恢复\n    \n    \t\tgetSaveCount\t\t获取栈中内容的数量(即保存次数)\n\n2. 位移(不断叠加),基于上一次位置的移动.\n\n\t\tcanvas.translate(200,200);\n\t\n3. 旋转(不断叠加),根据**某个中心位置或者原点**旋转**某个角度**;\n\t\t\n\t\tpublic void rotate \n\t\t(float degrees)\n        (float degrees, float px, float py)\n\n4. 缩放(不断叠加),**根据原点位置对x,y方向上的缩放比例,或者根据某个缩放中心的位置控制缩放比例;当缩放比例sx or sy < 0时,会进行翻转相当于中心对称翻转;**\n\n\t\tpublic void scale (float sx, float sy)\n\n\t\tpublic final void scale (float sx, float sy, float px, float py)\n\n\n5. 错切(不断叠加) - skew,**在某个方向上倾斜对应的角度,填入的值为角度对应的tan值.**\n\n\t\tpublic void skew (float sx, float sy)\n\t\t\n\t\t变换之后的值:\n\t\t\tX = x + sx * y\n\t\t\tY = sy * x + y\n\n\n","slug":"Android之自定义控件——Canvas绘制参考","published":1,"date":"2018-03-21T03:22:18.438Z","updated":"2018-03-03T01:51:49.217Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0kjqjc000h0s4lb1foivz5","content":"<h2 id=\"Canvas图片文字绘制\"><a href=\"#Canvas图片文字绘制\" class=\"headerlink\" title=\"Canvas图片文字绘制\"></a>Canvas图片文字绘制</h2><pre><code>概要:\n    1. 绘制图片\n    2. 绘制文字\n</code></pre><h3 id=\"1-绘制图片\"><a href=\"#1-绘制图片\" class=\"headerlink\" title=\"1. 绘制图片\"></a>1. 绘制图片</h3><h4 id=\"矢量-drawPicture\"><a href=\"#矢量-drawPicture\" class=\"headerlink\" title=\"-   矢量(drawPicture)\"></a>-   矢量(drawPicture)</h4><p>警告:需要关闭硬件加速.</p>\n<ul>\n<li>矢量图绘制就是记录Canvas绘制的内容. </li>\n<li><p>Picture的相关函数</p>\n<pre><code>- getWidth\\height():得到宽高\n- beginRecording(int width,int height):开始录制,return Canvas;\n- endRecording():结束录制;\n- draw(Canvas canvas):绘制矢量图;\n</code></pre></li>\n<li><p>矢量图的绘制有以下三种方式:</p>\n<ol>\n<li><p>mPic.draw(canvas);</p>\n<ul>\n<li>低版本<strong>影响canvas的状态</strong>,一般不使用;</li>\n</ul>\n</li>\n<li><p>canvas.drawPicture(mPic);</p>\n<ul>\n<li><p><strong>不影响canvas状态,可以设置显示矢量图的区域矩形大小,完全压缩显示.</strong></p>\n<pre><code>public void drawPicture (Picture picture)\n\npublic void drawPicture (Picture picture, Rect dst)\n\npublic void drawPicture (Picture picture, RectF dst)                \n</code></pre></li>\n</ul>\n</li>\n<li><p>picture → pictureDrawable → pictureDrawable.draw(canvas),<strong>不会缩放,按显示区域大小显示一部分</strong>;</p>\n<pre><code>// 包装成为Drawable\nPictureDrawable drawable = new PictureDrawable(mPicture);\n// 设置绘制区域 -- 注意此处所绘制的实际内容不会缩放\ndrawable.setBounds(0,0,250,mPicture.getHeight());\n// 绘制\ndrawable.draw(canvas);\n</code></pre></li>\n</ol>\n</li>\n</ul>\n<h4 id=\"位图-drawBitmap\"><a href=\"#位图-drawBitmap\" class=\"headerlink\" title=\"-   位图(drawBitmap)\"></a>-   位图(drawBitmap)</h4><p>可能会消耗大量的内存,或者会造成内存泄露;<br>首先获得bitmap,然后进行绘制.</p>\n<ol>\n<li><p>获取</p>\n<ol>\n<li><p>资源文件(drawable/mipmap/raw):</p>\n<pre><code>Bitmap bitmap = BitmapFactory.decodeResource\n(mContext.getResources(),R.raw.bitmap);\n</code></pre></li>\n<li><p>资源文件(assets):</p>\n<pre><code>Bitmap bitmap=null;\ntry {\n    InputStream is = mContext.getAssets()\n    .open(&quot;bitmap.png&quot;);\n    bitmap = BitmapFactory.decodeStream(is);\n    is.close();\n} catch (IOException e) {\n    e.printStackTrace();\n}\n</code></pre></li>\n<li><p>内存卡文件:</p>\n<pre><code>Bitmap bitmap = BitmapFactory\n    .decodeFile(&quot;/sdcard/.../bitmap.png&quot;);\n</code></pre></li>\n<li><p>网络文件:</p>\n<pre><code>// 此处省略了获取网络输入流的代码\nBitmap bitmap = BitmapFactory.decodeStream(is);\nis.close();\n</code></pre></li>\n</ol>\n</li>\n<li><p>绘制</p>\n<pre><code>public void drawBitmap \n1. (Bitmap bitmap, Matrix matrix, Paint paint)\n2. (Bitmap bitmap, float left, float top, Paint paint)\n3. (Bitmap bitmap, Rect src, Rect dst, Paint paint)\n4. (Bitmap bitmap, Rect src, RectF dst, Paint paint)\n\n1. 默认绘制起点为原点.\n    `canvas.drawBitmap(bitmap,new Matrix(),new Paint());`\n2. 确定一个绘制起点坐标.\n3. 4.指定图片的绘制矩形区域和图片在屏幕上的绘制矩形区域,当前者宽/高度&gt;后者宽/高度的情况下会压缩.\n\ncanvas.translate(mWidth/2,mHeight/2);\n// 指定图片绘制区域(左上角的四分之一)\nRect src = new Rect(0,0,bitmap.getWidth()/2,bitmap.getHeight()/2);\n// 指定图片在屏幕上显示的区域\nRect dst = new Rect(0,0,200,400);\n// 绘制图片\ncanvas.drawBitmap(bitmap,src,dst,null);\n\n4. 注:可以控制两个区域的大小来完成某个动画.\n</code></pre></li>\n</ol>\n<h3 id=\"2-绘制文字\"><a href=\"#2-绘制文字\" class=\"headerlink\" title=\"2. 绘制文字\"></a>2. 绘制文字</h3><pre><code>画笔Paint文本相关函数:\n色彩    setColor,setARGB,setAlpha  设置颜色，透明度\n大小    setTextSize                   设置文本字体大小\n字体    setTypeface                   设置或清除字体样式\n样式    setStyle                   填充描边等\n对齐    setTextAlign               左,居中,右\n测量    measureText                   测量文本大小\n\n(注意:measureText()在设置完文本各项参数后调用)\n</code></pre><ol>\n<li>指定文本基线位置(x,y)</li>\n</ol>\n<pre><code>    public void drawText \n    (String text, float x, float y, Paint paint)\n    (String text, int start, int end, float x, float y, Paint paint)\n    (CharSequence text, int start, int end, float x, float y, Paint paint)\n    (char[] text, int index, int count, float x, float y, Paint paint)\n\n\n* 截取的字符串的index∈[start,end),index从0开始,\n* count指截取的char字符数;\n</code></pre><ol>\n<li><p>指定每个文字的位置(不建议使用)</p>\n<pre><code>public void drawPosText \n(String text, float[] pos, Paint paint)\n(char[] text, int index, int count, float[] pos, Paint paint)\n</code></pre><ul>\n<li><p>例:</p>\n<pre><code>canvas.drawPosText(str,new float[]{\n      100,100,    // 第一个字符位置\n      200,200,    // 第二个字符位置\n      300,300,    // ...\n      400,400,\n      500,500},\ntextPaint);\n</code></pre></li>\n<li><p>缺点:</p>\n<ol>\n<li>必须指定所有字符位置，否则直接crash掉，反人类设计</li>\n<li>性能不佳，在大量使用的时候可能导致卡顿</li>\n<li>不支持emoji等特殊字符，不支持字形组合与分解        </li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<ol>\n<li><p>指定路径来绘制文字</p>\n<pre><code>public void drawTextOnPath \n(String text, Path path, float hOffset, float vOffset, Paint paint)\n(char[] text, int index, int count, Path path, float hOffset, float vOffset, Paint paint)\n</code></pre></li>\n</ol>\n<hr>\n<h2 id=\"Canvas内容绘制\"><a href=\"#Canvas内容绘制\" class=\"headerlink\" title=\"Canvas内容绘制\"></a>Canvas内容绘制</h2><pre><code>- 绘制颜色\n    - 主要函数:drawColor, drawRGB, drawARGB\n    - 使用单一颜色填充整个画布\n- 绘制基本形状\n    - 主要函数:drawPoint, drawPoints, drawLine, drawLines, drawRect, drawRoundRect, drawOval, drawCircle, drawArc    \n    - 依次为 点、线、矩形、圆角矩形、椭圆、圆、圆弧\n- 绘制图片\n    - 主要函数:drawBitmap, drawPicture\n    - 绘制位图和图片\n- 绘制文本    \n    - drawText, drawPosText, drawTextOnPath    \n    - 依次为 绘制文字、绘制文字时指定每个文字位置、根据路径绘制文字\n- 绘制路径    \n    - drawPath    \n    - 绘制路径，绘制贝塞尔曲线时也需要用到该函数\n- 顶点操作    \n    - drawVertices, drawBitmapMesh    \n    - 通过对顶点操作可以使图像形变，drawVertices直接对画布作用、 drawBitmapMesh只对绘制的Bitmap作用\n- 画布剪裁    \n    - clipPath, clipRect    \n    - 设置画布的显示区域\n- 画布快照    \n    - save, restore, saveLayerXxx, restoreToCount, getSaveCount    \n    - 依次为 保存当前状态、回滚到上一次保存的状态、 保存图层状态、 回滚到指定状态、 获取保存次数\n- 画布变换    \n    - translate, scale, rotate, skew    \n    - 依次为 位移、缩放、 旋转、错切\n- Matrix(矩阵)    \n    - getMatrix, setMatrix, concat    \n    - 实际上画布的位移，缩放等操作的都是图像矩阵Matrix， 只不过Matrix比较难以理解和使用，故封装了一些常用的方法。\n</code></pre><h3 id=\"绘制画布颜色\"><a href=\"#绘制画布颜色\" class=\"headerlink\" title=\"绘制画布颜色\"></a>绘制画布颜色</h3><pre><code>canvas.drawColor(int color);\n</code></pre><h4 id=\"绘制一个或者多个坐标点\"><a href=\"#绘制一个或者多个坐标点\" class=\"headerlink\" title=\"绘制一个或者多个坐标点\"></a>绘制一个或者多个坐标点</h4><pre><code>canvas.drawPoint(200, 200, mPaint);    \n //在坐标(200,200)位置绘制一个点\ncanvas.drawPoints(new float[]{          \n//绘制一组点，坐标位置由float数组指定\n      500,500,\n      500,600,\n      500,700\n},mPaint);\n</code></pre><h3 id=\"绘制形状\"><a href=\"#绘制形状\" class=\"headerlink\" title=\"绘制形状\"></a>绘制形状</h3><h4 id=\"1-线-—-每两个点确定一条线段\"><a href=\"#1-线-—-每两个点确定一条线段\" class=\"headerlink\" title=\"1. 线 —- 每两个点确定一条线段\"></a>1. 线 —- 每两个点确定一条线段</h4><pre><code>canvas.drawLine(300,300,500,600,mPaint);    \n// 在坐标(300,300)(500,600)之间绘制一条直线\ncanvas.drawLines(new float[]{               \n// 绘制一组线 每四数字(两个点的坐标)确定一条线\n    100,200,200,200,\n    100,300,200,300\n},mPaint);\n</code></pre><h4 id=\"2-矩形-—-两个对角线确定一个矩形\"><a href=\"#2-矩形-—-两个对角线确定一个矩形\" class=\"headerlink\" title=\"2. 矩形 —- 两个对角线确定一个矩形\"></a>2. 矩形 —- 两个对角线确定一个矩形</h4><pre><code>// 第一种\ncanvas.drawRect(100,100,800,400,mPaint);\n\n// 第二种\nRect rect = new Rect(100,100,800,400);\ncanvas.drawRect(rect,mPaint);\n\n// 第三种\nRectF rectF = new RectF(100,100,800,400);\ncanvas.drawRect(rectF,mPaint);\n\nRect和RectF的区别在于int 和 float精度,方法也不相同;\n</code></pre><h4 id=\"3-圆角矩形-—-矩形-内切椭圆的两个半径-半径大于矩形一半的宽度按一半来算\"><a href=\"#3-圆角矩形-—-矩形-内切椭圆的两个半径-半径大于矩形一半的宽度按一半来算\" class=\"headerlink\" title=\"3. 圆角矩形 —- 矩形 + 内切椭圆的两个半径(半径大于矩形一半的宽度按一半来算)\"></a>3. 圆角矩形 —- 矩形 + 内切椭圆的两个半径(半径大于矩形一半的宽度按一半来算)</h4><pre><code>// 第一种\nRectF rectF = new RectF(100,100,800,400);\ncanvas.drawRoundRect(rectF,30,30,mPaint);\n\n// 第二种\ncanvas.drawRoundRect(100,100,800,400,30,30,mPaint);\n</code></pre><h4 id=\"4-椭圆-—-矩形的内切椭圆-只需给定矩形\"><a href=\"#4-椭圆-—-矩形的内切椭圆-只需给定矩形\" class=\"headerlink\" title=\"4. 椭圆 —- 矩形的内切椭圆,只需给定矩形\"></a>4. 椭圆 —- 矩形的内切椭圆,只需给定矩形</h4><pre><code>// 第一种\nRectF rectF = new RectF(100,100,800,400);\ncanvas.drawOval(rectF,mPaint);\n\n// 第二种\ncanvas.drawOval(100,100,800,400,mPaint);\n</code></pre><h4 id=\"5-圆-—-圆心-半径\"><a href=\"#5-圆-—-圆心-半径\" class=\"headerlink\" title=\"5. 圆 —- 圆心 + 半径\"></a>5. 圆 —- 圆心 + 半径</h4><pre><code>canvas.drawCircle(500,500,400,mPaint);  \n// 绘制一个圆心坐标在(500,500)，半径为400 的圆。\n</code></pre><h4 id=\"6-圆弧-—-矩形内切椭圆-开始角度-结束角度-是否使用中心\"><a href=\"#6-圆弧-—-矩形内切椭圆-开始角度-结束角度-是否使用中心\" class=\"headerlink\" title=\"6. 圆弧 —- 矩形内切椭圆 + 开始角度 + 结束角度 + 是否使用中心\"></a>6. 圆弧 —- 矩形内切椭圆 + 开始角度 + 结束角度 + 是否使用中心</h4><pre><code>// 第一种\npublic void drawArc(@NonNull RectF oval, float startAngle, float sweepAngle, boolean useCenter, @NonNull Paint paint)\n\n// 第二种\npublic void drawArc(float left, float top, float right, float bottom, float startAngle,\nfloat sweepAngle, boolean useCenter, @NonNull Paint paint)\n</code></pre><h3 id=\"Paint\"><a href=\"#Paint\" class=\"headerlink\" title=\"Paint\"></a>Paint</h3><ol>\n<li>类型setStyle(int style)<ol>\n<li>Paint.Style.STROKE:描边 </li>\n<li>Paint.Style.FILL:填充</li>\n<li>Paint.Style.FILL_AND_STROKE:描边+填充</li>\n</ol>\n</li>\n<li><p>描边宽度</p>\n<pre><code>paint.setStrokeWidth(40);\n</code></pre></li>\n<li><p>抗锯齿</p>\n<pre><code>setAntiAlias(true);\n</code></pre></li>\n</ol>\n<h3 id=\"Canvas\"><a href=\"#Canvas\" class=\"headerlink\" title=\"Canvas\"></a>Canvas</h3><ol>\n<li><p>快照和回滚</p>\n<ol>\n<li><p>基础</p>\n<p> 快照 : save();            //保存画布状态<br> 回滚 : restore();        //取出最后一次入栈的图层</p>\n<p> save就是图层入栈,restore就是图层出栈;    </p>\n</li>\n<li><p>对应的API:</p>\n<pre><code>save()                把当前的画布的状态进行保存，\n或save(saveFlags)    然后放入特定的栈中\n\n    ALL_SAVE_FLAG                默认，保存全部状态\n    CLIP_SAVE_FLAG                保存剪辑区\n    CLIP_TO_LAYER_SAVE_FLAG        剪裁区作为图层保存\n    FULL_COLOR_LAYER_SAVE_FLAG    保存图层的全部色彩通道\n    HAS_ALPHA_LAYER_SAVE_FLAG    保存图层的alpha(不透明度)通道\n    MATRIX_SAVE_FLAG            保存Matrix信息( translate, rotate, scale, skew)\n\nsaveLayerXxx        新建一个图层，并放入特定的栈中\n\n    saveLayerXxx,导致图层叠加造成计算量增倍而过度渲染.\n\n    // 无图层alpha(不透明度)通道\n    public int saveLayer \n    (RectF bounds, Paint paint)\n    (RectF bounds, Paint paint, int saveFlags)\n    (float left, float top, float right, float bottom, Paint paint)\n    (float left, float top, float right, float bottom, Paint paint, int saveFlags)\n    // 有图层alpha(不透明度)通道\n    public int saveLayerAlpha (....,int alpha)\n\nrestore                把栈中最顶层的画布状态取出来，\n                    并按照这个状态恢复当前的画布\n\nrestoreToCount        弹出指定位置及其以上所有的状态，\n                    并按照指定位置的状态进行恢复\n\ngetSaveCount        获取栈中内容的数量(即保存次数)\n</code></pre></li>\n</ol>\n</li>\n<li><p>位移(不断叠加),基于上一次位置的移动.</p>\n<pre><code>canvas.translate(200,200);\n</code></pre></li>\n<li><p>旋转(不断叠加),根据<strong>某个中心位置或者原点</strong>旋转<strong>某个角度</strong>;</p>\n<pre><code>public void rotate \n(float degrees)\n(float degrees, float px, float py)\n</code></pre></li>\n<li><p>缩放(不断叠加),<strong>根据原点位置对x,y方向上的缩放比例,或者根据某个缩放中心的位置控制缩放比例;当缩放比例sx or sy &lt; 0时,会进行翻转相当于中心对称翻转;</strong></p>\n<pre><code>public void scale (float sx, float sy)\n\npublic final void scale (float sx, float sy, float px, float py)\n</code></pre></li>\n</ol>\n<ol>\n<li><p>错切(不断叠加) - skew,<strong>在某个方向上倾斜对应的角度,填入的值为角度对应的tan值.</strong></p>\n<pre><code>public void skew (float sx, float sy)\n\n变换之后的值:\n    X = x + sx * y\n    Y = sy * x + y\n</code></pre></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Canvas图片文字绘制\"><a href=\"#Canvas图片文字绘制\" class=\"headerlink\" title=\"Canvas图片文字绘制\"></a>Canvas图片文字绘制</h2><pre><code>概要:\n    1. 绘制图片\n    2. 绘制文字\n</code></pre><h3 id=\"1-绘制图片\"><a href=\"#1-绘制图片\" class=\"headerlink\" title=\"1. 绘制图片\"></a>1. 绘制图片</h3><h4 id=\"矢量-drawPicture\"><a href=\"#矢量-drawPicture\" class=\"headerlink\" title=\"-   矢量(drawPicture)\"></a>-   矢量(drawPicture)</h4><p>警告:需要关闭硬件加速.</p>\n<ul>\n<li>矢量图绘制就是记录Canvas绘制的内容. </li>\n<li><p>Picture的相关函数</p>\n<pre><code>- getWidth\\height():得到宽高\n- beginRecording(int width,int height):开始录制,return Canvas;\n- endRecording():结束录制;\n- draw(Canvas canvas):绘制矢量图;\n</code></pre></li>\n<li><p>矢量图的绘制有以下三种方式:</p>\n<ol>\n<li><p>mPic.draw(canvas);</p>\n<ul>\n<li>低版本<strong>影响canvas的状态</strong>,一般不使用;</li>\n</ul>\n</li>\n<li><p>canvas.drawPicture(mPic);</p>\n<ul>\n<li><p><strong>不影响canvas状态,可以设置显示矢量图的区域矩形大小,完全压缩显示.</strong></p>\n<pre><code>public void drawPicture (Picture picture)\n\npublic void drawPicture (Picture picture, Rect dst)\n\npublic void drawPicture (Picture picture, RectF dst)                \n</code></pre></li>\n</ul>\n</li>\n<li><p>picture → pictureDrawable → pictureDrawable.draw(canvas),<strong>不会缩放,按显示区域大小显示一部分</strong>;</p>\n<pre><code>// 包装成为Drawable\nPictureDrawable drawable = new PictureDrawable(mPicture);\n// 设置绘制区域 -- 注意此处所绘制的实际内容不会缩放\ndrawable.setBounds(0,0,250,mPicture.getHeight());\n// 绘制\ndrawable.draw(canvas);\n</code></pre></li>\n</ol>\n</li>\n</ul>\n<h4 id=\"位图-drawBitmap\"><a href=\"#位图-drawBitmap\" class=\"headerlink\" title=\"-   位图(drawBitmap)\"></a>-   位图(drawBitmap)</h4><p>可能会消耗大量的内存,或者会造成内存泄露;<br>首先获得bitmap,然后进行绘制.</p>\n<ol>\n<li><p>获取</p>\n<ol>\n<li><p>资源文件(drawable/mipmap/raw):</p>\n<pre><code>Bitmap bitmap = BitmapFactory.decodeResource\n(mContext.getResources(),R.raw.bitmap);\n</code></pre></li>\n<li><p>资源文件(assets):</p>\n<pre><code>Bitmap bitmap=null;\ntry {\n    InputStream is = mContext.getAssets()\n    .open(&quot;bitmap.png&quot;);\n    bitmap = BitmapFactory.decodeStream(is);\n    is.close();\n} catch (IOException e) {\n    e.printStackTrace();\n}\n</code></pre></li>\n<li><p>内存卡文件:</p>\n<pre><code>Bitmap bitmap = BitmapFactory\n    .decodeFile(&quot;/sdcard/.../bitmap.png&quot;);\n</code></pre></li>\n<li><p>网络文件:</p>\n<pre><code>// 此处省略了获取网络输入流的代码\nBitmap bitmap = BitmapFactory.decodeStream(is);\nis.close();\n</code></pre></li>\n</ol>\n</li>\n<li><p>绘制</p>\n<pre><code>public void drawBitmap \n1. (Bitmap bitmap, Matrix matrix, Paint paint)\n2. (Bitmap bitmap, float left, float top, Paint paint)\n3. (Bitmap bitmap, Rect src, Rect dst, Paint paint)\n4. (Bitmap bitmap, Rect src, RectF dst, Paint paint)\n\n1. 默认绘制起点为原点.\n    `canvas.drawBitmap(bitmap,new Matrix(),new Paint());`\n2. 确定一个绘制起点坐标.\n3. 4.指定图片的绘制矩形区域和图片在屏幕上的绘制矩形区域,当前者宽/高度&gt;后者宽/高度的情况下会压缩.\n\ncanvas.translate(mWidth/2,mHeight/2);\n// 指定图片绘制区域(左上角的四分之一)\nRect src = new Rect(0,0,bitmap.getWidth()/2,bitmap.getHeight()/2);\n// 指定图片在屏幕上显示的区域\nRect dst = new Rect(0,0,200,400);\n// 绘制图片\ncanvas.drawBitmap(bitmap,src,dst,null);\n\n4. 注:可以控制两个区域的大小来完成某个动画.\n</code></pre></li>\n</ol>\n<h3 id=\"2-绘制文字\"><a href=\"#2-绘制文字\" class=\"headerlink\" title=\"2. 绘制文字\"></a>2. 绘制文字</h3><pre><code>画笔Paint文本相关函数:\n色彩    setColor,setARGB,setAlpha  设置颜色，透明度\n大小    setTextSize                   设置文本字体大小\n字体    setTypeface                   设置或清除字体样式\n样式    setStyle                   填充描边等\n对齐    setTextAlign               左,居中,右\n测量    measureText                   测量文本大小\n\n(注意:measureText()在设置完文本各项参数后调用)\n</code></pre><ol>\n<li>指定文本基线位置(x,y)</li>\n</ol>\n<pre><code>    public void drawText \n    (String text, float x, float y, Paint paint)\n    (String text, int start, int end, float x, float y, Paint paint)\n    (CharSequence text, int start, int end, float x, float y, Paint paint)\n    (char[] text, int index, int count, float x, float y, Paint paint)\n\n\n* 截取的字符串的index∈[start,end),index从0开始,\n* count指截取的char字符数;\n</code></pre><ol>\n<li><p>指定每个文字的位置(不建议使用)</p>\n<pre><code>public void drawPosText \n(String text, float[] pos, Paint paint)\n(char[] text, int index, int count, float[] pos, Paint paint)\n</code></pre><ul>\n<li><p>例:</p>\n<pre><code>canvas.drawPosText(str,new float[]{\n      100,100,    // 第一个字符位置\n      200,200,    // 第二个字符位置\n      300,300,    // ...\n      400,400,\n      500,500},\ntextPaint);\n</code></pre></li>\n<li><p>缺点:</p>\n<ol>\n<li>必须指定所有字符位置，否则直接crash掉，反人类设计</li>\n<li>性能不佳，在大量使用的时候可能导致卡顿</li>\n<li>不支持emoji等特殊字符，不支持字形组合与分解        </li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<ol>\n<li><p>指定路径来绘制文字</p>\n<pre><code>public void drawTextOnPath \n(String text, Path path, float hOffset, float vOffset, Paint paint)\n(char[] text, int index, int count, Path path, float hOffset, float vOffset, Paint paint)\n</code></pre></li>\n</ol>\n<hr>\n<h2 id=\"Canvas内容绘制\"><a href=\"#Canvas内容绘制\" class=\"headerlink\" title=\"Canvas内容绘制\"></a>Canvas内容绘制</h2><pre><code>- 绘制颜色\n    - 主要函数:drawColor, drawRGB, drawARGB\n    - 使用单一颜色填充整个画布\n- 绘制基本形状\n    - 主要函数:drawPoint, drawPoints, drawLine, drawLines, drawRect, drawRoundRect, drawOval, drawCircle, drawArc    \n    - 依次为 点、线、矩形、圆角矩形、椭圆、圆、圆弧\n- 绘制图片\n    - 主要函数:drawBitmap, drawPicture\n    - 绘制位图和图片\n- 绘制文本    \n    - drawText, drawPosText, drawTextOnPath    \n    - 依次为 绘制文字、绘制文字时指定每个文字位置、根据路径绘制文字\n- 绘制路径    \n    - drawPath    \n    - 绘制路径，绘制贝塞尔曲线时也需要用到该函数\n- 顶点操作    \n    - drawVertices, drawBitmapMesh    \n    - 通过对顶点操作可以使图像形变，drawVertices直接对画布作用、 drawBitmapMesh只对绘制的Bitmap作用\n- 画布剪裁    \n    - clipPath, clipRect    \n    - 设置画布的显示区域\n- 画布快照    \n    - save, restore, saveLayerXxx, restoreToCount, getSaveCount    \n    - 依次为 保存当前状态、回滚到上一次保存的状态、 保存图层状态、 回滚到指定状态、 获取保存次数\n- 画布变换    \n    - translate, scale, rotate, skew    \n    - 依次为 位移、缩放、 旋转、错切\n- Matrix(矩阵)    \n    - getMatrix, setMatrix, concat    \n    - 实际上画布的位移，缩放等操作的都是图像矩阵Matrix， 只不过Matrix比较难以理解和使用，故封装了一些常用的方法。\n</code></pre><h3 id=\"绘制画布颜色\"><a href=\"#绘制画布颜色\" class=\"headerlink\" title=\"绘制画布颜色\"></a>绘制画布颜色</h3><pre><code>canvas.drawColor(int color);\n</code></pre><h4 id=\"绘制一个或者多个坐标点\"><a href=\"#绘制一个或者多个坐标点\" class=\"headerlink\" title=\"绘制一个或者多个坐标点\"></a>绘制一个或者多个坐标点</h4><pre><code>canvas.drawPoint(200, 200, mPaint);    \n //在坐标(200,200)位置绘制一个点\ncanvas.drawPoints(new float[]{          \n//绘制一组点，坐标位置由float数组指定\n      500,500,\n      500,600,\n      500,700\n},mPaint);\n</code></pre><h3 id=\"绘制形状\"><a href=\"#绘制形状\" class=\"headerlink\" title=\"绘制形状\"></a>绘制形状</h3><h4 id=\"1-线-—-每两个点确定一条线段\"><a href=\"#1-线-—-每两个点确定一条线段\" class=\"headerlink\" title=\"1. 线 —- 每两个点确定一条线段\"></a>1. 线 —- 每两个点确定一条线段</h4><pre><code>canvas.drawLine(300,300,500,600,mPaint);    \n// 在坐标(300,300)(500,600)之间绘制一条直线\ncanvas.drawLines(new float[]{               \n// 绘制一组线 每四数字(两个点的坐标)确定一条线\n    100,200,200,200,\n    100,300,200,300\n},mPaint);\n</code></pre><h4 id=\"2-矩形-—-两个对角线确定一个矩形\"><a href=\"#2-矩形-—-两个对角线确定一个矩形\" class=\"headerlink\" title=\"2. 矩形 —- 两个对角线确定一个矩形\"></a>2. 矩形 —- 两个对角线确定一个矩形</h4><pre><code>// 第一种\ncanvas.drawRect(100,100,800,400,mPaint);\n\n// 第二种\nRect rect = new Rect(100,100,800,400);\ncanvas.drawRect(rect,mPaint);\n\n// 第三种\nRectF rectF = new RectF(100,100,800,400);\ncanvas.drawRect(rectF,mPaint);\n\nRect和RectF的区别在于int 和 float精度,方法也不相同;\n</code></pre><h4 id=\"3-圆角矩形-—-矩形-内切椭圆的两个半径-半径大于矩形一半的宽度按一半来算\"><a href=\"#3-圆角矩形-—-矩形-内切椭圆的两个半径-半径大于矩形一半的宽度按一半来算\" class=\"headerlink\" title=\"3. 圆角矩形 —- 矩形 + 内切椭圆的两个半径(半径大于矩形一半的宽度按一半来算)\"></a>3. 圆角矩形 —- 矩形 + 内切椭圆的两个半径(半径大于矩形一半的宽度按一半来算)</h4><pre><code>// 第一种\nRectF rectF = new RectF(100,100,800,400);\ncanvas.drawRoundRect(rectF,30,30,mPaint);\n\n// 第二种\ncanvas.drawRoundRect(100,100,800,400,30,30,mPaint);\n</code></pre><h4 id=\"4-椭圆-—-矩形的内切椭圆-只需给定矩形\"><a href=\"#4-椭圆-—-矩形的内切椭圆-只需给定矩形\" class=\"headerlink\" title=\"4. 椭圆 —- 矩形的内切椭圆,只需给定矩形\"></a>4. 椭圆 —- 矩形的内切椭圆,只需给定矩形</h4><pre><code>// 第一种\nRectF rectF = new RectF(100,100,800,400);\ncanvas.drawOval(rectF,mPaint);\n\n// 第二种\ncanvas.drawOval(100,100,800,400,mPaint);\n</code></pre><h4 id=\"5-圆-—-圆心-半径\"><a href=\"#5-圆-—-圆心-半径\" class=\"headerlink\" title=\"5. 圆 —- 圆心 + 半径\"></a>5. 圆 —- 圆心 + 半径</h4><pre><code>canvas.drawCircle(500,500,400,mPaint);  \n// 绘制一个圆心坐标在(500,500)，半径为400 的圆。\n</code></pre><h4 id=\"6-圆弧-—-矩形内切椭圆-开始角度-结束角度-是否使用中心\"><a href=\"#6-圆弧-—-矩形内切椭圆-开始角度-结束角度-是否使用中心\" class=\"headerlink\" title=\"6. 圆弧 —- 矩形内切椭圆 + 开始角度 + 结束角度 + 是否使用中心\"></a>6. 圆弧 —- 矩形内切椭圆 + 开始角度 + 结束角度 + 是否使用中心</h4><pre><code>// 第一种\npublic void drawArc(@NonNull RectF oval, float startAngle, float sweepAngle, boolean useCenter, @NonNull Paint paint)\n\n// 第二种\npublic void drawArc(float left, float top, float right, float bottom, float startAngle,\nfloat sweepAngle, boolean useCenter, @NonNull Paint paint)\n</code></pre><h3 id=\"Paint\"><a href=\"#Paint\" class=\"headerlink\" title=\"Paint\"></a>Paint</h3><ol>\n<li>类型setStyle(int style)<ol>\n<li>Paint.Style.STROKE:描边 </li>\n<li>Paint.Style.FILL:填充</li>\n<li>Paint.Style.FILL_AND_STROKE:描边+填充</li>\n</ol>\n</li>\n<li><p>描边宽度</p>\n<pre><code>paint.setStrokeWidth(40);\n</code></pre></li>\n<li><p>抗锯齿</p>\n<pre><code>setAntiAlias(true);\n</code></pre></li>\n</ol>\n<h3 id=\"Canvas\"><a href=\"#Canvas\" class=\"headerlink\" title=\"Canvas\"></a>Canvas</h3><ol>\n<li><p>快照和回滚</p>\n<ol>\n<li><p>基础</p>\n<p> 快照 : save();            //保存画布状态<br> 回滚 : restore();        //取出最后一次入栈的图层</p>\n<p> save就是图层入栈,restore就是图层出栈;    </p>\n</li>\n<li><p>对应的API:</p>\n<pre><code>save()                把当前的画布的状态进行保存，\n或save(saveFlags)    然后放入特定的栈中\n\n    ALL_SAVE_FLAG                默认，保存全部状态\n    CLIP_SAVE_FLAG                保存剪辑区\n    CLIP_TO_LAYER_SAVE_FLAG        剪裁区作为图层保存\n    FULL_COLOR_LAYER_SAVE_FLAG    保存图层的全部色彩通道\n    HAS_ALPHA_LAYER_SAVE_FLAG    保存图层的alpha(不透明度)通道\n    MATRIX_SAVE_FLAG            保存Matrix信息( translate, rotate, scale, skew)\n\nsaveLayerXxx        新建一个图层，并放入特定的栈中\n\n    saveLayerXxx,导致图层叠加造成计算量增倍而过度渲染.\n\n    // 无图层alpha(不透明度)通道\n    public int saveLayer \n    (RectF bounds, Paint paint)\n    (RectF bounds, Paint paint, int saveFlags)\n    (float left, float top, float right, float bottom, Paint paint)\n    (float left, float top, float right, float bottom, Paint paint, int saveFlags)\n    // 有图层alpha(不透明度)通道\n    public int saveLayerAlpha (....,int alpha)\n\nrestore                把栈中最顶层的画布状态取出来，\n                    并按照这个状态恢复当前的画布\n\nrestoreToCount        弹出指定位置及其以上所有的状态，\n                    并按照指定位置的状态进行恢复\n\ngetSaveCount        获取栈中内容的数量(即保存次数)\n</code></pre></li>\n</ol>\n</li>\n<li><p>位移(不断叠加),基于上一次位置的移动.</p>\n<pre><code>canvas.translate(200,200);\n</code></pre></li>\n<li><p>旋转(不断叠加),根据<strong>某个中心位置或者原点</strong>旋转<strong>某个角度</strong>;</p>\n<pre><code>public void rotate \n(float degrees)\n(float degrees, float px, float py)\n</code></pre></li>\n<li><p>缩放(不断叠加),<strong>根据原点位置对x,y方向上的缩放比例,或者根据某个缩放中心的位置控制缩放比例;当缩放比例sx or sy &lt; 0时,会进行翻转相当于中心对称翻转;</strong></p>\n<pre><code>public void scale (float sx, float sy)\n\npublic final void scale (float sx, float sy, float px, float py)\n</code></pre></li>\n</ol>\n<ol>\n<li><p>错切(不断叠加) - skew,<strong>在某个方向上倾斜对应的角度,填入的值为角度对应的tan值.</strong></p>\n<pre><code>public void skew (float sx, float sy)\n\n变换之后的值:\n    X = x + sx * y\n    Y = sy * x + y\n</code></pre></li>\n</ol>\n"},{"title":"Android 坐标与参数/对应函数","_content":"\n# View之坐标与参数/对应函数\n\n---\n\t\n\t目录:\n\n\t\t1. 坐标与坐标系\n\t\t\t- mLeft:\t\t\t\t以父容器左上为坐标原点,左上角X值\n\t\t\t- mRight:\t\t\t\t以父容器左上为坐标原点,右下角X值\n\t\t\t- mTop:\t\t\t\t\t以父容器左上为坐标原点,左上角Y值\n\t\t\t- mBottom:\t\t\t\t以父容器左上为坐标原点,右下角Y值\n\n\t\t\t注意: offsetLeftAndRight(int offset)与offsetTopAndBottom(int offset)\n\t\t\t用于View的平移.直接改变以上四个值\n\n\t\t\t- translationX:\t\t\t以父容器左上为坐标原点,X偏移量\t\t\n\t\t\t- translationY:\t\t\t以父容器左上为坐标原点,Y偏移量\n\n\t\t\t注意: 偏移量使用setTranslationX/Y(float),原相对于父容器的坐标不会发生变化,\n\t\t\tView通过坐标与偏移量的叠加进行绘制.\n\n\t\t\t- MotionEvent#getX():\t以当前View左上为坐标原点,触摸点X值\n\t\t\t- MotionEvent#getY():\t以当前View左上为坐标原点,触摸点Y值\n\t\t\t- MotionEvent#getRawX():以屏幕左上为坐标原点,触摸点X值\n\t\t\t- MotionEvent#getRawY():以屏幕左上为坐标原点,触摸点Y值\n\n\t\t\t注意: 与触摸事件相关.\n\n\t\t\t- mScrollX:\t\t\t\t与View位置无关,View内容相对于原状态X方向的滚动量\n\t\t\t- mScrollY:\t\t\t\t与View位置无关,View内容相对于原状态Y方向的滚动量\n\t\n\t\t\t注意: 向上/左,滚动量为正;反之为负.\n\n\t\t\t- mPaddingLeft\n\t\t\t- mPaddingRight\n\t\t\t- mPaddingTop\n\t\t\t- mPaddingBottom\n\n\n\t\n\t\t2. 参数与函数\n\t\t\t- width:\t\t\t\t\t   getRight() - getLeft()\n\t\t\t- height:\t\t\t\t\t  getBottom() - getTop()\n\t\t\t- measureWidth:\t\t\t\tmMeasuredWidth & MEASURED_SIZE_MASK\n\t\t\t- measureHeight:\t\t\t   mMeasuredHeight & MEASURED_SIZE_MASK\n\n\t\t\t注: >>> width/height 与 measureWidth/measureHeight 区别在于赋值时机不同,\n\t\t\t\t>>> measureWidth/measureHeight 形成于 measure 过程;\n\t\t\t\t>>> width/height 形成于 layout 过程;\n\n\t\t\t- getLocalVisibleRect(Rect)\n\t\t\t- getGlobalVisibleRect(Rect,Point)\n\t\t\t- getLocationOnScreen(int[2])\n\t\t\t- getLocationInWindow(int[2])\n\n\n\n---\n\n### 坐标与坐标系\n1. 坐标示意图如下:\n\n\t![坐标示意图](http://upload-images.jianshu.io/upload_images/3551332-ceab93bf82f135a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n2. 角度示意图如下:\n\n\t![角度坐标](http://upload-images.jianshu.io/upload_images/3846387-89827b3403db8137.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n3. 滚动量值示意图如下:\n\n\t![滚动量值](http://upload-images.jianshu.io/upload_images/1302497-a65d8640ea8029cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n---\n\n### 参数与函数 ###\n\n#### 1. 获得View相对于父容器/屏幕原点的偏移量 ####\n\n\t\t来源链接：http://www.jianshu.com/p/f09541b2f43b\n\n- `getLocalVisibleRect(Rect)`: 获取View在其父控件中的可见区域相对于此View的左顶点的距离（偏移量）；\n```\n\t\tRect localRect = new Rect();\n        v.getLocalVisibleRect(localRect);\n        ((TextView) findViewById(R.id.local)).setText(\"local\" + localRect.toString());\n\t\t//显示左上和右下两个点的相对坐标\n```\n\n- `getGlobalVisibleRect(Rect,Point)`: 获取View在其父控件中的可见区域相对于屏幕左顶点的距离（偏移量）；\n```\n\t\tRect globalRect = new Rect();\n        Point globalOffset = new Point();\n        v.getGlobalVisibleRect(globalRect, globalOffset);\n        ((TextView) findViewById(R.id.global)).setText(\"global\" + globalRect.toString());\n        ((TextView) findViewById(R.id.offset)).setText(\"globalOffset:\" + globalOffset.x + \",\" + globalOffset.y);\n```\n\n\n#### 2. 绝对坐标 ####\n\t\n\t\t来源链接：http://www.jianshu.com/p/665449c78c74\n\n- `getLocationOnScreen(int[2])`：计算该视图在Android坐标系中的x，y值，获取在当前屏幕内的绝对坐标（这个值是要从屏幕顶端算起，当然包括了通知栏和状态栏的高度）\n\n- `getLocationInWindow(int[2])`: 计算该视图在它所在的window的坐标x，y值，获取在整个window的绝对坐标\n\n\n```\n\t\t例如:\n\n\t\t    int[] location = new int[2];\n\t\t    view.getLocationOnScreen(location);\n\t\t    int x = location[0];\n\t\t    int y = location[1];\n\n```\n\n---","source":"_posts/Android之自定义控件——坐标.md","raw":"---\n\ntitle: Android 坐标与参数/对应函数\ncategories: \"android 总结\"\ntags: \n     - android\n     - View坐标\n     - 参数/对应函数\n \n---\n\n# View之坐标与参数/对应函数\n\n---\n\t\n\t目录:\n\n\t\t1. 坐标与坐标系\n\t\t\t- mLeft:\t\t\t\t以父容器左上为坐标原点,左上角X值\n\t\t\t- mRight:\t\t\t\t以父容器左上为坐标原点,右下角X值\n\t\t\t- mTop:\t\t\t\t\t以父容器左上为坐标原点,左上角Y值\n\t\t\t- mBottom:\t\t\t\t以父容器左上为坐标原点,右下角Y值\n\n\t\t\t注意: offsetLeftAndRight(int offset)与offsetTopAndBottom(int offset)\n\t\t\t用于View的平移.直接改变以上四个值\n\n\t\t\t- translationX:\t\t\t以父容器左上为坐标原点,X偏移量\t\t\n\t\t\t- translationY:\t\t\t以父容器左上为坐标原点,Y偏移量\n\n\t\t\t注意: 偏移量使用setTranslationX/Y(float),原相对于父容器的坐标不会发生变化,\n\t\t\tView通过坐标与偏移量的叠加进行绘制.\n\n\t\t\t- MotionEvent#getX():\t以当前View左上为坐标原点,触摸点X值\n\t\t\t- MotionEvent#getY():\t以当前View左上为坐标原点,触摸点Y值\n\t\t\t- MotionEvent#getRawX():以屏幕左上为坐标原点,触摸点X值\n\t\t\t- MotionEvent#getRawY():以屏幕左上为坐标原点,触摸点Y值\n\n\t\t\t注意: 与触摸事件相关.\n\n\t\t\t- mScrollX:\t\t\t\t与View位置无关,View内容相对于原状态X方向的滚动量\n\t\t\t- mScrollY:\t\t\t\t与View位置无关,View内容相对于原状态Y方向的滚动量\n\t\n\t\t\t注意: 向上/左,滚动量为正;反之为负.\n\n\t\t\t- mPaddingLeft\n\t\t\t- mPaddingRight\n\t\t\t- mPaddingTop\n\t\t\t- mPaddingBottom\n\n\n\t\n\t\t2. 参数与函数\n\t\t\t- width:\t\t\t\t\t   getRight() - getLeft()\n\t\t\t- height:\t\t\t\t\t  getBottom() - getTop()\n\t\t\t- measureWidth:\t\t\t\tmMeasuredWidth & MEASURED_SIZE_MASK\n\t\t\t- measureHeight:\t\t\t   mMeasuredHeight & MEASURED_SIZE_MASK\n\n\t\t\t注: >>> width/height 与 measureWidth/measureHeight 区别在于赋值时机不同,\n\t\t\t\t>>> measureWidth/measureHeight 形成于 measure 过程;\n\t\t\t\t>>> width/height 形成于 layout 过程;\n\n\t\t\t- getLocalVisibleRect(Rect)\n\t\t\t- getGlobalVisibleRect(Rect,Point)\n\t\t\t- getLocationOnScreen(int[2])\n\t\t\t- getLocationInWindow(int[2])\n\n\n\n---\n\n### 坐标与坐标系\n1. 坐标示意图如下:\n\n\t![坐标示意图](http://upload-images.jianshu.io/upload_images/3551332-ceab93bf82f135a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n2. 角度示意图如下:\n\n\t![角度坐标](http://upload-images.jianshu.io/upload_images/3846387-89827b3403db8137.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n3. 滚动量值示意图如下:\n\n\t![滚动量值](http://upload-images.jianshu.io/upload_images/1302497-a65d8640ea8029cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n---\n\n### 参数与函数 ###\n\n#### 1. 获得View相对于父容器/屏幕原点的偏移量 ####\n\n\t\t来源链接：http://www.jianshu.com/p/f09541b2f43b\n\n- `getLocalVisibleRect(Rect)`: 获取View在其父控件中的可见区域相对于此View的左顶点的距离（偏移量）；\n```\n\t\tRect localRect = new Rect();\n        v.getLocalVisibleRect(localRect);\n        ((TextView) findViewById(R.id.local)).setText(\"local\" + localRect.toString());\n\t\t//显示左上和右下两个点的相对坐标\n```\n\n- `getGlobalVisibleRect(Rect,Point)`: 获取View在其父控件中的可见区域相对于屏幕左顶点的距离（偏移量）；\n```\n\t\tRect globalRect = new Rect();\n        Point globalOffset = new Point();\n        v.getGlobalVisibleRect(globalRect, globalOffset);\n        ((TextView) findViewById(R.id.global)).setText(\"global\" + globalRect.toString());\n        ((TextView) findViewById(R.id.offset)).setText(\"globalOffset:\" + globalOffset.x + \",\" + globalOffset.y);\n```\n\n\n#### 2. 绝对坐标 ####\n\t\n\t\t来源链接：http://www.jianshu.com/p/665449c78c74\n\n- `getLocationOnScreen(int[2])`：计算该视图在Android坐标系中的x，y值，获取在当前屏幕内的绝对坐标（这个值是要从屏幕顶端算起，当然包括了通知栏和状态栏的高度）\n\n- `getLocationInWindow(int[2])`: 计算该视图在它所在的window的坐标x，y值，获取在整个window的绝对坐标\n\n\n```\n\t\t例如:\n\n\t\t    int[] location = new int[2];\n\t\t    view.getLocationOnScreen(location);\n\t\t    int x = location[0];\n\t\t    int y = location[1];\n\n```\n\n---","slug":"Android之自定义控件——坐标","published":1,"date":"2018-03-21T05:35:40.027Z","updated":"2018-03-21T05:23:08.600Z","_id":"cjf0kjqjd000i0s4lwr54y1r1","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"View之坐标与参数-对应函数\"><a href=\"#View之坐标与参数-对应函数\" class=\"headerlink\" title=\"View之坐标与参数/对应函数\"></a>View之坐标与参数/对应函数</h1><hr>\n<pre><code>目录:\n\n    1. 坐标与坐标系\n        - mLeft:                以父容器左上为坐标原点,左上角X值\n        - mRight:                以父容器左上为坐标原点,右下角X值\n        - mTop:                    以父容器左上为坐标原点,左上角Y值\n        - mBottom:                以父容器左上为坐标原点,右下角Y值\n\n        注意: offsetLeftAndRight(int offset)与offsetTopAndBottom(int offset)\n        用于View的平移.直接改变以上四个值\n\n        - translationX:            以父容器左上为坐标原点,X偏移量        \n        - translationY:            以父容器左上为坐标原点,Y偏移量\n\n        注意: 偏移量使用setTranslationX/Y(float),原相对于父容器的坐标不会发生变化,\n        View通过坐标与偏移量的叠加进行绘制.\n\n        - MotionEvent#getX():    以当前View左上为坐标原点,触摸点X值\n        - MotionEvent#getY():    以当前View左上为坐标原点,触摸点Y值\n        - MotionEvent#getRawX():以屏幕左上为坐标原点,触摸点X值\n        - MotionEvent#getRawY():以屏幕左上为坐标原点,触摸点Y值\n\n        注意: 与触摸事件相关.\n\n        - mScrollX:                与View位置无关,View内容相对于原状态X方向的滚动量\n        - mScrollY:                与View位置无关,View内容相对于原状态Y方向的滚动量\n\n        注意: 向上/左,滚动量为正;反之为负.\n\n        - mPaddingLeft\n        - mPaddingRight\n        - mPaddingTop\n        - mPaddingBottom\n\n\n\n    2. 参数与函数\n        - width:                       getRight() - getLeft()\n        - height:                      getBottom() - getTop()\n        - measureWidth:                mMeasuredWidth &amp; MEASURED_SIZE_MASK\n        - measureHeight:               mMeasuredHeight &amp; MEASURED_SIZE_MASK\n\n        注: &gt;&gt;&gt; width/height 与 measureWidth/measureHeight 区别在于赋值时机不同,\n            &gt;&gt;&gt; measureWidth/measureHeight 形成于 measure 过程;\n            &gt;&gt;&gt; width/height 形成于 layout 过程;\n\n        - getLocalVisibleRect(Rect)\n        - getGlobalVisibleRect(Rect,Point)\n        - getLocationOnScreen(int[2])\n        - getLocationInWindow(int[2])\n</code></pre><hr>\n<h3 id=\"坐标与坐标系\"><a href=\"#坐标与坐标系\" class=\"headerlink\" title=\"坐标与坐标系\"></a>坐标与坐标系</h3><ol>\n<li><p>坐标示意图如下:</p>\n<p> <img src=\"http://upload-images.jianshu.io/upload_images/3551332-ceab93bf82f135a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"坐标示意图\"></p>\n</li>\n<li><p>角度示意图如下:</p>\n<p> <img src=\"http://upload-images.jianshu.io/upload_images/3846387-89827b3403db8137.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"角度坐标\"></p>\n</li>\n<li><p>滚动量值示意图如下:</p>\n<p> <img src=\"http://upload-images.jianshu.io/upload_images/1302497-a65d8640ea8029cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"滚动量值\"></p>\n</li>\n</ol>\n<hr>\n<h3 id=\"参数与函数\"><a href=\"#参数与函数\" class=\"headerlink\" title=\"参数与函数\"></a>参数与函数</h3><h4 id=\"1-获得View相对于父容器-屏幕原点的偏移量\"><a href=\"#1-获得View相对于父容器-屏幕原点的偏移量\" class=\"headerlink\" title=\"1. 获得View相对于父容器/屏幕原点的偏移量\"></a>1. 获得View相对于父容器/屏幕原点的偏移量</h4><pre><code>来源链接：http://www.jianshu.com/p/f09541b2f43b\n</code></pre><ul>\n<li><p><code>getLocalVisibleRect(Rect)</code>: 获取View在其父控件中的可见区域相对于此View的左顶点的距离（偏移量）；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Rect localRect = new Rect();</span><br><span class=\"line\">      v.getLocalVisibleRect(localRect);</span><br><span class=\"line\">      ((TextView) findViewById(R.id.local)).setText(&quot;local&quot; + localRect.toString());</span><br><span class=\"line\">//显示左上和右下两个点的相对坐标</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>getGlobalVisibleRect(Rect,Point)</code>: 获取View在其父控件中的可见区域相对于屏幕左顶点的距离（偏移量）；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Rect globalRect = new Rect();</span><br><span class=\"line\">      Point globalOffset = new Point();</span><br><span class=\"line\">      v.getGlobalVisibleRect(globalRect, globalOffset);</span><br><span class=\"line\">      ((TextView) findViewById(R.id.global)).setText(&quot;global&quot; + globalRect.toString());</span><br><span class=\"line\">      ((TextView) findViewById(R.id.offset)).setText(&quot;globalOffset:&quot; + globalOffset.x + &quot;,&quot; + globalOffset.y);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"2-绝对坐标\"><a href=\"#2-绝对坐标\" class=\"headerlink\" title=\"2. 绝对坐标\"></a>2. 绝对坐标</h4><pre><code>来源链接：http://www.jianshu.com/p/665449c78c74\n</code></pre><ul>\n<li><p><code>getLocationOnScreen(int[2])</code>：计算该视图在Android坐标系中的x，y值，获取在当前屏幕内的绝对坐标（这个值是要从屏幕顶端算起，当然包括了通知栏和状态栏的高度）</p>\n</li>\n<li><p><code>getLocationInWindow(int[2])</code>: 计算该视图在它所在的window的坐标x，y值，获取在整个window的绝对坐标</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例如:</span><br><span class=\"line\"></span><br><span class=\"line\">    int[] location = new int[2];</span><br><span class=\"line\">    view.getLocationOnScreen(location);</span><br><span class=\"line\">    int x = location[0];</span><br><span class=\"line\">    int y = location[1];</span><br></pre></td></tr></table></figure>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"View之坐标与参数-对应函数\"><a href=\"#View之坐标与参数-对应函数\" class=\"headerlink\" title=\"View之坐标与参数/对应函数\"></a>View之坐标与参数/对应函数</h1><hr>\n<pre><code>目录:\n\n    1. 坐标与坐标系\n        - mLeft:                以父容器左上为坐标原点,左上角X值\n        - mRight:                以父容器左上为坐标原点,右下角X值\n        - mTop:                    以父容器左上为坐标原点,左上角Y值\n        - mBottom:                以父容器左上为坐标原点,右下角Y值\n\n        注意: offsetLeftAndRight(int offset)与offsetTopAndBottom(int offset)\n        用于View的平移.直接改变以上四个值\n\n        - translationX:            以父容器左上为坐标原点,X偏移量        \n        - translationY:            以父容器左上为坐标原点,Y偏移量\n\n        注意: 偏移量使用setTranslationX/Y(float),原相对于父容器的坐标不会发生变化,\n        View通过坐标与偏移量的叠加进行绘制.\n\n        - MotionEvent#getX():    以当前View左上为坐标原点,触摸点X值\n        - MotionEvent#getY():    以当前View左上为坐标原点,触摸点Y值\n        - MotionEvent#getRawX():以屏幕左上为坐标原点,触摸点X值\n        - MotionEvent#getRawY():以屏幕左上为坐标原点,触摸点Y值\n\n        注意: 与触摸事件相关.\n\n        - mScrollX:                与View位置无关,View内容相对于原状态X方向的滚动量\n        - mScrollY:                与View位置无关,View内容相对于原状态Y方向的滚动量\n\n        注意: 向上/左,滚动量为正;反之为负.\n\n        - mPaddingLeft\n        - mPaddingRight\n        - mPaddingTop\n        - mPaddingBottom\n\n\n\n    2. 参数与函数\n        - width:                       getRight() - getLeft()\n        - height:                      getBottom() - getTop()\n        - measureWidth:                mMeasuredWidth &amp; MEASURED_SIZE_MASK\n        - measureHeight:               mMeasuredHeight &amp; MEASURED_SIZE_MASK\n\n        注: &gt;&gt;&gt; width/height 与 measureWidth/measureHeight 区别在于赋值时机不同,\n            &gt;&gt;&gt; measureWidth/measureHeight 形成于 measure 过程;\n            &gt;&gt;&gt; width/height 形成于 layout 过程;\n\n        - getLocalVisibleRect(Rect)\n        - getGlobalVisibleRect(Rect,Point)\n        - getLocationOnScreen(int[2])\n        - getLocationInWindow(int[2])\n</code></pre><hr>\n<h3 id=\"坐标与坐标系\"><a href=\"#坐标与坐标系\" class=\"headerlink\" title=\"坐标与坐标系\"></a>坐标与坐标系</h3><ol>\n<li><p>坐标示意图如下:</p>\n<p> <img src=\"http://upload-images.jianshu.io/upload_images/3551332-ceab93bf82f135a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"坐标示意图\"></p>\n</li>\n<li><p>角度示意图如下:</p>\n<p> <img src=\"http://upload-images.jianshu.io/upload_images/3846387-89827b3403db8137.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"角度坐标\"></p>\n</li>\n<li><p>滚动量值示意图如下:</p>\n<p> <img src=\"http://upload-images.jianshu.io/upload_images/1302497-a65d8640ea8029cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"滚动量值\"></p>\n</li>\n</ol>\n<hr>\n<h3 id=\"参数与函数\"><a href=\"#参数与函数\" class=\"headerlink\" title=\"参数与函数\"></a>参数与函数</h3><h4 id=\"1-获得View相对于父容器-屏幕原点的偏移量\"><a href=\"#1-获得View相对于父容器-屏幕原点的偏移量\" class=\"headerlink\" title=\"1. 获得View相对于父容器/屏幕原点的偏移量\"></a>1. 获得View相对于父容器/屏幕原点的偏移量</h4><pre><code>来源链接：http://www.jianshu.com/p/f09541b2f43b\n</code></pre><ul>\n<li><p><code>getLocalVisibleRect(Rect)</code>: 获取View在其父控件中的可见区域相对于此View的左顶点的距离（偏移量）；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Rect localRect = new Rect();</span><br><span class=\"line\">      v.getLocalVisibleRect(localRect);</span><br><span class=\"line\">      ((TextView) findViewById(R.id.local)).setText(&quot;local&quot; + localRect.toString());</span><br><span class=\"line\">//显示左上和右下两个点的相对坐标</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>getGlobalVisibleRect(Rect,Point)</code>: 获取View在其父控件中的可见区域相对于屏幕左顶点的距离（偏移量）；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Rect globalRect = new Rect();</span><br><span class=\"line\">      Point globalOffset = new Point();</span><br><span class=\"line\">      v.getGlobalVisibleRect(globalRect, globalOffset);</span><br><span class=\"line\">      ((TextView) findViewById(R.id.global)).setText(&quot;global&quot; + globalRect.toString());</span><br><span class=\"line\">      ((TextView) findViewById(R.id.offset)).setText(&quot;globalOffset:&quot; + globalOffset.x + &quot;,&quot; + globalOffset.y);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"2-绝对坐标\"><a href=\"#2-绝对坐标\" class=\"headerlink\" title=\"2. 绝对坐标\"></a>2. 绝对坐标</h4><pre><code>来源链接：http://www.jianshu.com/p/665449c78c74\n</code></pre><ul>\n<li><p><code>getLocationOnScreen(int[2])</code>：计算该视图在Android坐标系中的x，y值，获取在当前屏幕内的绝对坐标（这个值是要从屏幕顶端算起，当然包括了通知栏和状态栏的高度）</p>\n</li>\n<li><p><code>getLocationInWindow(int[2])</code>: 计算该视图在它所在的window的坐标x，y值，获取在整个window的绝对坐标</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例如:</span><br><span class=\"line\"></span><br><span class=\"line\">    int[] location = new int[2];</span><br><span class=\"line\">    view.getLocationOnScreen(location);</span><br><span class=\"line\">    int x = location[0];</span><br><span class=\"line\">    int y = location[1];</span><br></pre></td></tr></table></figure>\n<hr>\n"},{"_content":"# HTTP/HTTPS 基础与版本 #\n\n---\n\n\t目录:\n\t\t- http\n\t\t\t- 原理\n\t\t\t- 结构\n\t\t\t- 请求报文格式\n\t\t\t- 答复报文格式\n\t\t\t- 状态码\n\t\t\t- 版本\n\t\t- http与https的区别\n\t\t- https\n\t\t\t- 优点\n\t\t\t- 加密\n\t\t\t\n\n\n---\n### HTTP(HyperText Transport Protocol) ###\n\t\t超文本(超过计算机处理文本信息的方法)传输协议,最初为了提供发布和接收html页面的方法,运行在TCP/IP协议簇之上;\n\t\t服务器=html+http驻留程序(用于响应用户请求)\n\n1. 1.0处理完请求之后就会释放连接;\n2. 1.1请求可以多次重叠;\n3. 客户端固定时间段向服务器发送保持连接请求,服务器收到请求后回复确认客户端在线;当长时间没有收到请求,则认为网络已经断开.\n\n\n#### 原理 ####\n\n\n1. **首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作就开始了。**\n\n2. **建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。**\n\n3. **服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。**\n\n4. **客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。**\n\n\n#### 结构 ####\n\n\n\t\t- 模型: 请求/响应模型.\n\t\t- 请求头包含:\n\t\t\t- 请求的方法\n\t\t\t- URL\n\t\t\t- 协议版本\n\t\t\t- 类似于MIME的消息结构\n\t\t\t\t- 请求修饰符\n\t\t\t\t- 客户信息\n\t\t\t\t- 内容\n\t\t- 响应包含:\n\t\t\t- 消息协议的版本\n\t\t\t- 成功/错误编码\n\t\t\t- 包含服务器信息、实体元信息以及可能的实体内容。\n\t\t- 请求/响应内容包括:\n\t\t\t- 一个起始行\n\t\t\t- 一个或者多个头域\n\t\t\t\t- 通用头\n\t\t\t\t- 请求头\n\t\t\t\t- 响应头\n\t\t\t\t- 实体头\n\t\t\t- 一个指示头域结束的空行\n\t\t\t- 可选的消息体\n\n#### 请求报文格式 ####\n\n\t\t请求行 － 通用信息头 － 请求头 － 实体头 － 报文主体\n\n\t\t请求行以方法字段开始，后面分别是 URL 字段和 HTTP 协议版本字段，并以 CRLF 结尾。\n\t\tSP 是分隔符。除了在最后的 CRLF 序列中 CF 和 LF 是必需的之外，其他都可以不要。\n\t\t有关通用信息头，请求头和实体头方面的具体内容可以参照相关文件。\n#### 应答报文格式 ####\n\n\t\t状态行 － 通用信息头 － 响应头 － 实体头 － 报文主体\n\n\t\t状态码元由3位数字组成，表示请求是否被理解或被满足。原因分析是对原文的状态码作简短的描述，\n\t\t状态码用来支持自动操作，而原因分析用来供用户使用。客户机无需用来检查或显示语法。\n\t\t有关通用信息头，响应头和实体头方面的具体内容可以参照相关文件。\n\n\n#### 状态码 ####\n\n\t\t1xx: 信息响应类，表示接收到请求并且继续处理\n\t\t2xx: 处理成功响应类，表示动作被成功接收、理解和接受\n\t\t3xx: 重定向响应类，为了完成指定的动作，必须接受进一步处理\n\t\t4xx: 客户端错误，客户请求包含语法错误或者是不能正确执行\n\t\t5xx: 服务端错误，服务器不能正确执行一个正确的请求\n\n\n#### 版本 ####\n\n\t\tHTTP/0.9　已过时。只接受 GET 一种请求方法，没有在通讯中指定版本号，且不支持请求头。\n\t\t\t\t由于该版本不支持 POST 方法，所以客户端无法向服务器传递太多信息。\n\t\tHTTP/1.0　这是第一个在通讯中指定版本号的HTTP 协议版本，至今仍被广泛采用，特别是在代理服务器中。\n\t\tHTTP/1.1　当前版本。持久连接被默认采用，并能很好地配合代理服务器工作。\n\t\t\t\t还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。\n\n---\n\n### HTTPS 与 HTTP 的区别 ###\n\n- 证书: HTTPS有需要缴费的**ca证书**；\n- 端口: HTTPS使用**443端口**,HTTP使用80端口；\n- 安全: HTTPS有作为**应用层子层的,加密传输,身份认证**的SSL层;HTTP是位于传输层，明文传输，无状态无记忆能力的连接；\n---\n### HTTPS(Hyper Text Transfer Protocol over Secure Socket Layer) ###\n\n\t\t加入SSL层,以安全为目标的HTTP通道。\n\n\t\t以安全为目标的HTTP通道,添加的内容是SSl完全套接字层,主要进行详细内容的加密,Https存在不同于Http的默认端口,在Http和TCP之间还有加密/身份证明层,本来用于身份证明和加密通讯方法.\n\t\t\t\n\t\t　　客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。\n\n\t\t\t\t（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。\n\t\t\t\t\n\t\t\t\t（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。\n\t\t\t\t\n\t\t\t\t（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。\n\t\t\t\t\n\t\t\t\t（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。\n\t\t\t\t\n\t\t\t\t（5）Web服务器利用自己的私钥解密出会话密钥。\n\t\t\t\t\n\t\t\t\t（6）Web服务器利用会话密钥加密与客户端之间的通信。\n\n#### SSL层原理 ####\n\n\n1. SSL 协议既用到了<font color = \"red\">**公钥加密技术**</font>又用到了<font color = \"red\">**对称加密技术**</font>，对称加密技术虽然比公钥加密技术的速度快，可是公钥加密技术提供了更好的身份认证技术。\n\n2. 分为两层:\n\n\t- SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供<font color = \"red\">**数据封装、压缩、加密**</font>等基本功能的支持。\n\t- SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于<font color = \"red\">在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</font>\n\n3. 工作流程\n\n\t1. 客户端Client: 向服务器发送一个开始信息“Hello”以便开始一个新的会话连接；\n\t2. 服务器Server: 根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的“Hello”信息时将包含生成主密钥所需的信息；\n\t3. 客户端Client: 根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器；\n\t4. 服务器Server: 恢复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。\n\t\t\n\n\t\t\n\t\t\t注:在此之前，服务器已经通过了客户认证，这一阶段主要完成对客户的认证。\n\t\t\t经认证的服务器发送一个提问给客户，客户则返回（数字）签名后的提问和其公开密钥，\n\t\t\t从而向服务器提供认证。\n\n#### 握手过程 ####\n\n为了便于更好的认识和理解SSL 协议，这里着重介绍SSL 协议的握手协议。SSL 协议既用到了公钥加密技术又用到了对称加密技术，对称加密技术虽然比公钥加密技术的速度快，可是公钥加密技术提供了更好的身份认证技术。SSL 的握手协议非常有效的让客户和服务器之间完成相互之间的身份认证，其主要过程如下：\n\n\t1. 客户端的浏览器向服务器传送客户端SSL 协议的版本号，加密算法的种类，产生的随机数，\n\t\t以及其他服务器和客户端之间通讯所需要的各种信息。\n\n\t2. 服务器向客户端传送SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，\n\t\t同时服务器还将向客户端传送自己的证书。\n\n\t3. 客户利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，\n\t发行服务器证书的CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，\n\t服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；\n\t如果合法性验证通过，将继续进行第四步。\n\n\t4. 用户端随机产生一个用于后面通讯的“对称密码”，然后用服务器的公钥（服务器的公钥从步骤②中的\n\t服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。\n\n\t5. 如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，\n\t将这个含有签名的随机数和客户自己的证书以及加密过的“预主密码”一起传给服务器。\n\n\t6. 如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：\n\t客户的证书使用日期是否有效，为客户提供证书的CA 是否可靠，发行CA 的公钥能否正确解开客户证书\n\t的发行CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，\n\t通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的“预主密码”，\n\t然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。\n\n\t7. 服务器和客户端用相同的主密码即“通话密码”，一个对称密钥用于SSL协议的安全数据通讯的\n\t加解密通讯。同时在SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。\n\n\t8. 客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，\n\t同时通知服务器客户端的握手过程结束。\n\n\t9. 服务器向客户端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，\n\t同时通知客户端服务器端的握手过程结束。\n\n\t10. SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥\n\t进行数据通讯，同时进行通讯完整性的检验。\n\n\n---\n","source":"_posts/Android之通信——HTTP,HTTPS.md","raw":"# HTTP/HTTPS 基础与版本 #\n\n---\n\n\t目录:\n\t\t- http\n\t\t\t- 原理\n\t\t\t- 结构\n\t\t\t- 请求报文格式\n\t\t\t- 答复报文格式\n\t\t\t- 状态码\n\t\t\t- 版本\n\t\t- http与https的区别\n\t\t- https\n\t\t\t- 优点\n\t\t\t- 加密\n\t\t\t\n\n\n---\n### HTTP(HyperText Transport Protocol) ###\n\t\t超文本(超过计算机处理文本信息的方法)传输协议,最初为了提供发布和接收html页面的方法,运行在TCP/IP协议簇之上;\n\t\t服务器=html+http驻留程序(用于响应用户请求)\n\n1. 1.0处理完请求之后就会释放连接;\n2. 1.1请求可以多次重叠;\n3. 客户端固定时间段向服务器发送保持连接请求,服务器收到请求后回复确认客户端在线;当长时间没有收到请求,则认为网络已经断开.\n\n\n#### 原理 ####\n\n\n1. **首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作就开始了。**\n\n2. **建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。**\n\n3. **服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。**\n\n4. **客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。**\n\n\n#### 结构 ####\n\n\n\t\t- 模型: 请求/响应模型.\n\t\t- 请求头包含:\n\t\t\t- 请求的方法\n\t\t\t- URL\n\t\t\t- 协议版本\n\t\t\t- 类似于MIME的消息结构\n\t\t\t\t- 请求修饰符\n\t\t\t\t- 客户信息\n\t\t\t\t- 内容\n\t\t- 响应包含:\n\t\t\t- 消息协议的版本\n\t\t\t- 成功/错误编码\n\t\t\t- 包含服务器信息、实体元信息以及可能的实体内容。\n\t\t- 请求/响应内容包括:\n\t\t\t- 一个起始行\n\t\t\t- 一个或者多个头域\n\t\t\t\t- 通用头\n\t\t\t\t- 请求头\n\t\t\t\t- 响应头\n\t\t\t\t- 实体头\n\t\t\t- 一个指示头域结束的空行\n\t\t\t- 可选的消息体\n\n#### 请求报文格式 ####\n\n\t\t请求行 － 通用信息头 － 请求头 － 实体头 － 报文主体\n\n\t\t请求行以方法字段开始，后面分别是 URL 字段和 HTTP 协议版本字段，并以 CRLF 结尾。\n\t\tSP 是分隔符。除了在最后的 CRLF 序列中 CF 和 LF 是必需的之外，其他都可以不要。\n\t\t有关通用信息头，请求头和实体头方面的具体内容可以参照相关文件。\n#### 应答报文格式 ####\n\n\t\t状态行 － 通用信息头 － 响应头 － 实体头 － 报文主体\n\n\t\t状态码元由3位数字组成，表示请求是否被理解或被满足。原因分析是对原文的状态码作简短的描述，\n\t\t状态码用来支持自动操作，而原因分析用来供用户使用。客户机无需用来检查或显示语法。\n\t\t有关通用信息头，响应头和实体头方面的具体内容可以参照相关文件。\n\n\n#### 状态码 ####\n\n\t\t1xx: 信息响应类，表示接收到请求并且继续处理\n\t\t2xx: 处理成功响应类，表示动作被成功接收、理解和接受\n\t\t3xx: 重定向响应类，为了完成指定的动作，必须接受进一步处理\n\t\t4xx: 客户端错误，客户请求包含语法错误或者是不能正确执行\n\t\t5xx: 服务端错误，服务器不能正确执行一个正确的请求\n\n\n#### 版本 ####\n\n\t\tHTTP/0.9　已过时。只接受 GET 一种请求方法，没有在通讯中指定版本号，且不支持请求头。\n\t\t\t\t由于该版本不支持 POST 方法，所以客户端无法向服务器传递太多信息。\n\t\tHTTP/1.0　这是第一个在通讯中指定版本号的HTTP 协议版本，至今仍被广泛采用，特别是在代理服务器中。\n\t\tHTTP/1.1　当前版本。持久连接被默认采用，并能很好地配合代理服务器工作。\n\t\t\t\t还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。\n\n---\n\n### HTTPS 与 HTTP 的区别 ###\n\n- 证书: HTTPS有需要缴费的**ca证书**；\n- 端口: HTTPS使用**443端口**,HTTP使用80端口；\n- 安全: HTTPS有作为**应用层子层的,加密传输,身份认证**的SSL层;HTTP是位于传输层，明文传输，无状态无记忆能力的连接；\n---\n### HTTPS(Hyper Text Transfer Protocol over Secure Socket Layer) ###\n\n\t\t加入SSL层,以安全为目标的HTTP通道。\n\n\t\t以安全为目标的HTTP通道,添加的内容是SSl完全套接字层,主要进行详细内容的加密,Https存在不同于Http的默认端口,在Http和TCP之间还有加密/身份证明层,本来用于身份证明和加密通讯方法.\n\t\t\t\n\t\t　　客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。\n\n\t\t\t\t（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。\n\t\t\t\t\n\t\t\t\t（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。\n\t\t\t\t\n\t\t\t\t（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。\n\t\t\t\t\n\t\t\t\t（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。\n\t\t\t\t\n\t\t\t\t（5）Web服务器利用自己的私钥解密出会话密钥。\n\t\t\t\t\n\t\t\t\t（6）Web服务器利用会话密钥加密与客户端之间的通信。\n\n#### SSL层原理 ####\n\n\n1. SSL 协议既用到了<font color = \"red\">**公钥加密技术**</font>又用到了<font color = \"red\">**对称加密技术**</font>，对称加密技术虽然比公钥加密技术的速度快，可是公钥加密技术提供了更好的身份认证技术。\n\n2. 分为两层:\n\n\t- SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供<font color = \"red\">**数据封装、压缩、加密**</font>等基本功能的支持。\n\t- SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于<font color = \"red\">在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</font>\n\n3. 工作流程\n\n\t1. 客户端Client: 向服务器发送一个开始信息“Hello”以便开始一个新的会话连接；\n\t2. 服务器Server: 根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的“Hello”信息时将包含生成主密钥所需的信息；\n\t3. 客户端Client: 根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器；\n\t4. 服务器Server: 恢复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。\n\t\t\n\n\t\t\n\t\t\t注:在此之前，服务器已经通过了客户认证，这一阶段主要完成对客户的认证。\n\t\t\t经认证的服务器发送一个提问给客户，客户则返回（数字）签名后的提问和其公开密钥，\n\t\t\t从而向服务器提供认证。\n\n#### 握手过程 ####\n\n为了便于更好的认识和理解SSL 协议，这里着重介绍SSL 协议的握手协议。SSL 协议既用到了公钥加密技术又用到了对称加密技术，对称加密技术虽然比公钥加密技术的速度快，可是公钥加密技术提供了更好的身份认证技术。SSL 的握手协议非常有效的让客户和服务器之间完成相互之间的身份认证，其主要过程如下：\n\n\t1. 客户端的浏览器向服务器传送客户端SSL 协议的版本号，加密算法的种类，产生的随机数，\n\t\t以及其他服务器和客户端之间通讯所需要的各种信息。\n\n\t2. 服务器向客户端传送SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，\n\t\t同时服务器还将向客户端传送自己的证书。\n\n\t3. 客户利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，\n\t发行服务器证书的CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，\n\t服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；\n\t如果合法性验证通过，将继续进行第四步。\n\n\t4. 用户端随机产生一个用于后面通讯的“对称密码”，然后用服务器的公钥（服务器的公钥从步骤②中的\n\t服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。\n\n\t5. 如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，\n\t将这个含有签名的随机数和客户自己的证书以及加密过的“预主密码”一起传给服务器。\n\n\t6. 如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：\n\t客户的证书使用日期是否有效，为客户提供证书的CA 是否可靠，发行CA 的公钥能否正确解开客户证书\n\t的发行CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，\n\t通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的“预主密码”，\n\t然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。\n\n\t7. 服务器和客户端用相同的主密码即“通话密码”，一个对称密钥用于SSL协议的安全数据通讯的\n\t加解密通讯。同时在SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。\n\n\t8. 客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，\n\t同时通知服务器客户端的握手过程结束。\n\n\t9. 服务器向客户端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，\n\t同时通知客户端服务器端的握手过程结束。\n\n\t10. SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥\n\t进行数据通讯，同时进行通讯完整性的检验。\n\n\n---\n","slug":"Android之通信——HTTP,HTTPS","published":1,"date":"2018-03-21T03:22:18.409Z","updated":"2017-12-13T02:13:57.260Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0kjqje000j0s4lbs5tdvwr","content":"<h1 id=\"HTTP-HTTPS-基础与版本\"><a href=\"#HTTP-HTTPS-基础与版本\" class=\"headerlink\" title=\"HTTP/HTTPS 基础与版本\"></a>HTTP/HTTPS 基础与版本</h1><hr>\n<pre><code>目录:\n    - http\n        - 原理\n        - 结构\n        - 请求报文格式\n        - 答复报文格式\n        - 状态码\n        - 版本\n    - http与https的区别\n    - https\n        - 优点\n        - 加密\n</code></pre><hr>\n<h3 id=\"HTTP-HyperText-Transport-Protocol\"><a href=\"#HTTP-HyperText-Transport-Protocol\" class=\"headerlink\" title=\"HTTP(HyperText Transport Protocol)\"></a>HTTP(HyperText Transport Protocol)</h3><pre><code>超文本(超过计算机处理文本信息的方法)传输协议,最初为了提供发布和接收html页面的方法,运行在TCP/IP协议簇之上;\n服务器=html+http驻留程序(用于响应用户请求)\n</code></pre><ol>\n<li>1.0处理完请求之后就会释放连接;</li>\n<li>1.1请求可以多次重叠;</li>\n<li>客户端固定时间段向服务器发送保持连接请求,服务器收到请求后回复确认客户端在线;当长时间没有收到请求,则认为网络已经断开.</li>\n</ol>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><ol>\n<li><p><strong>首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作就开始了。</strong></p>\n</li>\n<li><p><strong>建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。</strong></p>\n</li>\n<li><p><strong>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</strong></p>\n</li>\n<li><p><strong>客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。</strong></p>\n</li>\n</ol>\n<h4 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h4><pre><code>- 模型: 请求/响应模型.\n- 请求头包含:\n    - 请求的方法\n    - URL\n    - 协议版本\n    - 类似于MIME的消息结构\n        - 请求修饰符\n        - 客户信息\n        - 内容\n- 响应包含:\n    - 消息协议的版本\n    - 成功/错误编码\n    - 包含服务器信息、实体元信息以及可能的实体内容。\n- 请求/响应内容包括:\n    - 一个起始行\n    - 一个或者多个头域\n        - 通用头\n        - 请求头\n        - 响应头\n        - 实体头\n    - 一个指示头域结束的空行\n    - 可选的消息体\n</code></pre><h4 id=\"请求报文格式\"><a href=\"#请求报文格式\" class=\"headerlink\" title=\"请求报文格式\"></a>请求报文格式</h4><pre><code>请求行 － 通用信息头 － 请求头 － 实体头 － 报文主体\n\n请求行以方法字段开始，后面分别是 URL 字段和 HTTP 协议版本字段，并以 CRLF 结尾。\nSP 是分隔符。除了在最后的 CRLF 序列中 CF 和 LF 是必需的之外，其他都可以不要。\n有关通用信息头，请求头和实体头方面的具体内容可以参照相关文件。\n</code></pre><h4 id=\"应答报文格式\"><a href=\"#应答报文格式\" class=\"headerlink\" title=\"应答报文格式\"></a>应答报文格式</h4><pre><code>状态行 － 通用信息头 － 响应头 － 实体头 － 报文主体\n\n状态码元由3位数字组成，表示请求是否被理解或被满足。原因分析是对原文的状态码作简短的描述，\n状态码用来支持自动操作，而原因分析用来供用户使用。客户机无需用来检查或显示语法。\n有关通用信息头，响应头和实体头方面的具体内容可以参照相关文件。\n</code></pre><h4 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h4><pre><code>1xx: 信息响应类，表示接收到请求并且继续处理\n2xx: 处理成功响应类，表示动作被成功接收、理解和接受\n3xx: 重定向响应类，为了完成指定的动作，必须接受进一步处理\n4xx: 客户端错误，客户请求包含语法错误或者是不能正确执行\n5xx: 服务端错误，服务器不能正确执行一个正确的请求\n</code></pre><h4 id=\"版本\"><a href=\"#版本\" class=\"headerlink\" title=\"版本\"></a>版本</h4><pre><code>HTTP/0.9　已过时。只接受 GET 一种请求方法，没有在通讯中指定版本号，且不支持请求头。\n        由于该版本不支持 POST 方法，所以客户端无法向服务器传递太多信息。\nHTTP/1.0　这是第一个在通讯中指定版本号的HTTP 协议版本，至今仍被广泛采用，特别是在代理服务器中。\nHTTP/1.1　当前版本。持久连接被默认采用，并能很好地配合代理服务器工作。\n        还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。\n</code></pre><hr>\n<h3 id=\"HTTPS-与-HTTP-的区别\"><a href=\"#HTTPS-与-HTTP-的区别\" class=\"headerlink\" title=\"HTTPS 与 HTTP 的区别\"></a>HTTPS 与 HTTP 的区别</h3><ul>\n<li>证书: HTTPS有需要缴费的<strong>ca证书</strong>；</li>\n<li>端口: HTTPS使用<strong>443端口</strong>,HTTP使用80端口；</li>\n<li>安全: HTTPS有作为<strong>应用层子层的,加密传输,身份认证</strong>的SSL层;HTTP是位于传输层，明文传输，无状态无记忆能力的连接；</li>\n</ul>\n<hr>\n<h3 id=\"HTTPS-Hyper-Text-Transfer-Protocol-over-Secure-Socket-Layer\"><a href=\"#HTTPS-Hyper-Text-Transfer-Protocol-over-Secure-Socket-Layer\" class=\"headerlink\" title=\"HTTPS(Hyper Text Transfer Protocol over Secure Socket Layer)\"></a>HTTPS(Hyper Text Transfer Protocol over Secure Socket Layer)</h3><pre><code>加入SSL层,以安全为目标的HTTP通道。\n\n以安全为目标的HTTP通道,添加的内容是SSl完全套接字层,主要进行详细内容的加密,Https存在不同于Http的默认端口,在Http和TCP之间还有加密/身份证明层,本来用于身份证明和加密通讯方法.\n\n　　客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。\n\n        （1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。\n\n        （2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。\n\n        （3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。\n\n        （4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。\n\n        （5）Web服务器利用自己的私钥解密出会话密钥。\n\n        （6）Web服务器利用会话密钥加密与客户端之间的通信。\n</code></pre><h4 id=\"SSL层原理\"><a href=\"#SSL层原理\" class=\"headerlink\" title=\"SSL层原理\"></a>SSL层原理</h4><ol>\n<li><p>SSL 协议既用到了<font color=\"red\"><strong>公钥加密技术</strong></font>又用到了<font color=\"red\"><strong>对称加密技术</strong></font>，对称加密技术虽然比公钥加密技术的速度快，可是公钥加密技术提供了更好的身份认证技术。</p>\n</li>\n<li><p>分为两层:</p>\n<ul>\n<li>SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供<font color=\"red\"><strong>数据封装、压缩、加密</strong></font>等基本功能的支持。</li>\n<li>SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于<font color=\"red\">在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</font></li>\n</ul>\n</li>\n<li><p>工作流程</p>\n<ol>\n<li>客户端Client: 向服务器发送一个开始信息“Hello”以便开始一个新的会话连接；</li>\n<li>服务器Server: 根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的“Hello”信息时将包含生成主密钥所需的信息；</li>\n<li>客户端Client: 根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器；</li>\n<li>服务器Server: 恢复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。</li>\n</ol>\n</li>\n</ol>\n<pre><code>注:在此之前，服务器已经通过了客户认证，这一阶段主要完成对客户的认证。\n经认证的服务器发送一个提问给客户，客户则返回（数字）签名后的提问和其公开密钥，\n从而向服务器提供认证。\n</code></pre><h4 id=\"握手过程\"><a href=\"#握手过程\" class=\"headerlink\" title=\"握手过程\"></a>握手过程</h4><p>为了便于更好的认识和理解SSL 协议，这里着重介绍SSL 协议的握手协议。SSL 协议既用到了公钥加密技术又用到了对称加密技术，对称加密技术虽然比公钥加密技术的速度快，可是公钥加密技术提供了更好的身份认证技术。SSL 的握手协议非常有效的让客户和服务器之间完成相互之间的身份认证，其主要过程如下：</p>\n<pre><code>1. 客户端的浏览器向服务器传送客户端SSL 协议的版本号，加密算法的种类，产生的随机数，\n    以及其他服务器和客户端之间通讯所需要的各种信息。\n\n2. 服务器向客户端传送SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，\n    同时服务器还将向客户端传送自己的证书。\n\n3. 客户利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，\n发行服务器证书的CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，\n服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；\n如果合法性验证通过，将继续进行第四步。\n\n4. 用户端随机产生一个用于后面通讯的“对称密码”，然后用服务器的公钥（服务器的公钥从步骤②中的\n服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。\n\n5. 如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，\n将这个含有签名的随机数和客户自己的证书以及加密过的“预主密码”一起传给服务器。\n\n6. 如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：\n客户的证书使用日期是否有效，为客户提供证书的CA 是否可靠，发行CA 的公钥能否正确解开客户证书\n的发行CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，\n通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的“预主密码”，\n然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。\n\n7. 服务器和客户端用相同的主密码即“通话密码”，一个对称密钥用于SSL协议的安全数据通讯的\n加解密通讯。同时在SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。\n\n8. 客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，\n同时通知服务器客户端的握手过程结束。\n\n9. 服务器向客户端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，\n同时通知客户端服务器端的握手过程结束。\n\n10. SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥\n进行数据通讯，同时进行通讯完整性的检验。\n</code></pre><hr>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"HTTP-HTTPS-基础与版本\"><a href=\"#HTTP-HTTPS-基础与版本\" class=\"headerlink\" title=\"HTTP/HTTPS 基础与版本\"></a>HTTP/HTTPS 基础与版本</h1><hr>\n<pre><code>目录:\n    - http\n        - 原理\n        - 结构\n        - 请求报文格式\n        - 答复报文格式\n        - 状态码\n        - 版本\n    - http与https的区别\n    - https\n        - 优点\n        - 加密\n</code></pre><hr>\n<h3 id=\"HTTP-HyperText-Transport-Protocol\"><a href=\"#HTTP-HyperText-Transport-Protocol\" class=\"headerlink\" title=\"HTTP(HyperText Transport Protocol)\"></a>HTTP(HyperText Transport Protocol)</h3><pre><code>超文本(超过计算机处理文本信息的方法)传输协议,最初为了提供发布和接收html页面的方法,运行在TCP/IP协议簇之上;\n服务器=html+http驻留程序(用于响应用户请求)\n</code></pre><ol>\n<li>1.0处理完请求之后就会释放连接;</li>\n<li>1.1请求可以多次重叠;</li>\n<li>客户端固定时间段向服务器发送保持连接请求,服务器收到请求后回复确认客户端在线;当长时间没有收到请求,则认为网络已经断开.</li>\n</ol>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><ol>\n<li><p><strong>首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作就开始了。</strong></p>\n</li>\n<li><p><strong>建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。</strong></p>\n</li>\n<li><p><strong>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</strong></p>\n</li>\n<li><p><strong>客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。</strong></p>\n</li>\n</ol>\n<h4 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h4><pre><code>- 模型: 请求/响应模型.\n- 请求头包含:\n    - 请求的方法\n    - URL\n    - 协议版本\n    - 类似于MIME的消息结构\n        - 请求修饰符\n        - 客户信息\n        - 内容\n- 响应包含:\n    - 消息协议的版本\n    - 成功/错误编码\n    - 包含服务器信息、实体元信息以及可能的实体内容。\n- 请求/响应内容包括:\n    - 一个起始行\n    - 一个或者多个头域\n        - 通用头\n        - 请求头\n        - 响应头\n        - 实体头\n    - 一个指示头域结束的空行\n    - 可选的消息体\n</code></pre><h4 id=\"请求报文格式\"><a href=\"#请求报文格式\" class=\"headerlink\" title=\"请求报文格式\"></a>请求报文格式</h4><pre><code>请求行 － 通用信息头 － 请求头 － 实体头 － 报文主体\n\n请求行以方法字段开始，后面分别是 URL 字段和 HTTP 协议版本字段，并以 CRLF 结尾。\nSP 是分隔符。除了在最后的 CRLF 序列中 CF 和 LF 是必需的之外，其他都可以不要。\n有关通用信息头，请求头和实体头方面的具体内容可以参照相关文件。\n</code></pre><h4 id=\"应答报文格式\"><a href=\"#应答报文格式\" class=\"headerlink\" title=\"应答报文格式\"></a>应答报文格式</h4><pre><code>状态行 － 通用信息头 － 响应头 － 实体头 － 报文主体\n\n状态码元由3位数字组成，表示请求是否被理解或被满足。原因分析是对原文的状态码作简短的描述，\n状态码用来支持自动操作，而原因分析用来供用户使用。客户机无需用来检查或显示语法。\n有关通用信息头，响应头和实体头方面的具体内容可以参照相关文件。\n</code></pre><h4 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h4><pre><code>1xx: 信息响应类，表示接收到请求并且继续处理\n2xx: 处理成功响应类，表示动作被成功接收、理解和接受\n3xx: 重定向响应类，为了完成指定的动作，必须接受进一步处理\n4xx: 客户端错误，客户请求包含语法错误或者是不能正确执行\n5xx: 服务端错误，服务器不能正确执行一个正确的请求\n</code></pre><h4 id=\"版本\"><a href=\"#版本\" class=\"headerlink\" title=\"版本\"></a>版本</h4><pre><code>HTTP/0.9　已过时。只接受 GET 一种请求方法，没有在通讯中指定版本号，且不支持请求头。\n        由于该版本不支持 POST 方法，所以客户端无法向服务器传递太多信息。\nHTTP/1.0　这是第一个在通讯中指定版本号的HTTP 协议版本，至今仍被广泛采用，特别是在代理服务器中。\nHTTP/1.1　当前版本。持久连接被默认采用，并能很好地配合代理服务器工作。\n        还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。\n</code></pre><hr>\n<h3 id=\"HTTPS-与-HTTP-的区别\"><a href=\"#HTTPS-与-HTTP-的区别\" class=\"headerlink\" title=\"HTTPS 与 HTTP 的区别\"></a>HTTPS 与 HTTP 的区别</h3><ul>\n<li>证书: HTTPS有需要缴费的<strong>ca证书</strong>；</li>\n<li>端口: HTTPS使用<strong>443端口</strong>,HTTP使用80端口；</li>\n<li>安全: HTTPS有作为<strong>应用层子层的,加密传输,身份认证</strong>的SSL层;HTTP是位于传输层，明文传输，无状态无记忆能力的连接；</li>\n</ul>\n<hr>\n<h3 id=\"HTTPS-Hyper-Text-Transfer-Protocol-over-Secure-Socket-Layer\"><a href=\"#HTTPS-Hyper-Text-Transfer-Protocol-over-Secure-Socket-Layer\" class=\"headerlink\" title=\"HTTPS(Hyper Text Transfer Protocol over Secure Socket Layer)\"></a>HTTPS(Hyper Text Transfer Protocol over Secure Socket Layer)</h3><pre><code>加入SSL层,以安全为目标的HTTP通道。\n\n以安全为目标的HTTP通道,添加的内容是SSl完全套接字层,主要进行详细内容的加密,Https存在不同于Http的默认端口,在Http和TCP之间还有加密/身份证明层,本来用于身份证明和加密通讯方法.\n\n　　客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。\n\n        （1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。\n\n        （2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。\n\n        （3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。\n\n        （4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。\n\n        （5）Web服务器利用自己的私钥解密出会话密钥。\n\n        （6）Web服务器利用会话密钥加密与客户端之间的通信。\n</code></pre><h4 id=\"SSL层原理\"><a href=\"#SSL层原理\" class=\"headerlink\" title=\"SSL层原理\"></a>SSL层原理</h4><ol>\n<li><p>SSL 协议既用到了<font color=\"red\"><strong>公钥加密技术</strong></font>又用到了<font color=\"red\"><strong>对称加密技术</strong></font>，对称加密技术虽然比公钥加密技术的速度快，可是公钥加密技术提供了更好的身份认证技术。</p>\n</li>\n<li><p>分为两层:</p>\n<ul>\n<li>SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供<font color=\"red\"><strong>数据封装、压缩、加密</strong></font>等基本功能的支持。</li>\n<li>SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于<font color=\"red\">在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</font></li>\n</ul>\n</li>\n<li><p>工作流程</p>\n<ol>\n<li>客户端Client: 向服务器发送一个开始信息“Hello”以便开始一个新的会话连接；</li>\n<li>服务器Server: 根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的“Hello”信息时将包含生成主密钥所需的信息；</li>\n<li>客户端Client: 根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器；</li>\n<li>服务器Server: 恢复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。</li>\n</ol>\n</li>\n</ol>\n<pre><code>注:在此之前，服务器已经通过了客户认证，这一阶段主要完成对客户的认证。\n经认证的服务器发送一个提问给客户，客户则返回（数字）签名后的提问和其公开密钥，\n从而向服务器提供认证。\n</code></pre><h4 id=\"握手过程\"><a href=\"#握手过程\" class=\"headerlink\" title=\"握手过程\"></a>握手过程</h4><p>为了便于更好的认识和理解SSL 协议，这里着重介绍SSL 协议的握手协议。SSL 协议既用到了公钥加密技术又用到了对称加密技术，对称加密技术虽然比公钥加密技术的速度快，可是公钥加密技术提供了更好的身份认证技术。SSL 的握手协议非常有效的让客户和服务器之间完成相互之间的身份认证，其主要过程如下：</p>\n<pre><code>1. 客户端的浏览器向服务器传送客户端SSL 协议的版本号，加密算法的种类，产生的随机数，\n    以及其他服务器和客户端之间通讯所需要的各种信息。\n\n2. 服务器向客户端传送SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，\n    同时服务器还将向客户端传送自己的证书。\n\n3. 客户利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，\n发行服务器证书的CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，\n服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；\n如果合法性验证通过，将继续进行第四步。\n\n4. 用户端随机产生一个用于后面通讯的“对称密码”，然后用服务器的公钥（服务器的公钥从步骤②中的\n服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。\n\n5. 如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，\n将这个含有签名的随机数和客户自己的证书以及加密过的“预主密码”一起传给服务器。\n\n6. 如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：\n客户的证书使用日期是否有效，为客户提供证书的CA 是否可靠，发行CA 的公钥能否正确解开客户证书\n的发行CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，\n通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的“预主密码”，\n然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。\n\n7. 服务器和客户端用相同的主密码即“通话密码”，一个对称密钥用于SSL协议的安全数据通讯的\n加解密通讯。同时在SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。\n\n8. 客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，\n同时通知服务器客户端的握手过程结束。\n\n9. 服务器向客户端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，\n同时通知客户端服务器端的握手过程结束。\n\n10. SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥\n进行数据通讯，同时进行通讯完整性的检验。\n</code></pre><hr>\n"},{"_content":"## TCP/UDP ##\n\nTCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议。\n* TCP提供IP环境下的数据可靠传输，它提供的服务包括数据流传送、可靠性、有效流控、全双工操作和多路复用。通过面向连接、端到端和可靠的数据包发送。通俗说，它是事先为所发送的数据开辟出连接好的通道，然后再进行数据发送；\n\t* TCP支持的应用协议主要有：Telnet、FTP、SMTP等；\n* 而UDP则不为IP提供可靠性、流控或差错恢复功能。一般来说，TCP对应的是可靠性要求高的应用，而UDP对应的则是可靠性要求低、传输经济的应用。\n\t* UDP支持的应用层协议主要有：NFS（网络文件系统）、SNMP（简单网络管理协议）、DNS（主域名称系统）、TFTP（通用文件传输协议）等。\n\n\n\n### TCP ###\nTCP协议能为应用程序提供可靠的通信连接，使一台计算机发出的字节流无差错地发往网络上的其他计算机，对可靠性要求高.\n\n1. 面向连接,计算机接收数据包的同时还要向其他计算机回发数据包.\n\n\n### UDP ###\n\nUDP面向非连接,不必先建立连接就可以直接发送.UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。\n","source":"_posts/Android之通信——UDP.md","raw":"## TCP/UDP ##\n\nTCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议。\n* TCP提供IP环境下的数据可靠传输，它提供的服务包括数据流传送、可靠性、有效流控、全双工操作和多路复用。通过面向连接、端到端和可靠的数据包发送。通俗说，它是事先为所发送的数据开辟出连接好的通道，然后再进行数据发送；\n\t* TCP支持的应用协议主要有：Telnet、FTP、SMTP等；\n* 而UDP则不为IP提供可靠性、流控或差错恢复功能。一般来说，TCP对应的是可靠性要求高的应用，而UDP对应的则是可靠性要求低、传输经济的应用。\n\t* UDP支持的应用层协议主要有：NFS（网络文件系统）、SNMP（简单网络管理协议）、DNS（主域名称系统）、TFTP（通用文件传输协议）等。\n\n\n\n### TCP ###\nTCP协议能为应用程序提供可靠的通信连接，使一台计算机发出的字节流无差错地发往网络上的其他计算机，对可靠性要求高.\n\n1. 面向连接,计算机接收数据包的同时还要向其他计算机回发数据包.\n\n\n### UDP ###\n\nUDP面向非连接,不必先建立连接就可以直接发送.UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。\n","slug":"Android之通信——UDP","published":1,"date":"2018-03-21T03:22:18.412Z","updated":"2017-08-29T09:44:09.528Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0kjqjf000k0s4l66mz9l6s","content":"<h2 id=\"TCP-UDP\"><a href=\"#TCP-UDP\" class=\"headerlink\" title=\"TCP/UDP\"></a>TCP/UDP</h2><p>TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议。</p>\n<ul>\n<li>TCP提供IP环境下的数据可靠传输，它提供的服务包括数据流传送、可靠性、有效流控、全双工操作和多路复用。通过面向连接、端到端和可靠的数据包发送。通俗说，它是事先为所发送的数据开辟出连接好的通道，然后再进行数据发送；<ul>\n<li>TCP支持的应用协议主要有：Telnet、FTP、SMTP等；</li>\n</ul>\n</li>\n<li>而UDP则不为IP提供可靠性、流控或差错恢复功能。一般来说，TCP对应的是可靠性要求高的应用，而UDP对应的则是可靠性要求低、传输经济的应用。<ul>\n<li>UDP支持的应用层协议主要有：NFS（网络文件系统）、SNMP（简单网络管理协议）、DNS（主域名称系统）、TFTP（通用文件传输协议）等。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h3><p>TCP协议能为应用程序提供可靠的通信连接，使一台计算机发出的字节流无差错地发往网络上的其他计算机，对可靠性要求高.</p>\n<ol>\n<li>面向连接,计算机接收数据包的同时还要向其他计算机回发数据包.</li>\n</ol>\n<h3 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h3><p>UDP面向非连接,不必先建立连接就可以直接发送.UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"TCP-UDP\"><a href=\"#TCP-UDP\" class=\"headerlink\" title=\"TCP/UDP\"></a>TCP/UDP</h2><p>TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议。</p>\n<ul>\n<li>TCP提供IP环境下的数据可靠传输，它提供的服务包括数据流传送、可靠性、有效流控、全双工操作和多路复用。通过面向连接、端到端和可靠的数据包发送。通俗说，它是事先为所发送的数据开辟出连接好的通道，然后再进行数据发送；<ul>\n<li>TCP支持的应用协议主要有：Telnet、FTP、SMTP等；</li>\n</ul>\n</li>\n<li>而UDP则不为IP提供可靠性、流控或差错恢复功能。一般来说，TCP对应的是可靠性要求高的应用，而UDP对应的则是可靠性要求低、传输经济的应用。<ul>\n<li>UDP支持的应用层协议主要有：NFS（网络文件系统）、SNMP（简单网络管理协议）、DNS（主域名称系统）、TFTP（通用文件传输协议）等。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h3><p>TCP协议能为应用程序提供可靠的通信连接，使一台计算机发出的字节流无差错地发往网络上的其他计算机，对可靠性要求高.</p>\n<ol>\n<li>面向连接,计算机接收数据包的同时还要向其他计算机回发数据包.</li>\n</ol>\n<h3 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h3><p>UDP面向非连接,不必先建立连接就可以直接发送.UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。</p>\n"},{"title":"错误与崩溃集锦","_content":"\n# 错误与崩溃集锦\n\n\n\n1. 错误1\n\n\t\tError:A problem occurred configuring project ':app'.\n\t\t> Failed to notify project evaluation listener.\n\t\t   > Tinker does not support instant run mode, please trigger build by assembleHuaweiDebug or disable instant run in 'File->Settings...'.\n\t\t   > can't find tinkerProcessHuaweiDebugManifest, you must init tinker plugin first!\n\n2. 改变build.gradle为\"com.android.library\"\n\n\t\tError:Dependency fentu_android:zxingLibrary:unspecified on project app resolves to an APK archive which is not supported as a compilation dependency. \n\t\tFile: D:\\Workspace\\fentu_android\\zxingLibrary\\build\\outputs\\apk\\zxingLibrary-release-unsigned.apk\n\n3. 删除module中的applicationId\n\n\tError:Library projects cannot set applicationId. applicationId is set to 'package_name' in default config.\n\n4. RecyclerView \n\t\n\t1. itemClickListener的getAdapterPosition = -1 导致的崩溃\n\t2. 数据源每一次更新必须notify,否则会报数据源不对应的错;\n\n5. Glide\n\n\t1. `.asBitmap().dontAnimate()`不会造成第一次加载图片拉伸的问题.\n\n\n6. NavigationView DrawerLayout 配合使用,NavigationView 点击事件无效的问题\n\n\t\t需要将 NavigationView 作为第二个子View 时才能正常使用","source":"_posts/错误集锦及更正记录.md","raw":"---\n\ntitle: 错误与崩溃集锦\ncategories: \"android 总结\"\ntags: \n     - android\n     - 崩溃\n     - 错误\n \n---\n\n# 错误与崩溃集锦\n\n\n\n1. 错误1\n\n\t\tError:A problem occurred configuring project ':app'.\n\t\t> Failed to notify project evaluation listener.\n\t\t   > Tinker does not support instant run mode, please trigger build by assembleHuaweiDebug or disable instant run in 'File->Settings...'.\n\t\t   > can't find tinkerProcessHuaweiDebugManifest, you must init tinker plugin first!\n\n2. 改变build.gradle为\"com.android.library\"\n\n\t\tError:Dependency fentu_android:zxingLibrary:unspecified on project app resolves to an APK archive which is not supported as a compilation dependency. \n\t\tFile: D:\\Workspace\\fentu_android\\zxingLibrary\\build\\outputs\\apk\\zxingLibrary-release-unsigned.apk\n\n3. 删除module中的applicationId\n\n\tError:Library projects cannot set applicationId. applicationId is set to 'package_name' in default config.\n\n4. RecyclerView \n\t\n\t1. itemClickListener的getAdapterPosition = -1 导致的崩溃\n\t2. 数据源每一次更新必须notify,否则会报数据源不对应的错;\n\n5. Glide\n\n\t1. `.asBitmap().dontAnimate()`不会造成第一次加载图片拉伸的问题.\n\n\n6. NavigationView DrawerLayout 配合使用,NavigationView 点击事件无效的问题\n\n\t\t需要将 NavigationView 作为第二个子View 时才能正常使用","slug":"错误集锦及更正记录","published":1,"date":"2018-03-21T05:35:40.042Z","updated":"2018-03-21T05:22:07.144Z","_id":"cjf0kjqjg000l0s4ltz86p57i","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"错误与崩溃集锦\"><a href=\"#错误与崩溃集锦\" class=\"headerlink\" title=\"错误与崩溃集锦\"></a>错误与崩溃集锦</h1><ol>\n<li><p>错误1</p>\n<pre><code>Error:A problem occurred configuring project &apos;:app&apos;.\n&gt; Failed to notify project evaluation listener.\n   &gt; Tinker does not support instant run mode, please trigger build by assembleHuaweiDebug or disable instant run in &apos;File-&gt;Settings...&apos;.\n   &gt; can&apos;t find tinkerProcessHuaweiDebugManifest, you must init tinker plugin first!\n</code></pre></li>\n<li><p>改变build.gradle为”com.android.library”</p>\n<pre><code>Error:Dependency fentu_android:zxingLibrary:unspecified on project app resolves to an APK archive which is not supported as a compilation dependency. \nFile: D:\\Workspace\\fentu_android\\zxingLibrary\\build\\outputs\\apk\\zxingLibrary-release-unsigned.apk\n</code></pre></li>\n<li><p>删除module中的applicationId</p>\n<p> Error:Library projects cannot set applicationId. applicationId is set to ‘package_name’ in default config.</p>\n</li>\n<li><p>RecyclerView </p>\n<ol>\n<li>itemClickListener的getAdapterPosition = -1 导致的崩溃</li>\n<li>数据源每一次更新必须notify,否则会报数据源不对应的错;</li>\n</ol>\n</li>\n<li><p>Glide</p>\n<ol>\n<li><code>.asBitmap().dontAnimate()</code>不会造成第一次加载图片拉伸的问题.</li>\n</ol>\n</li>\n</ol>\n<ol>\n<li><p>NavigationView DrawerLayout 配合使用,NavigationView 点击事件无效的问题</p>\n<pre><code>需要将 NavigationView 作为第二个子View 时才能正常使用\n</code></pre></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"错误与崩溃集锦\"><a href=\"#错误与崩溃集锦\" class=\"headerlink\" title=\"错误与崩溃集锦\"></a>错误与崩溃集锦</h1><ol>\n<li><p>错误1</p>\n<pre><code>Error:A problem occurred configuring project &apos;:app&apos;.\n&gt; Failed to notify project evaluation listener.\n   &gt; Tinker does not support instant run mode, please trigger build by assembleHuaweiDebug or disable instant run in &apos;File-&gt;Settings...&apos;.\n   &gt; can&apos;t find tinkerProcessHuaweiDebugManifest, you must init tinker plugin first!\n</code></pre></li>\n<li><p>改变build.gradle为”com.android.library”</p>\n<pre><code>Error:Dependency fentu_android:zxingLibrary:unspecified on project app resolves to an APK archive which is not supported as a compilation dependency. \nFile: D:\\Workspace\\fentu_android\\zxingLibrary\\build\\outputs\\apk\\zxingLibrary-release-unsigned.apk\n</code></pre></li>\n<li><p>删除module中的applicationId</p>\n<p> Error:Library projects cannot set applicationId. applicationId is set to ‘package_name’ in default config.</p>\n</li>\n<li><p>RecyclerView </p>\n<ol>\n<li>itemClickListener的getAdapterPosition = -1 导致的崩溃</li>\n<li>数据源每一次更新必须notify,否则会报数据源不对应的错;</li>\n</ol>\n</li>\n<li><p>Glide</p>\n<ol>\n<li><code>.asBitmap().dontAnimate()</code>不会造成第一次加载图片拉伸的问题.</li>\n</ol>\n</li>\n</ol>\n<ol>\n<li><p>NavigationView DrawerLayout 配合使用,NavigationView 点击事件无效的问题</p>\n<pre><code>需要将 NavigationView 作为第二个子View 时才能正常使用\n</code></pre></li>\n</ol>\n"},{"title":"代码规范&屏幕适配","_content":"# 代码规范&屏幕适配\n---\n## 代码规范\n\n\t\t参考:http://www.jianshu.com/p/fbf9ea4b9d76#rd\t\t\n\t\t\n1. 包名全部小写,不使用下划线,\n\n\t1. 主包名使用公司性质.公司名称.项目名称;\n\t2. 子包名使用通用名称的命名方式:\n\n\t\t1. util:工具类\n\t\t2. main:activity及入口所在的包\n\t\t3. view:自定义View\n\t\t4. db:数据库操作\n\t\t5. pref:首选项\n\t\t6. provider:contentProvider\n\t\t7. receiver:广播接收器\n\t\t8. service:服务所在包\n\n\t3. 导包不要使用\"*\",使用具体的类包;\n\t4. 导入类,系统类在上,自定义类在下;\n\n2. 代码:\n\n\t1. 主要使用驼峰命名:每个单词的首字母大写;\n\t2. 类,接口,枚举等首字母大写;\n\t3. 父类名作为类名的后缀;\n\t4. 自定义异常Exception结尾;\n\t5. for循环内部使用ijk,其他不允许;\n\t6. 数组名称使用复数;\n\t7. 常量枚举使用大写+下划线;\n\t8. 成员变量使用前缀m(member),静态变量使用前缀s(static);\n\t9. 控件变量添加组件前缀,并在所有者前缀之后;\n\t10. 除单例模式一般不使用静态变量;\n\t11. 常量使用 static final修饰;\n\t12. 构造方法的顺序根据参数多少使用递增方式;\n\t13. 项目内使用的实体类不使用javaBean封装,访问修饰符使用非private;\n\t14. 成员变量不可随意修改的内容使用下划线进行区分;\n\t15. 使用Log打印输出;\n\t16. 使用BuildConfig.DEBUG标记对Log进行封装，只在调试时输出重要信息，正式版不输出;\n\t17. try.catch只捕获需要的异常,且catch的异常信息应该输出;\n3. res文件夹内容:\n\n\t1. 资源命名使用小写+下划线;\n\t2. 常用的布局文件的前缀:activity,dialog,item,popup,window;\n\t3. 图片使用格式:**性质前缀_ 功能模块_ 属性后缀.扩展名**(属性后缀:pressed,disable,normal,checked,selector等.);\n\t4. values目录下的文件名称:arrays,attrs,colors,dimens,drawables,strings,styles.\n4. 注释:\n\n\t1. 开源项目必要文件注释,非开源项目建议添加;/*...\n\t2. 类写类注释,接口写接口注释,变量常量添加属性注释,关联性大的可以使用一条注释.\n\t3. public protected必须添加方法注释,其他建议添加注释,重写方法子类可以不写注释.\n\t4. 弃用的使用@Deprecated;\n\t5. switch每一项添加说明;\n\t6. if条件多于2个必须写注释;\n\t7. **未完成的函数使用//TODO:...标记**\n\t8. **有潜在问题的使用//XXX:...进行标记.**\n\t9. **代码存在严重问题或用于调试,使用//FIXME:...标记,不能作为正式版发布;**\n\t10. for,while过长使用标记\n\n----\n\n\n## 屏幕适配\n1. 屏幕尺寸:对角线长度,单位是英寸.1英寸=2.54厘米,\n\t\t\n\t\t常见的屏幕尺寸有2.4、2.8、3.5、3.7、4.2、5.0、5.5、6.0等;\n2. 分辨率:单位为px.1px = 1像素点.\n\t\t\n\t\t常用表示 1280(px)×720(px);\n3. 像素密度:每英寸有多少像素,单位dpi;\n\t\t\n\t\t计算方法如:开根(1280 * 1280+720 * 720)/屏幕尺寸;\n4. 单位比较:\n\t1. dp=dip(密度无关像素),以160dpi为基准，1dp=1px,320dpi下，1dp=2px;\n\t2. dpi：屏幕像素密度的单位，“dot per inch”的缩写;\n\t3. sp：Scale-Independent Pixels的缩写，可以根据文字大小首选项自动进行缩放。Google推荐我们使用12sp以上的大小，最好不要使用奇数和小数。\n5. 尺寸比例\n\t\t\n\t\tmdpi：hdpi：xhdpi：xxhdpi：xxxhdpi=2：3：4：6：8;\n6. 支持屏幕尺寸的解决方案\n\t1. 使用wrap_ content、math_ parent、weight;\n\t2. 使用相对布局，禁用绝对布局;\n\t3. 使用限定符.\n\t\t1. large:程序运行在屏幕尺寸大于7inch的设备上，系统就会加载`res/layout-large/activity_main.xml`，在小于7inch的设备上就会加载`res/layout/activity_main.xml`.**适用于android3.2之前.**\n\t\t2. 最小宽度限定符\n\t\t\t\t`layout-sw600dp`文件夹(Small Width 最小宽度)\n\t\t3. 使用布局别名\n\t\t\t\t`res/layout/main.xml`: 单面板布局\n\t\t\t\t`res/layout-large/main.xml`: 多面板布局\n\t\t\t\t`res/layout-sw600dp/main.xml`: 多面板布局\n\t\t\t\t\n\t\t\t由于后两个文具文件一样，我们可以用以下两个文件代替上面三个布局文件：\n\t\t\n\t\t\t\tres/layout/main.xml单面板布局\n\t\t\t\tres/layout/main_twopanes.xml双面板布局\n\t\t\n\t\t\t然后在res下建立\n\t\t\t\t`res/values/layout.xml`、\n\t\t\t\t`res/values-large/layout.xml`、\n\t\t\t\t`res/values-sw600dp/layout.xml`三个文件。\n\t\t\n\t\t\t默认布局\n\t\t\t`res/values/layout.xml`:\n\t\t\t\n\t\t\t\t\t<resources>\n\t\t\t\t\t  <item name=\"main\" type=\"layout\">@layout/main</item>\n\t\t\t\t\t</resources>\n\t\t\n\t\t\tAndroid3.2之前的平板布局\n\t\t\t`res/values-large/layout.xml`:\n\t\t\n\t\t\t\t\t<resources>\n\t\t\t\t\t  <item name=\"main\" type=\"layout\">@layout/main_twopanes</item>\n\t\t\t\t\t</resources>\n\t\t\n\t\t\tAndroid3.2之后的平板布局\n\t\t\t`res/values-sw600dp/layout.xml`:\n\t\t\n\t\t\t\t\t<resources>\n\t\t\t\t\t  <item name=\"main\" type=\"layout\">@layout/main_twopanes</item>\n\t\t\t\t\t</resources>\n\t\t\n\t\t\t这样就有了main为别名的布局。\n\t\t\t在activity中`setContentView(R.layout.main)`;\n\t\t\t\n\t\t\t这样，程序在运行时，就会检测手机的屏幕大小，如果是平板设备就会加载`res/layout/main_twopanes.xml`，如果是手机设备，就会加载`res/layout/main.xml `。我们就解决了只使用一个布局文件来适配android3.2前后的所有平板设备。\n\t\t\t\n\t\t4. 屏幕方向限定符\n\t\t\t\n\t\t\t如果我们要求给横屏、竖屏显示的布局不一样。就可以使用屏幕方向限定符来实现。\n\t\t\t例如，要在平板上实现横竖屏显示不用的布局，可以用以下方式实现。\n\t\t\t`res/values-sw600dp-land/layouts.xml`:横屏\n\t\t\t\n\t\t\t\t<resources>\n\t\t\t\t  <item name=\"main\" type=\"layout\">@layout/main_twopanes</item>\n\t\t\t\t</resources>\n\t\t\t\n\t\t\t`res/values-sw600dp-port/layouts.xml`:竖屏\n\t\t\t\n\t\t\t\t<resources>\n\t\t\t\t  <item name=\"main\" type=\"layout\">@layout/main</item>\n\t\t\t\t</resources>\n\t\t5. 使用.9.png\n7. 支持屏幕密度的解决方案\n\n\t\t1. 将任何设备的手机密度像素分为320份*480份,当使用dp时使用对应的参数px即可\n\t\t2. 使用备用位图,每个文件夹下放置符合比例的资源文件,系统自动加载,否则很大程度耗费内存;\n\n8. 不同布局可能导致不同的操作,应该对应不同的逻辑判断.","source":"_posts/代码规范&屏幕适配.md","raw":"---\n\ntitle: 代码规范&屏幕适配\ncategories: \"android 总结\"\ntags: \n     - android\n     - 代码规范\n     - 屏幕适配\n \n---\n# 代码规范&屏幕适配\n---\n## 代码规范\n\n\t\t参考:http://www.jianshu.com/p/fbf9ea4b9d76#rd\t\t\n\t\t\n1. 包名全部小写,不使用下划线,\n\n\t1. 主包名使用公司性质.公司名称.项目名称;\n\t2. 子包名使用通用名称的命名方式:\n\n\t\t1. util:工具类\n\t\t2. main:activity及入口所在的包\n\t\t3. view:自定义View\n\t\t4. db:数据库操作\n\t\t5. pref:首选项\n\t\t6. provider:contentProvider\n\t\t7. receiver:广播接收器\n\t\t8. service:服务所在包\n\n\t3. 导包不要使用\"*\",使用具体的类包;\n\t4. 导入类,系统类在上,自定义类在下;\n\n2. 代码:\n\n\t1. 主要使用驼峰命名:每个单词的首字母大写;\n\t2. 类,接口,枚举等首字母大写;\n\t3. 父类名作为类名的后缀;\n\t4. 自定义异常Exception结尾;\n\t5. for循环内部使用ijk,其他不允许;\n\t6. 数组名称使用复数;\n\t7. 常量枚举使用大写+下划线;\n\t8. 成员变量使用前缀m(member),静态变量使用前缀s(static);\n\t9. 控件变量添加组件前缀,并在所有者前缀之后;\n\t10. 除单例模式一般不使用静态变量;\n\t11. 常量使用 static final修饰;\n\t12. 构造方法的顺序根据参数多少使用递增方式;\n\t13. 项目内使用的实体类不使用javaBean封装,访问修饰符使用非private;\n\t14. 成员变量不可随意修改的内容使用下划线进行区分;\n\t15. 使用Log打印输出;\n\t16. 使用BuildConfig.DEBUG标记对Log进行封装，只在调试时输出重要信息，正式版不输出;\n\t17. try.catch只捕获需要的异常,且catch的异常信息应该输出;\n3. res文件夹内容:\n\n\t1. 资源命名使用小写+下划线;\n\t2. 常用的布局文件的前缀:activity,dialog,item,popup,window;\n\t3. 图片使用格式:**性质前缀_ 功能模块_ 属性后缀.扩展名**(属性后缀:pressed,disable,normal,checked,selector等.);\n\t4. values目录下的文件名称:arrays,attrs,colors,dimens,drawables,strings,styles.\n4. 注释:\n\n\t1. 开源项目必要文件注释,非开源项目建议添加;/*...\n\t2. 类写类注释,接口写接口注释,变量常量添加属性注释,关联性大的可以使用一条注释.\n\t3. public protected必须添加方法注释,其他建议添加注释,重写方法子类可以不写注释.\n\t4. 弃用的使用@Deprecated;\n\t5. switch每一项添加说明;\n\t6. if条件多于2个必须写注释;\n\t7. **未完成的函数使用//TODO:...标记**\n\t8. **有潜在问题的使用//XXX:...进行标记.**\n\t9. **代码存在严重问题或用于调试,使用//FIXME:...标记,不能作为正式版发布;**\n\t10. for,while过长使用标记\n\n----\n\n\n## 屏幕适配\n1. 屏幕尺寸:对角线长度,单位是英寸.1英寸=2.54厘米,\n\t\t\n\t\t常见的屏幕尺寸有2.4、2.8、3.5、3.7、4.2、5.0、5.5、6.0等;\n2. 分辨率:单位为px.1px = 1像素点.\n\t\t\n\t\t常用表示 1280(px)×720(px);\n3. 像素密度:每英寸有多少像素,单位dpi;\n\t\t\n\t\t计算方法如:开根(1280 * 1280+720 * 720)/屏幕尺寸;\n4. 单位比较:\n\t1. dp=dip(密度无关像素),以160dpi为基准，1dp=1px,320dpi下，1dp=2px;\n\t2. dpi：屏幕像素密度的单位，“dot per inch”的缩写;\n\t3. sp：Scale-Independent Pixels的缩写，可以根据文字大小首选项自动进行缩放。Google推荐我们使用12sp以上的大小，最好不要使用奇数和小数。\n5. 尺寸比例\n\t\t\n\t\tmdpi：hdpi：xhdpi：xxhdpi：xxxhdpi=2：3：4：6：8;\n6. 支持屏幕尺寸的解决方案\n\t1. 使用wrap_ content、math_ parent、weight;\n\t2. 使用相对布局，禁用绝对布局;\n\t3. 使用限定符.\n\t\t1. large:程序运行在屏幕尺寸大于7inch的设备上，系统就会加载`res/layout-large/activity_main.xml`，在小于7inch的设备上就会加载`res/layout/activity_main.xml`.**适用于android3.2之前.**\n\t\t2. 最小宽度限定符\n\t\t\t\t`layout-sw600dp`文件夹(Small Width 最小宽度)\n\t\t3. 使用布局别名\n\t\t\t\t`res/layout/main.xml`: 单面板布局\n\t\t\t\t`res/layout-large/main.xml`: 多面板布局\n\t\t\t\t`res/layout-sw600dp/main.xml`: 多面板布局\n\t\t\t\t\n\t\t\t由于后两个文具文件一样，我们可以用以下两个文件代替上面三个布局文件：\n\t\t\n\t\t\t\tres/layout/main.xml单面板布局\n\t\t\t\tres/layout/main_twopanes.xml双面板布局\n\t\t\n\t\t\t然后在res下建立\n\t\t\t\t`res/values/layout.xml`、\n\t\t\t\t`res/values-large/layout.xml`、\n\t\t\t\t`res/values-sw600dp/layout.xml`三个文件。\n\t\t\n\t\t\t默认布局\n\t\t\t`res/values/layout.xml`:\n\t\t\t\n\t\t\t\t\t<resources>\n\t\t\t\t\t  <item name=\"main\" type=\"layout\">@layout/main</item>\n\t\t\t\t\t</resources>\n\t\t\n\t\t\tAndroid3.2之前的平板布局\n\t\t\t`res/values-large/layout.xml`:\n\t\t\n\t\t\t\t\t<resources>\n\t\t\t\t\t  <item name=\"main\" type=\"layout\">@layout/main_twopanes</item>\n\t\t\t\t\t</resources>\n\t\t\n\t\t\tAndroid3.2之后的平板布局\n\t\t\t`res/values-sw600dp/layout.xml`:\n\t\t\n\t\t\t\t\t<resources>\n\t\t\t\t\t  <item name=\"main\" type=\"layout\">@layout/main_twopanes</item>\n\t\t\t\t\t</resources>\n\t\t\n\t\t\t这样就有了main为别名的布局。\n\t\t\t在activity中`setContentView(R.layout.main)`;\n\t\t\t\n\t\t\t这样，程序在运行时，就会检测手机的屏幕大小，如果是平板设备就会加载`res/layout/main_twopanes.xml`，如果是手机设备，就会加载`res/layout/main.xml `。我们就解决了只使用一个布局文件来适配android3.2前后的所有平板设备。\n\t\t\t\n\t\t4. 屏幕方向限定符\n\t\t\t\n\t\t\t如果我们要求给横屏、竖屏显示的布局不一样。就可以使用屏幕方向限定符来实现。\n\t\t\t例如，要在平板上实现横竖屏显示不用的布局，可以用以下方式实现。\n\t\t\t`res/values-sw600dp-land/layouts.xml`:横屏\n\t\t\t\n\t\t\t\t<resources>\n\t\t\t\t  <item name=\"main\" type=\"layout\">@layout/main_twopanes</item>\n\t\t\t\t</resources>\n\t\t\t\n\t\t\t`res/values-sw600dp-port/layouts.xml`:竖屏\n\t\t\t\n\t\t\t\t<resources>\n\t\t\t\t  <item name=\"main\" type=\"layout\">@layout/main</item>\n\t\t\t\t</resources>\n\t\t5. 使用.9.png\n7. 支持屏幕密度的解决方案\n\n\t\t1. 将任何设备的手机密度像素分为320份*480份,当使用dp时使用对应的参数px即可\n\t\t2. 使用备用位图,每个文件夹下放置符合比例的资源文件,系统自动加载,否则很大程度耗费内存;\n\n8. 不同布局可能导致不同的操作,应该对应不同的逻辑判断.","slug":"代码规范&屏幕适配","published":1,"date":"2018-03-21T05:35:40.042Z","updated":"2018-03-21T05:21:33.609Z","_id":"cjf0kjqjh000m0s4ltrktmbgo","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"代码规范-amp-屏幕适配\"><a href=\"#代码规范-amp-屏幕适配\" class=\"headerlink\" title=\"代码规范&amp;屏幕适配\"></a>代码规范&amp;屏幕适配</h1><hr>\n<h2 id=\"代码规范\"><a href=\"#代码规范\" class=\"headerlink\" title=\"代码规范\"></a>代码规范</h2><pre><code>参考:http://www.jianshu.com/p/fbf9ea4b9d76#rd        \n</code></pre><ol>\n<li><p>包名全部小写,不使用下划线,</p>\n<ol>\n<li>主包名使用公司性质.公司名称.项目名称;</li>\n<li><p>子包名使用通用名称的命名方式:</p>\n<ol>\n<li>util:工具类</li>\n<li>main:activity及入口所在的包</li>\n<li>view:自定义View</li>\n<li>db:数据库操作</li>\n<li>pref:首选项</li>\n<li>provider:contentProvider</li>\n<li>receiver:广播接收器</li>\n<li>service:服务所在包</li>\n</ol>\n</li>\n<li><p>导包不要使用”*”,使用具体的类包;</p>\n</li>\n<li>导入类,系统类在上,自定义类在下;</li>\n</ol>\n</li>\n<li><p>代码:</p>\n<ol>\n<li>主要使用驼峰命名:每个单词的首字母大写;</li>\n<li>类,接口,枚举等首字母大写;</li>\n<li>父类名作为类名的后缀;</li>\n<li>自定义异常Exception结尾;</li>\n<li>for循环内部使用ijk,其他不允许;</li>\n<li>数组名称使用复数;</li>\n<li>常量枚举使用大写+下划线;</li>\n<li>成员变量使用前缀m(member),静态变量使用前缀s(static);</li>\n<li>控件变量添加组件前缀,并在所有者前缀之后;</li>\n<li>除单例模式一般不使用静态变量;</li>\n<li>常量使用 static final修饰;</li>\n<li>构造方法的顺序根据参数多少使用递增方式;</li>\n<li>项目内使用的实体类不使用javaBean封装,访问修饰符使用非private;</li>\n<li>成员变量不可随意修改的内容使用下划线进行区分;</li>\n<li>使用Log打印输出;</li>\n<li>使用BuildConfig.DEBUG标记对Log进行封装，只在调试时输出重要信息，正式版不输出;</li>\n<li>try.catch只捕获需要的异常,且catch的异常信息应该输出;</li>\n</ol>\n</li>\n<li><p>res文件夹内容:</p>\n<ol>\n<li>资源命名使用小写+下划线;</li>\n<li>常用的布局文件的前缀:activity,dialog,item,popup,window;</li>\n<li>图片使用格式:<strong>性质前缀_ 功能模块_ 属性后缀.扩展名</strong>(属性后缀:pressed,disable,normal,checked,selector等.);</li>\n<li>values目录下的文件名称:arrays,attrs,colors,dimens,drawables,strings,styles.</li>\n</ol>\n</li>\n<li><p>注释:</p>\n<ol>\n<li>开源项目必要文件注释,非开源项目建议添加;/*…</li>\n<li>类写类注释,接口写接口注释,变量常量添加属性注释,关联性大的可以使用一条注释.</li>\n<li>public protected必须添加方法注释,其他建议添加注释,重写方法子类可以不写注释.</li>\n<li>弃用的使用@Deprecated;</li>\n<li>switch每一项添加说明;</li>\n<li>if条件多于2个必须写注释;</li>\n<li><strong>未完成的函数使用//TODO:…标记</strong></li>\n<li><strong>有潜在问题的使用//XXX:…进行标记.</strong></li>\n<li><strong>代码存在严重问题或用于调试,使用//FIXME:…标记,不能作为正式版发布;</strong></li>\n<li>for,while过长使用标记</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"屏幕适配\"><a href=\"#屏幕适配\" class=\"headerlink\" title=\"屏幕适配\"></a>屏幕适配</h2><ol>\n<li><p>屏幕尺寸:对角线长度,单位是英寸.1英寸=2.54厘米,</p>\n<pre><code>常见的屏幕尺寸有2.4、2.8、3.5、3.7、4.2、5.0、5.5、6.0等;\n</code></pre></li>\n<li><p>分辨率:单位为px.1px = 1像素点.</p>\n<pre><code>常用表示 1280(px)×720(px);\n</code></pre></li>\n<li><p>像素密度:每英寸有多少像素,单位dpi;</p>\n<pre><code>计算方法如:开根(1280 * 1280+720 * 720)/屏幕尺寸;\n</code></pre></li>\n<li>单位比较:<ol>\n<li>dp=dip(密度无关像素),以160dpi为基准，1dp=1px,320dpi下，1dp=2px;</li>\n<li>dpi：屏幕像素密度的单位，“dot per inch”的缩写;</li>\n<li>sp：Scale-Independent Pixels的缩写，可以根据文字大小首选项自动进行缩放。Google推荐我们使用12sp以上的大小，最好不要使用奇数和小数。</li>\n</ol>\n</li>\n<li><p>尺寸比例</p>\n<pre><code>mdpi：hdpi：xhdpi：xxhdpi：xxxhdpi=2：3：4：6：8;\n</code></pre></li>\n<li><p>支持屏幕尺寸的解决方案</p>\n<ol>\n<li>使用wrap_ content、math_ parent、weight;</li>\n<li>使用相对布局，禁用绝对布局;</li>\n<li><p>使用限定符.</p>\n<ol>\n<li>large:程序运行在屏幕尺寸大于7inch的设备上，系统就会加载<code>res/layout-large/activity_main.xml</code>，在小于7inch的设备上就会加载<code>res/layout/activity_main.xml</code>.<strong>适用于android3.2之前.</strong></li>\n<li>最小宽度限定符<pre><code>`layout-sw600dp`文件夹(Small Width 最小宽度)\n</code></pre></li>\n<li><p>使用布局别名</p>\n<pre><code>`res/layout/main.xml`: 单面板布局\n`res/layout-large/main.xml`: 多面板布局\n`res/layout-sw600dp/main.xml`: 多面板布局\n</code></pre><p> 由于后两个文具文件一样，我们可以用以下两个文件代替上面三个布局文件：</p>\n<pre><code>res/layout/main.xml单面板布局\nres/layout/main_twopanes.xml双面板布局\n</code></pre><p> 然后在res下建立</p>\n<pre><code>`res/values/layout.xml`、\n`res/values-large/layout.xml`、\n`res/values-sw600dp/layout.xml`三个文件。\n</code></pre><p> 默认布局<br> <code>res/values/layout.xml</code>:</p>\n<pre><code>&lt;resources&gt;\n  &lt;item name=&quot;main&quot; type=&quot;layout&quot;&gt;@layout/main&lt;/item&gt;\n&lt;/resources&gt;\n</code></pre><p> Android3.2之前的平板布局<br> <code>res/values-large/layout.xml</code>:</p>\n<pre><code>&lt;resources&gt;\n  &lt;item name=&quot;main&quot; type=&quot;layout&quot;&gt;@layout/main_twopanes&lt;/item&gt;\n&lt;/resources&gt;\n</code></pre><p> Android3.2之后的平板布局<br> <code>res/values-sw600dp/layout.xml</code>:</p>\n<pre><code>&lt;resources&gt;\n  &lt;item name=&quot;main&quot; type=&quot;layout&quot;&gt;@layout/main_twopanes&lt;/item&gt;\n&lt;/resources&gt;\n</code></pre><p> 这样就有了main为别名的布局。<br> 在activity中<code>setContentView(R.layout.main)</code>;</p>\n<p> 这样，程序在运行时，就会检测手机的屏幕大小，如果是平板设备就会加载<code>res/layout/main_twopanes.xml</code>，如果是手机设备，就会加载<code>res/layout/main.xml</code>。我们就解决了只使用一个布局文件来适配android3.2前后的所有平板设备。</p>\n</li>\n<li><p>屏幕方向限定符</p>\n<p> 如果我们要求给横屏、竖屏显示的布局不一样。就可以使用屏幕方向限定符来实现。<br> 例如，要在平板上实现横竖屏显示不用的布局，可以用以下方式实现。<br> <code>res/values-sw600dp-land/layouts.xml</code>:横屏</p>\n<pre><code>&lt;resources&gt;\n  &lt;item name=&quot;main&quot; type=&quot;layout&quot;&gt;@layout/main_twopanes&lt;/item&gt;\n&lt;/resources&gt;\n</code></pre><p> <code>res/values-sw600dp-port/layouts.xml</code>:竖屏</p>\n<pre><code>&lt;resources&gt;\n  &lt;item name=&quot;main&quot; type=&quot;layout&quot;&gt;@layout/main&lt;/item&gt;\n&lt;/resources&gt;\n</code></pre></li>\n<li>使用.9.png</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>支持屏幕密度的解决方案</p>\n<pre><code>1. 将任何设备的手机密度像素分为320份*480份,当使用dp时使用对应的参数px即可\n2. 使用备用位图,每个文件夹下放置符合比例的资源文件,系统自动加载,否则很大程度耗费内存;\n</code></pre></li>\n<li><p>不同布局可能导致不同的操作,应该对应不同的逻辑判断.</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"代码规范-amp-屏幕适配\"><a href=\"#代码规范-amp-屏幕适配\" class=\"headerlink\" title=\"代码规范&amp;屏幕适配\"></a>代码规范&amp;屏幕适配</h1><hr>\n<h2 id=\"代码规范\"><a href=\"#代码规范\" class=\"headerlink\" title=\"代码规范\"></a>代码规范</h2><pre><code>参考:http://www.jianshu.com/p/fbf9ea4b9d76#rd        \n</code></pre><ol>\n<li><p>包名全部小写,不使用下划线,</p>\n<ol>\n<li>主包名使用公司性质.公司名称.项目名称;</li>\n<li><p>子包名使用通用名称的命名方式:</p>\n<ol>\n<li>util:工具类</li>\n<li>main:activity及入口所在的包</li>\n<li>view:自定义View</li>\n<li>db:数据库操作</li>\n<li>pref:首选项</li>\n<li>provider:contentProvider</li>\n<li>receiver:广播接收器</li>\n<li>service:服务所在包</li>\n</ol>\n</li>\n<li><p>导包不要使用”*”,使用具体的类包;</p>\n</li>\n<li>导入类,系统类在上,自定义类在下;</li>\n</ol>\n</li>\n<li><p>代码:</p>\n<ol>\n<li>主要使用驼峰命名:每个单词的首字母大写;</li>\n<li>类,接口,枚举等首字母大写;</li>\n<li>父类名作为类名的后缀;</li>\n<li>自定义异常Exception结尾;</li>\n<li>for循环内部使用ijk,其他不允许;</li>\n<li>数组名称使用复数;</li>\n<li>常量枚举使用大写+下划线;</li>\n<li>成员变量使用前缀m(member),静态变量使用前缀s(static);</li>\n<li>控件变量添加组件前缀,并在所有者前缀之后;</li>\n<li>除单例模式一般不使用静态变量;</li>\n<li>常量使用 static final修饰;</li>\n<li>构造方法的顺序根据参数多少使用递增方式;</li>\n<li>项目内使用的实体类不使用javaBean封装,访问修饰符使用非private;</li>\n<li>成员变量不可随意修改的内容使用下划线进行区分;</li>\n<li>使用Log打印输出;</li>\n<li>使用BuildConfig.DEBUG标记对Log进行封装，只在调试时输出重要信息，正式版不输出;</li>\n<li>try.catch只捕获需要的异常,且catch的异常信息应该输出;</li>\n</ol>\n</li>\n<li><p>res文件夹内容:</p>\n<ol>\n<li>资源命名使用小写+下划线;</li>\n<li>常用的布局文件的前缀:activity,dialog,item,popup,window;</li>\n<li>图片使用格式:<strong>性质前缀_ 功能模块_ 属性后缀.扩展名</strong>(属性后缀:pressed,disable,normal,checked,selector等.);</li>\n<li>values目录下的文件名称:arrays,attrs,colors,dimens,drawables,strings,styles.</li>\n</ol>\n</li>\n<li><p>注释:</p>\n<ol>\n<li>开源项目必要文件注释,非开源项目建议添加;/*…</li>\n<li>类写类注释,接口写接口注释,变量常量添加属性注释,关联性大的可以使用一条注释.</li>\n<li>public protected必须添加方法注释,其他建议添加注释,重写方法子类可以不写注释.</li>\n<li>弃用的使用@Deprecated;</li>\n<li>switch每一项添加说明;</li>\n<li>if条件多于2个必须写注释;</li>\n<li><strong>未完成的函数使用//TODO:…标记</strong></li>\n<li><strong>有潜在问题的使用//XXX:…进行标记.</strong></li>\n<li><strong>代码存在严重问题或用于调试,使用//FIXME:…标记,不能作为正式版发布;</strong></li>\n<li>for,while过长使用标记</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"屏幕适配\"><a href=\"#屏幕适配\" class=\"headerlink\" title=\"屏幕适配\"></a>屏幕适配</h2><ol>\n<li><p>屏幕尺寸:对角线长度,单位是英寸.1英寸=2.54厘米,</p>\n<pre><code>常见的屏幕尺寸有2.4、2.8、3.5、3.7、4.2、5.0、5.5、6.0等;\n</code></pre></li>\n<li><p>分辨率:单位为px.1px = 1像素点.</p>\n<pre><code>常用表示 1280(px)×720(px);\n</code></pre></li>\n<li><p>像素密度:每英寸有多少像素,单位dpi;</p>\n<pre><code>计算方法如:开根(1280 * 1280+720 * 720)/屏幕尺寸;\n</code></pre></li>\n<li>单位比较:<ol>\n<li>dp=dip(密度无关像素),以160dpi为基准，1dp=1px,320dpi下，1dp=2px;</li>\n<li>dpi：屏幕像素密度的单位，“dot per inch”的缩写;</li>\n<li>sp：Scale-Independent Pixels的缩写，可以根据文字大小首选项自动进行缩放。Google推荐我们使用12sp以上的大小，最好不要使用奇数和小数。</li>\n</ol>\n</li>\n<li><p>尺寸比例</p>\n<pre><code>mdpi：hdpi：xhdpi：xxhdpi：xxxhdpi=2：3：4：6：8;\n</code></pre></li>\n<li><p>支持屏幕尺寸的解决方案</p>\n<ol>\n<li>使用wrap_ content、math_ parent、weight;</li>\n<li>使用相对布局，禁用绝对布局;</li>\n<li><p>使用限定符.</p>\n<ol>\n<li>large:程序运行在屏幕尺寸大于7inch的设备上，系统就会加载<code>res/layout-large/activity_main.xml</code>，在小于7inch的设备上就会加载<code>res/layout/activity_main.xml</code>.<strong>适用于android3.2之前.</strong></li>\n<li>最小宽度限定符<pre><code>`layout-sw600dp`文件夹(Small Width 最小宽度)\n</code></pre></li>\n<li><p>使用布局别名</p>\n<pre><code>`res/layout/main.xml`: 单面板布局\n`res/layout-large/main.xml`: 多面板布局\n`res/layout-sw600dp/main.xml`: 多面板布局\n</code></pre><p> 由于后两个文具文件一样，我们可以用以下两个文件代替上面三个布局文件：</p>\n<pre><code>res/layout/main.xml单面板布局\nres/layout/main_twopanes.xml双面板布局\n</code></pre><p> 然后在res下建立</p>\n<pre><code>`res/values/layout.xml`、\n`res/values-large/layout.xml`、\n`res/values-sw600dp/layout.xml`三个文件。\n</code></pre><p> 默认布局<br> <code>res/values/layout.xml</code>:</p>\n<pre><code>&lt;resources&gt;\n  &lt;item name=&quot;main&quot; type=&quot;layout&quot;&gt;@layout/main&lt;/item&gt;\n&lt;/resources&gt;\n</code></pre><p> Android3.2之前的平板布局<br> <code>res/values-large/layout.xml</code>:</p>\n<pre><code>&lt;resources&gt;\n  &lt;item name=&quot;main&quot; type=&quot;layout&quot;&gt;@layout/main_twopanes&lt;/item&gt;\n&lt;/resources&gt;\n</code></pre><p> Android3.2之后的平板布局<br> <code>res/values-sw600dp/layout.xml</code>:</p>\n<pre><code>&lt;resources&gt;\n  &lt;item name=&quot;main&quot; type=&quot;layout&quot;&gt;@layout/main_twopanes&lt;/item&gt;\n&lt;/resources&gt;\n</code></pre><p> 这样就有了main为别名的布局。<br> 在activity中<code>setContentView(R.layout.main)</code>;</p>\n<p> 这样，程序在运行时，就会检测手机的屏幕大小，如果是平板设备就会加载<code>res/layout/main_twopanes.xml</code>，如果是手机设备，就会加载<code>res/layout/main.xml</code>。我们就解决了只使用一个布局文件来适配android3.2前后的所有平板设备。</p>\n</li>\n<li><p>屏幕方向限定符</p>\n<p> 如果我们要求给横屏、竖屏显示的布局不一样。就可以使用屏幕方向限定符来实现。<br> 例如，要在平板上实现横竖屏显示不用的布局，可以用以下方式实现。<br> <code>res/values-sw600dp-land/layouts.xml</code>:横屏</p>\n<pre><code>&lt;resources&gt;\n  &lt;item name=&quot;main&quot; type=&quot;layout&quot;&gt;@layout/main_twopanes&lt;/item&gt;\n&lt;/resources&gt;\n</code></pre><p> <code>res/values-sw600dp-port/layouts.xml</code>:竖屏</p>\n<pre><code>&lt;resources&gt;\n  &lt;item name=&quot;main&quot; type=&quot;layout&quot;&gt;@layout/main&lt;/item&gt;\n&lt;/resources&gt;\n</code></pre></li>\n<li>使用.9.png</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>支持屏幕密度的解决方案</p>\n<pre><code>1. 将任何设备的手机密度像素分为320份*480份,当使用dp时使用对应的参数px即可\n2. 使用备用位图,每个文件夹下放置符合比例的资源文件,系统自动加载,否则很大程度耗费内存;\n</code></pre></li>\n<li><p>不同布局可能导致不同的操作,应该对应不同的逻辑判断.</p>\n</li>\n</ol>\n"},{"_content":"","source":"_posts/Android之Java基础.md","raw":"","slug":"Android之Java基础","published":1,"date":"2018-03-21T04:27:50.879Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtcar0000to4lhkp8lc6p","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之Kotlin.md","raw":"","slug":"Android之Kotlin","published":1,"date":"2018-03-21T04:27:50.880Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtcaw0001to4l0z7ognz1","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之代码框架——MVC,MVP,MVVM.md","raw":"","slug":"Android之代码框架——MVC,MVP,MVVM","published":1,"date":"2018-03-21T04:27:50.891Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtcaz0002to4lhv8no8dt","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之Linux.md","raw":"","slug":"Android之Linux","published":1,"date":"2018-03-21T04:27:50.881Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtcb00003to4lg8uxwvzl","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之发布优化——修复健壮.md","raw":"","slug":"Android之发布优化——修复健壮","published":1,"date":"2018-03-21T04:27:50.908Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtcb10004to4l5tc1th68","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之发布优化——适配.md","raw":"","slug":"Android之发布优化——适配","published":1,"date":"2018-03-21T04:27:50.906Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtcb20005to4lefs2vsq8","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之发布优化——加固.md","raw":"","slug":"Android之发布优化——加固","published":1,"date":"2018-03-21T04:27:50.905Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtcb30006to4le90ory29","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之多媒体——图像.md","raw":"","slug":"Android之多媒体——图像","published":1,"date":"2018-03-21T04:27:50.896Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtcb40007to4l1zoli2u9","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之多媒体——VR,AR.md","raw":"","slug":"Android之多媒体——VR,AR","published":1,"date":"2018-03-21T04:27:50.894Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtcb50008to4lq02wzbsv","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之多媒体——文档.md","raw":"","slug":"Android之多媒体——文档","published":1,"date":"2018-03-21T04:27:50.896Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtcb60009to4lo6me89lb","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之多媒体——文件.md","raw":"","slug":"Android之多媒体——文件","published":1,"date":"2018-03-21T04:27:50.897Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtcb7000ato4lqzerxpwf","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之多媒体——直播.md","raw":"","slug":"Android之多媒体——直播","published":1,"date":"2018-03-21T04:27:50.900Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtcb8000bto4l7bssq1tu","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之多媒体——视频.md","raw":"","slug":"Android之多媒体——视频","published":1,"date":"2018-03-21T04:27:50.895Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtcb9000cto4lniwc4fo1","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之多媒体——语音.md","raw":"","slug":"Android之多媒体——语音","published":1,"date":"2018-03-21T04:27:50.899Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtcba000dto4ldxxr9iu1","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之多媒体——音频.md","raw":"","slug":"Android之多媒体——音频","published":1,"date":"2018-03-21T04:27:50.898Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtcba000eto4lm7tia3dc","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之显示——Dialog.md","raw":"","slug":"Android之显示——Dialog","published":1,"date":"2018-03-21T04:27:50.935Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtcbb000fto4lhytzvpha","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之显示——Material Design.md","raw":"","slug":"Android之显示——Material Design","published":1,"date":"2018-03-21T04:27:50.937Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtcbc000gto4lgd9x9mne","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之插件化.md","raw":"","slug":"Android之插件化","published":1,"date":"2018-03-21T04:27:50.882Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtcbd000hto4lxszkr7ny","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之显示——NavigationView.md","raw":"","slug":"Android之显示——NavigationView","published":1,"date":"2018-03-21T04:27:50.939Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtcbd000ito4lb859283x","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之显示——StatusBar,ActionBar,Toolbar.md","raw":"","slug":"Android之显示——StatusBar,ActionBar,Toolbar","published":1,"date":"2018-03-21T04:27:50.942Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtcbe000jto4licsdf7rk","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之显示——Theme&Style.md","raw":"","slug":"Android之显示——Theme&Style","published":1,"date":"2018-03-21T04:27:50.944Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtccg000kto4l25q7j035","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之显示——输入法键盘.md","raw":"","slug":"Android之显示——输入法键盘","published":1,"date":"2018-03-21T04:27:50.946Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtcci000lto4lgu4715cr","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之桌面插件.md","raw":"","slug":"Android之桌面插件","published":1,"date":"2018-03-21T04:27:50.951Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtccj000mto4lvdxwme32","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之模块——Camera.md","raw":"","slug":"Android之模块——Camera","published":1,"date":"2018-03-21T04:27:50.912Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtcck000nto4liozm733q","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之模块——HIFI.md","raw":"","slug":"Android之模块——HIFI","published":1,"date":"2018-03-21T04:27:50.913Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtcck000oto4l9fn7vhsy","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之模块——电源.md","raw":"","slug":"Android之模块——电源","published":1,"date":"2018-03-21T04:27:50.914Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtccl000pto4ltyxyantu","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之模块——NFC.md","raw":"","slug":"Android之模块——NFC","published":1,"date":"2018-03-21T04:27:50.913Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtccm000qto4lx7yc7h9m","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之模块——系统信息.md","raw":"","slug":"Android之模块——系统信息","published":1,"date":"2018-03-21T04:27:50.918Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtccm000rto4lirgqakcf","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之模块——蓝牙.md","raw":"","slug":"Android之模块——蓝牙","published":1,"date":"2018-03-21T04:27:50.915Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtccn000sto4l5g9xehmn","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之模块——录音.md","raw":"","slug":"Android之模块——录音","published":1,"date":"2018-03-21T04:27:50.917Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtcco000tto4lkyv6pfg8","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之模块——闪光灯&通知指示灯.md","raw":"","slug":"Android之模块——闪光灯&通知指示灯","published":1,"date":"2018-03-21T04:27:50.917Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtcco000uto4l8652cajt","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之源码——Framework分析.md","raw":"","slug":"Android之源码——Framework分析","published":1,"date":"2018-03-21T04:27:50.948Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtccp000vto4l3p9znwtj","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之模块——震动.md","raw":"","slug":"Android之模块——震动","published":1,"date":"2018-03-21T04:27:50.919Z","updated":"2017-08-25T03:03:33.622Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtccp000wto4lvwwhunxx","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之源码——三方View源码分析.md","raw":"","slug":"Android之源码——三方View源码分析","published":1,"date":"2018-03-21T04:27:50.950Z","updated":"2017-08-25T03:03:33.638Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtccq000xto4l5n447afl","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之辅助——插件及操作.md","raw":"","slug":"Android之辅助——插件及操作","published":1,"date":"2018-03-21T04:27:50.911Z","updated":"2017-08-25T03:03:33.638Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtccr000yto4lluo59mei","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之源码——原生View源码分析.md","raw":"","slug":"Android之源码——原生View源码分析","published":1,"date":"2018-03-21T04:27:50.950Z","updated":"2018-01-04T10:06:55.989Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtccr000zto4lns83auuc","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之算法.md","raw":"","slug":"Android之算法","published":1,"date":"2018-03-21T04:27:50.927Z","updated":"2017-08-25T03:03:33.638Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtccs0010to4lv5fntefz","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之通信——断续上传.md","raw":"","slug":"Android之通信——断续上传","published":1,"date":"2018-03-21T04:27:50.932Z","updated":"2017-08-25T03:03:33.638Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtccs0011to4ls2imk2tn","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之通信——文件下载.md","raw":"","slug":"Android之通信——文件下载","published":1,"date":"2018-03-21T04:27:50.934Z","updated":"2017-08-25T03:03:33.638Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtcct0012to4lpbvu4lqd","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android之通信——网络框架.md","raw":"","slug":"Android之通信——网络框架","published":1,"date":"2018-03-21T04:27:50.934Z","updated":"2017-08-25T03:03:33.638Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0mtch20013to4l2n34t856","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Android MotionEvent","_content":"\n# MotionEvent\n\n\t\t1. 不常用事件;\n\t\t2. 多点触控事件;\n\t\t3. 历史数据(事件批处理);\n\t\t4. 获取事件发生的时间;\n\t\t5. 获取压力(接触面积大小);\n\t\t6. 鼠标事件;\n\t\t参考自: http://www.gcssloop.com/customview/motionevent\n---\n\n事件 |\t简介\n-|-\n`ACTION_DOWN`\t\t\t|手指 初次接触到屏幕 时触发。\n`ACTION_MOVE`\t\t\t|手指 在屏幕上滑动 时触发，会多次触发。\n`ACTION_UP`\t\t\t\t|手指 离开屏幕 时触发。\n`ACTION_CANCEL`\t\t\t|事件 **被上层拦截** 时触发。\n`ACTION_OUTSIDE`\t\t|手指 **不在控件区域** 时触发。\n`ACTION_POINTER_DOWN`\t|有**非主要**的手指**按下**(即按下之前已经有手指在屏幕上)。\n`ACTION_POINTER_UP`\t\t|有**非主要**的手指**抬起**(即抬起之后仍然有手指在屏幕上)。\n\n\n### 不常用事件之`ACTION_CANCEL` ###\n**父容器在判断了事件之后对事件处理权的收回,`childView`收到`ACTION_CANCEL`不会收到后续事件。**\n\n> `RecyclerView`：儿砸，这里有一个 `ACTION_DOWN` 你看你要不要。\n> `ItemView` ：好嘞，我看看。\n> `RecyclerView`：噫？居然是移动事件 `ACTION_MOVE`，我要滚起来了，儿砸，我可能要把你送去你姑父家(缓存区)了，在这之前给你一个 `ACTION_CANCEL`，你要收好啊。\n> `ItemView` ：……\n\n---\n\n### 不常用事件之`ACTION_OUTSIDE` ###\n视图所在的`WindowManager`设置了`FLAG_WATCH_OUTSIDE_TOUCH`的`flag`后才能收到的动作。\n\n---\n\n### 多点触控 ###\n**通过多点编号完成指针判断。第一次按下的手指特殊处理作为主指针，之后按下的手指作为辅助指针。**\n\n\n方法|\t简介\n-|-\n`ev.getActionMasked()`\t\t\t\t\t|与 `getAction()` 类似，**多点触控必须使用这个方法获取事件类型**。\n~~`ev.getActionIndex()`~~\t\t\t\t\t|~~获取该事件是哪个指针(手指)产生的。~~\n`ev.getPointerCount()`\t\t\t\t\t|获取在屏幕上手指的个数。\n`ev.getPointerId(int pointerIndex)`\t\t|获取一个指针(手指)的唯一标识符ID，在手指按下和抬起之间ID始终不变。\n`ev.findPointerIndex(int pointerId)`\t|通过`PointerId`获取到当前状态下`PointIndex`，之后通过`PointIndex`获取其他内容。\n`ev.getX(int pointerIndex )`\t\t\t\t|获取某一个指针(手指)的X坐标\n`ev.getY(int pointerIndex )`\t\t\t\t|获取某一个指针(手指)的Y坐标\n\n\n> 当多个手指在屏幕上按下的时候，会产生大量的事件，如何在获取事件类型的同时区分这些事件就是一个大问题了。一般来说我们可以通过为事件添加一个int类型的index属性来区分，但是谷歌工程师是有洁癖的，<font color=blue>**为了添加一个通常数值不会超过10的index属性就浪费一个int大小的空间简直是不能忍受的**</font>，于是工程师们将这个index属性和事件类型直接合并了。int类型共32位(0x00000000)，他们用最低8位(0x000000**ff**)表示事件类型，再往前的8位(0x0000**ff**00)表示事件编号。\n\n手指按下\t| 触发事件(数值)\n-|-\n第1个手指按下\t| `ACTION_DOWN` (0x0000**00**00)\n---\t\t\t|`ACTION_POINTER_DOWN`(0x0000**00**05)\n第2个手指按下\t| `ACTION_POINTER_2_DOWN` (0x0000**01**05)\n第3个手指按下\t| `ACTION_POINTER_3_DOWN` (0x0000**02**05)\n第4个手指按下\t| `ACTION_POINTER_4_DOWN` (0x0000**03**05)\n\n> 注意：\n> 上面表格中用粗体标示出的数值，可以看到随着按下手指数量的增加，这个数值也是一直变化的，进而导致我们使用 `getAction()` 获取到的数值无法与标准的事件类型进行对比，为了解决这个问题，他们创建了一个 `getActionMasked()` 方法，这个方法可以清除index数值，让其变成一个标准的事件类型。\n**<font color=black> 1、多点触控时必须使用 `getActionMasked()` 来获取事件类型。\n2、单点触控时由于事件数值不变，使用 `getAction()` 和 `getActionMasked()` 两个方法都可以。\n3、使用 `getActionIndex()` 可以获取到这个index数值。不过请注意，`getActionIndex()` 只在 down 和 up 时有效，move 时是无效的。</font>**\n\n>目前来说获取事件类型使用 `getActionMasked()` 就行了，但是如果一定要编译时兼容古董版本的话，可以考虑使用这样的写法:\n\n```java\n\tfinal int action = (Build.VERSION.SDK_INT >= Build.VERSION_CODES.FROYO)\n\t                ? event.getActionMasked()\n\t                : event.getAction();\n\tswitch (action){\n\t    case MotionEvent.ACTION_DOWN:\n\t        // TODO\n\t        break;\n\t}\n```\n\n---\n### 历史数据(事件批处理) ###\n由于我们的设备非常灵敏，手指稍微移动一下就会产生一个移动事件，所以移动事件会产生的特别频繁，为了提高效率，<font color=red>**系统会将近期的多个移动事件(move)按照事件发生的顺序进行排序打包放在同一个 MotionEvent 中**</font>，与之对应的产生了以下方法：\n\n事件 |\t简介\n-|-\n`ev.getHistorySize()`\t|获取历史事件集合大小\n`ev.getHistoricalX(int pos)`\t|获取第pos个历史事件x坐标 <br>`(pos < getHistorySize())`\n`ev.getHistoricalY(int pos)`\t|获取第pos个历史事件y坐标 <br>`(pos < getHistorySize())`\n`ev.getHistoricalX (int pin, int pos)`\t|获取第pin个手指的第pos个历史事件x坐标 <br>`(pin < getPointerCount(), pos < getHistorySize() )`\n`ev.getHistoricalY (int pin, int pos)\t`|获取第pin个手指的第pos个历史事件y坐标 <br>`(pin < getPointerCount(), pos < getHistorySize() )`\n注意：\n- pin 全称是 `pointerIndex`，表示第几个手指，此处为了节省空间使用了缩写。\n- <font color=red> 历史数据只有 `ACTION_MOVE` 事件。</font>\n- 历史数据单点触控和多点触控均可以用。\n\n下面是官方文档给出的一个简单使用示例：\n\n```java\n\tvoid printSamples(MotionEvent ev) {\n\t     final int historySize = ev.getHistorySize();\n\t     final int pointerCount = ev.getPointerCount();\n\t     for (int h = 0; h < historySize; h++) {\n\t         System.out.printf(\"At time %d:\", ev.getHistoricalEventTime(h));\n\t         for (int p = 0; p < pointerCount; p++) {\n\t             System.out.printf(\"  pointer %d: (%f,%f)\",\n\t                 ev.getPointerId(p), ev.getHistoricalX(p, h), ev.getHistoricalY(p, h));\n\t         }\n\t     }\n\t     System.out.printf(\"At time %d:\", ev.getEventTime());\n\t     for (int p = 0; p < pointerCount; p++) {\n\t         System.out.printf(\"  pointer %d: (%f,%f)\",\n\t             ev.getPointerId(p), ev.getX(p), ev.getY(p));\n\t     }\n\t}\n```\n---\n### 获取事件发生的时间 ###\n\n方法\t| 简介\n-|- \n`getDownTime()`\t\t\t\t\t\t|获取手指按下时的时间。\n`getEventTime()`\t\t\t\t\t|获取当前事件发生的时间。\n`getHistoricalEventTime(int pos)`\t|获取历史事件发生的时间。\n\n> pos 表示历史数据中的第几个数据。( pos < getHistorySize() )\n> 返回值类型为 long，单位是毫秒。\n\n---\n\n### 获取压力(接触面积大小) ###\nMotionEvent支持获取某些输入设备(手指或触控笔)的与屏幕的接触面积和压力大小，主要有以下方法：\n\n>描述中使用了手指，触控笔也是一样的。\n\n方法\t\t|\t简介\n-|- \n`getSize ()`\t\t\t\t\t\t\t\t|获取第1个手指与屏幕接触面积的大小\n`getSize (int pin)`\t|获取第pin个手指与屏幕接触面积的大小\n`getHistoricalSize (int pos)`\t|获取历史数据中第1个手指在第pos次事件中的接触面积\n`getHistoricalSize (int pin, int pos)`\t\t|获取历史数据中第pin个手指在第pos次事件中的接触面积\n`getPressure ()`\t|获取第一个手指的压力大小\n`getPressure (int pin)`\t|获取第pin个手指的压力大小\n`getHistoricalPressure (int pos)`\t|获取历史数据中第1个手指在第pos次事件中的压力大小\n`getHistoricalPressure (int pin, int pos)`\t|获取历史数据中第pin个手指在第pos次事件中的压力大小\n\n> pin 全称是 pointerIndex，表示第几个手指。`(pin < getPointerCount() )`\n> pos 表示历史数据中的第几个数据。`( pos < getHistorySize() )`\n\n注意：\n1. 获取接触面积大小和获取压力大小是需要硬件支持的。\n2. 非常不幸的是<font color=red>**大部分设备所使用的电容屏不支持压力检测**</font>，但能够大致检测出接触面积。\n3. <font color=red>大部分设备的 `getPressure()` 是使用接触面积来模拟的</font>。\n4. 由于某些未知的原因(可能系统版本和硬件问题)，某些设备不支持 `getPressure()`。\n5. 系统问题造成<font color=blue>**有的设备上只有` getSize() `能用，有的设备上只有 `getPressure()` 能用，而有的则两个都不能用**</font>。\n\n由于获取接触面积和获取压力大小受系统和硬件影响，使用的时候一定要进行数据检测，以防因为设备问题而导致程序出错。\n\n--- \n### 鼠标事件 ###\n由于触控笔事件和手指事件处理流程大致相同，与鼠标相关的几个事件：\n\n事件 |\t简介\n-|- \n`ACTION_HOVER_ENTER`|指针移入到窗口或者View区域，但没有按下。\n`ACTION_HOVER_MOVE`\t|指针在窗口或者View区域移动，但没有按下。\n`ACTION_HOVER_EXIT`\t|指针移出到窗口或者View区域，但没有按下。\n`ACTION_SCROLL`\t\t|滚轮滚动，可以触发水平滚动(`AXIS_HSCROLL`)或者垂直滚动(`AXIS_VSCROLL`)\n\n注意：\n\n1. 这些事件类型是 安卓4.0 (API 14) 才添加的。\n2. 使用 ` getActionMasked()` 获得这些事件类型。\n3. 这些事件不会传递到 `onTouchEvent(MotionEvent)` 而是传递到 `onGenericMotionEvent(MotionEvent)` 。\n\n---","source":"_posts/Android之自定义控件——事件之MotionEvent.md","raw":"---\n\ntitle: Android MotionEvent\ncategories: \"android 总结\"\ntags: \n     - android\n     - MotionEvent\n \n---\n\n# MotionEvent\n\n\t\t1. 不常用事件;\n\t\t2. 多点触控事件;\n\t\t3. 历史数据(事件批处理);\n\t\t4. 获取事件发生的时间;\n\t\t5. 获取压力(接触面积大小);\n\t\t6. 鼠标事件;\n\t\t参考自: http://www.gcssloop.com/customview/motionevent\n---\n\n事件 |\t简介\n-|-\n`ACTION_DOWN`\t\t\t|手指 初次接触到屏幕 时触发。\n`ACTION_MOVE`\t\t\t|手指 在屏幕上滑动 时触发，会多次触发。\n`ACTION_UP`\t\t\t\t|手指 离开屏幕 时触发。\n`ACTION_CANCEL`\t\t\t|事件 **被上层拦截** 时触发。\n`ACTION_OUTSIDE`\t\t|手指 **不在控件区域** 时触发。\n`ACTION_POINTER_DOWN`\t|有**非主要**的手指**按下**(即按下之前已经有手指在屏幕上)。\n`ACTION_POINTER_UP`\t\t|有**非主要**的手指**抬起**(即抬起之后仍然有手指在屏幕上)。\n\n\n### 不常用事件之`ACTION_CANCEL` ###\n**父容器在判断了事件之后对事件处理权的收回,`childView`收到`ACTION_CANCEL`不会收到后续事件。**\n\n> `RecyclerView`：儿砸，这里有一个 `ACTION_DOWN` 你看你要不要。\n> `ItemView` ：好嘞，我看看。\n> `RecyclerView`：噫？居然是移动事件 `ACTION_MOVE`，我要滚起来了，儿砸，我可能要把你送去你姑父家(缓存区)了，在这之前给你一个 `ACTION_CANCEL`，你要收好啊。\n> `ItemView` ：……\n\n---\n\n### 不常用事件之`ACTION_OUTSIDE` ###\n视图所在的`WindowManager`设置了`FLAG_WATCH_OUTSIDE_TOUCH`的`flag`后才能收到的动作。\n\n---\n\n### 多点触控 ###\n**通过多点编号完成指针判断。第一次按下的手指特殊处理作为主指针，之后按下的手指作为辅助指针。**\n\n\n方法|\t简介\n-|-\n`ev.getActionMasked()`\t\t\t\t\t|与 `getAction()` 类似，**多点触控必须使用这个方法获取事件类型**。\n~~`ev.getActionIndex()`~~\t\t\t\t\t|~~获取该事件是哪个指针(手指)产生的。~~\n`ev.getPointerCount()`\t\t\t\t\t|获取在屏幕上手指的个数。\n`ev.getPointerId(int pointerIndex)`\t\t|获取一个指针(手指)的唯一标识符ID，在手指按下和抬起之间ID始终不变。\n`ev.findPointerIndex(int pointerId)`\t|通过`PointerId`获取到当前状态下`PointIndex`，之后通过`PointIndex`获取其他内容。\n`ev.getX(int pointerIndex )`\t\t\t\t|获取某一个指针(手指)的X坐标\n`ev.getY(int pointerIndex )`\t\t\t\t|获取某一个指针(手指)的Y坐标\n\n\n> 当多个手指在屏幕上按下的时候，会产生大量的事件，如何在获取事件类型的同时区分这些事件就是一个大问题了。一般来说我们可以通过为事件添加一个int类型的index属性来区分，但是谷歌工程师是有洁癖的，<font color=blue>**为了添加一个通常数值不会超过10的index属性就浪费一个int大小的空间简直是不能忍受的**</font>，于是工程师们将这个index属性和事件类型直接合并了。int类型共32位(0x00000000)，他们用最低8位(0x000000**ff**)表示事件类型，再往前的8位(0x0000**ff**00)表示事件编号。\n\n手指按下\t| 触发事件(数值)\n-|-\n第1个手指按下\t| `ACTION_DOWN` (0x0000**00**00)\n---\t\t\t|`ACTION_POINTER_DOWN`(0x0000**00**05)\n第2个手指按下\t| `ACTION_POINTER_2_DOWN` (0x0000**01**05)\n第3个手指按下\t| `ACTION_POINTER_3_DOWN` (0x0000**02**05)\n第4个手指按下\t| `ACTION_POINTER_4_DOWN` (0x0000**03**05)\n\n> 注意：\n> 上面表格中用粗体标示出的数值，可以看到随着按下手指数量的增加，这个数值也是一直变化的，进而导致我们使用 `getAction()` 获取到的数值无法与标准的事件类型进行对比，为了解决这个问题，他们创建了一个 `getActionMasked()` 方法，这个方法可以清除index数值，让其变成一个标准的事件类型。\n**<font color=black> 1、多点触控时必须使用 `getActionMasked()` 来获取事件类型。\n2、单点触控时由于事件数值不变，使用 `getAction()` 和 `getActionMasked()` 两个方法都可以。\n3、使用 `getActionIndex()` 可以获取到这个index数值。不过请注意，`getActionIndex()` 只在 down 和 up 时有效，move 时是无效的。</font>**\n\n>目前来说获取事件类型使用 `getActionMasked()` 就行了，但是如果一定要编译时兼容古董版本的话，可以考虑使用这样的写法:\n\n```java\n\tfinal int action = (Build.VERSION.SDK_INT >= Build.VERSION_CODES.FROYO)\n\t                ? event.getActionMasked()\n\t                : event.getAction();\n\tswitch (action){\n\t    case MotionEvent.ACTION_DOWN:\n\t        // TODO\n\t        break;\n\t}\n```\n\n---\n### 历史数据(事件批处理) ###\n由于我们的设备非常灵敏，手指稍微移动一下就会产生一个移动事件，所以移动事件会产生的特别频繁，为了提高效率，<font color=red>**系统会将近期的多个移动事件(move)按照事件发生的顺序进行排序打包放在同一个 MotionEvent 中**</font>，与之对应的产生了以下方法：\n\n事件 |\t简介\n-|-\n`ev.getHistorySize()`\t|获取历史事件集合大小\n`ev.getHistoricalX(int pos)`\t|获取第pos个历史事件x坐标 <br>`(pos < getHistorySize())`\n`ev.getHistoricalY(int pos)`\t|获取第pos个历史事件y坐标 <br>`(pos < getHistorySize())`\n`ev.getHistoricalX (int pin, int pos)`\t|获取第pin个手指的第pos个历史事件x坐标 <br>`(pin < getPointerCount(), pos < getHistorySize() )`\n`ev.getHistoricalY (int pin, int pos)\t`|获取第pin个手指的第pos个历史事件y坐标 <br>`(pin < getPointerCount(), pos < getHistorySize() )`\n注意：\n- pin 全称是 `pointerIndex`，表示第几个手指，此处为了节省空间使用了缩写。\n- <font color=red> 历史数据只有 `ACTION_MOVE` 事件。</font>\n- 历史数据单点触控和多点触控均可以用。\n\n下面是官方文档给出的一个简单使用示例：\n\n```java\n\tvoid printSamples(MotionEvent ev) {\n\t     final int historySize = ev.getHistorySize();\n\t     final int pointerCount = ev.getPointerCount();\n\t     for (int h = 0; h < historySize; h++) {\n\t         System.out.printf(\"At time %d:\", ev.getHistoricalEventTime(h));\n\t         for (int p = 0; p < pointerCount; p++) {\n\t             System.out.printf(\"  pointer %d: (%f,%f)\",\n\t                 ev.getPointerId(p), ev.getHistoricalX(p, h), ev.getHistoricalY(p, h));\n\t         }\n\t     }\n\t     System.out.printf(\"At time %d:\", ev.getEventTime());\n\t     for (int p = 0; p < pointerCount; p++) {\n\t         System.out.printf(\"  pointer %d: (%f,%f)\",\n\t             ev.getPointerId(p), ev.getX(p), ev.getY(p));\n\t     }\n\t}\n```\n---\n### 获取事件发生的时间 ###\n\n方法\t| 简介\n-|- \n`getDownTime()`\t\t\t\t\t\t|获取手指按下时的时间。\n`getEventTime()`\t\t\t\t\t|获取当前事件发生的时间。\n`getHistoricalEventTime(int pos)`\t|获取历史事件发生的时间。\n\n> pos 表示历史数据中的第几个数据。( pos < getHistorySize() )\n> 返回值类型为 long，单位是毫秒。\n\n---\n\n### 获取压力(接触面积大小) ###\nMotionEvent支持获取某些输入设备(手指或触控笔)的与屏幕的接触面积和压力大小，主要有以下方法：\n\n>描述中使用了手指，触控笔也是一样的。\n\n方法\t\t|\t简介\n-|- \n`getSize ()`\t\t\t\t\t\t\t\t|获取第1个手指与屏幕接触面积的大小\n`getSize (int pin)`\t|获取第pin个手指与屏幕接触面积的大小\n`getHistoricalSize (int pos)`\t|获取历史数据中第1个手指在第pos次事件中的接触面积\n`getHistoricalSize (int pin, int pos)`\t\t|获取历史数据中第pin个手指在第pos次事件中的接触面积\n`getPressure ()`\t|获取第一个手指的压力大小\n`getPressure (int pin)`\t|获取第pin个手指的压力大小\n`getHistoricalPressure (int pos)`\t|获取历史数据中第1个手指在第pos次事件中的压力大小\n`getHistoricalPressure (int pin, int pos)`\t|获取历史数据中第pin个手指在第pos次事件中的压力大小\n\n> pin 全称是 pointerIndex，表示第几个手指。`(pin < getPointerCount() )`\n> pos 表示历史数据中的第几个数据。`( pos < getHistorySize() )`\n\n注意：\n1. 获取接触面积大小和获取压力大小是需要硬件支持的。\n2. 非常不幸的是<font color=red>**大部分设备所使用的电容屏不支持压力检测**</font>，但能够大致检测出接触面积。\n3. <font color=red>大部分设备的 `getPressure()` 是使用接触面积来模拟的</font>。\n4. 由于某些未知的原因(可能系统版本和硬件问题)，某些设备不支持 `getPressure()`。\n5. 系统问题造成<font color=blue>**有的设备上只有` getSize() `能用，有的设备上只有 `getPressure()` 能用，而有的则两个都不能用**</font>。\n\n由于获取接触面积和获取压力大小受系统和硬件影响，使用的时候一定要进行数据检测，以防因为设备问题而导致程序出错。\n\n--- \n### 鼠标事件 ###\n由于触控笔事件和手指事件处理流程大致相同，与鼠标相关的几个事件：\n\n事件 |\t简介\n-|- \n`ACTION_HOVER_ENTER`|指针移入到窗口或者View区域，但没有按下。\n`ACTION_HOVER_MOVE`\t|指针在窗口或者View区域移动，但没有按下。\n`ACTION_HOVER_EXIT`\t|指针移出到窗口或者View区域，但没有按下。\n`ACTION_SCROLL`\t\t|滚轮滚动，可以触发水平滚动(`AXIS_HSCROLL`)或者垂直滚动(`AXIS_VSCROLL`)\n\n注意：\n\n1. 这些事件类型是 安卓4.0 (API 14) 才添加的。\n2. 使用 ` getActionMasked()` 获得这些事件类型。\n3. 这些事件不会传递到 `onTouchEvent(MotionEvent)` 而是传递到 `onGenericMotionEvent(MotionEvent)` 。\n\n---","slug":"Android之自定义控件——事件之MotionEvent","published":1,"date":"2018-03-21T05:35:40.027Z","updated":"2018-03-21T05:23:51.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0otqoj0000so4l5qqz87x0","content":"<h1 id=\"MotionEvent\"><a href=\"#MotionEvent\" class=\"headerlink\" title=\"MotionEvent\"></a>MotionEvent</h1><pre><code>1. 不常用事件;\n2. 多点触控事件;\n3. 历史数据(事件批处理);\n4. 获取事件发生的时间;\n5. 获取压力(接触面积大小);\n6. 鼠标事件;\n参考自: http://www.gcssloop.com/customview/motionevent\n</code></pre><hr>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>ACTION_DOWN</code></td>\n<td>手指 初次接触到屏幕 时触发。</td>\n</tr>\n<tr>\n<td><code>ACTION_MOVE</code></td>\n<td>手指 在屏幕上滑动 时触发，会多次触发。</td>\n</tr>\n<tr>\n<td><code>ACTION_UP</code></td>\n<td>手指 离开屏幕 时触发。</td>\n</tr>\n<tr>\n<td><code>ACTION_CANCEL</code></td>\n<td>事件 <strong>被上层拦截</strong> 时触发。</td>\n</tr>\n<tr>\n<td><code>ACTION_OUTSIDE</code></td>\n<td>手指 <strong>不在控件区域</strong> 时触发。</td>\n</tr>\n<tr>\n<td><code>ACTION_POINTER_DOWN</code></td>\n<td>有<strong>非主要</strong>的手指<strong>按下</strong>(即按下之前已经有手指在屏幕上)。</td>\n</tr>\n<tr>\n<td><code>ACTION_POINTER_UP</code></td>\n<td>有<strong>非主要</strong>的手指<strong>抬起</strong>(即抬起之后仍然有手指在屏幕上)。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"不常用事件之ACTION-CANCEL\"><a href=\"#不常用事件之ACTION-CANCEL\" class=\"headerlink\" title=\"不常用事件之ACTION_CANCEL\"></a>不常用事件之<code>ACTION_CANCEL</code></h3><p><strong>父容器在判断了事件之后对事件处理权的收回,<code>childView</code>收到<code>ACTION_CANCEL</code>不会收到后续事件。</strong></p>\n<blockquote>\n<p><code>RecyclerView</code>：儿砸，这里有一个 <code>ACTION_DOWN</code> 你看你要不要。<br><code>ItemView</code> ：好嘞，我看看。<br><code>RecyclerView</code>：噫？居然是移动事件 <code>ACTION_MOVE</code>，我要滚起来了，儿砸，我可能要把你送去你姑父家(缓存区)了，在这之前给你一个 <code>ACTION_CANCEL</code>，你要收好啊。<br><code>ItemView</code> ：……</p>\n</blockquote>\n<hr>\n<h3 id=\"不常用事件之ACTION-OUTSIDE\"><a href=\"#不常用事件之ACTION-OUTSIDE\" class=\"headerlink\" title=\"不常用事件之ACTION_OUTSIDE\"></a>不常用事件之<code>ACTION_OUTSIDE</code></h3><p>视图所在的<code>WindowManager</code>设置了<code>FLAG_WATCH_OUTSIDE_TOUCH</code>的<code>flag</code>后才能收到的动作。</p>\n<hr>\n<h3 id=\"多点触控\"><a href=\"#多点触控\" class=\"headerlink\" title=\"多点触控\"></a>多点触控</h3><p><strong>通过多点编号完成指针判断。第一次按下的手指特殊处理作为主指针，之后按下的手指作为辅助指针。</strong></p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>ev.getActionMasked()</code></td>\n<td>与 <code>getAction()</code> 类似，<strong>多点触控必须使用这个方法获取事件类型</strong>。</td>\n</tr>\n<tr>\n<td><del><code>ev.getActionIndex()</code></del></td>\n<td><del>获取该事件是哪个指针(手指)产生的。</del></td>\n</tr>\n<tr>\n<td><code>ev.getPointerCount()</code></td>\n<td>获取在屏幕上手指的个数。</td>\n</tr>\n<tr>\n<td><code>ev.getPointerId(int pointerIndex)</code></td>\n<td>获取一个指针(手指)的唯一标识符ID，在手指按下和抬起之间ID始终不变。</td>\n</tr>\n<tr>\n<td><code>ev.findPointerIndex(int pointerId)</code></td>\n<td>通过<code>PointerId</code>获取到当前状态下<code>PointIndex</code>，之后通过<code>PointIndex</code>获取其他内容。</td>\n</tr>\n<tr>\n<td><code>ev.getX(int pointerIndex )</code></td>\n<td>获取某一个指针(手指)的X坐标</td>\n</tr>\n<tr>\n<td><code>ev.getY(int pointerIndex )</code></td>\n<td>获取某一个指针(手指)的Y坐标</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>当多个手指在屏幕上按下的时候，会产生大量的事件，如何在获取事件类型的同时区分这些事件就是一个大问题了。一般来说我们可以通过为事件添加一个int类型的index属性来区分，但是谷歌工程师是有洁癖的，<font color=\"blue\"><strong>为了添加一个通常数值不会超过10的index属性就浪费一个int大小的空间简直是不能忍受的</strong></font>，于是工程师们将这个index属性和事件类型直接合并了。int类型共32位(0x00000000)，他们用最低8位(0x000000<strong>ff</strong>)表示事件类型，再往前的8位(0x0000<strong>ff</strong>00)表示事件编号。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>手指按下</th>\n<th>触发事件(数值)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>第1个手指按下</td>\n<td><code>ACTION_DOWN</code> (0x0000<strong>00</strong>00)</td>\n</tr>\n<tr>\n<td>—</td>\n<td><code>ACTION_POINTER_DOWN</code>(0x0000<strong>00</strong>05)</td>\n</tr>\n<tr>\n<td>第2个手指按下</td>\n<td><code>ACTION_POINTER_2_DOWN</code> (0x0000<strong>01</strong>05)</td>\n</tr>\n<tr>\n<td>第3个手指按下</td>\n<td><code>ACTION_POINTER_3_DOWN</code> (0x0000<strong>02</strong>05)</td>\n</tr>\n<tr>\n<td>第4个手指按下</td>\n<td><code>ACTION_POINTER_4_DOWN</code> (0x0000<strong>03</strong>05)</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>注意：<br>上面表格中用粗体标示出的数值，可以看到随着按下手指数量的增加，这个数值也是一直变化的，进而导致我们使用 <code>getAction()</code> 获取到的数值无法与标准的事件类型进行对比，为了解决这个问题，他们创建了一个 <code>getActionMasked()</code> 方法，这个方法可以清除index数值，让其变成一个标准的事件类型。<br><strong><font color=\"black\"> 1、多点触控时必须使用 <code>getActionMasked()</code> 来获取事件类型。<br>2、单点触控时由于事件数值不变，使用 <code>getAction()</code> 和 <code>getActionMasked()</code> 两个方法都可以。<br>3、使用 <code>getActionIndex()</code> 可以获取到这个index数值。不过请注意，<code>getActionIndex()</code> 只在 down 和 up 时有效，move 时是无效的。</font></strong></p>\n</blockquote>\n<blockquote>\n<p>目前来说获取事件类型使用 <code>getActionMasked()</code> 就行了，但是如果一定要编译时兼容古董版本的话，可以考虑使用这样的写法:</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> action = (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.FROYO)</span><br><span class=\"line\">                ? event.getActionMasked()</span><br><span class=\"line\">                : event.getAction();</span><br><span class=\"line\"><span class=\"keyword\">switch</span> (action)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> MotionEvent.ACTION_DOWN:</span><br><span class=\"line\">        <span class=\"comment\">// TODO</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"历史数据-事件批处理\"><a href=\"#历史数据-事件批处理\" class=\"headerlink\" title=\"历史数据(事件批处理)\"></a>历史数据(事件批处理)</h3><p>由于我们的设备非常灵敏，手指稍微移动一下就会产生一个移动事件，所以移动事件会产生的特别频繁，为了提高效率，<font color=\"red\"><strong>系统会将近期的多个移动事件(move)按照事件发生的顺序进行排序打包放在同一个 MotionEvent 中</strong></font>，与之对应的产生了以下方法：</p>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>ev.getHistorySize()</code></td>\n<td>获取历史事件集合大小</td>\n</tr>\n<tr>\n<td><code>ev.getHistoricalX(int pos)</code></td>\n<td>获取第pos个历史事件x坐标 <br><code>(pos &lt; getHistorySize())</code></td>\n</tr>\n<tr>\n<td><code>ev.getHistoricalY(int pos)</code></td>\n<td>获取第pos个历史事件y坐标 <br><code>(pos &lt; getHistorySize())</code></td>\n</tr>\n<tr>\n<td><code>ev.getHistoricalX (int pin, int pos)</code></td>\n<td>获取第pin个手指的第pos个历史事件x坐标 <br><code>(pin &lt; getPointerCount(), pos &lt; getHistorySize() )</code></td>\n</tr>\n<tr>\n<td><code>ev.getHistoricalY (int pin, int pos)</code></td>\n<td>获取第pin个手指的第pos个历史事件y坐标 <br><code>(pin &lt; getPointerCount(), pos &lt; getHistorySize() )</code></td>\n</tr>\n</tbody>\n</table>\n<p>注意：</p>\n<ul>\n<li>pin 全称是 <code>pointerIndex</code>，表示第几个手指，此处为了节省空间使用了缩写。</li>\n<li><font color=\"red\"> 历史数据只有 <code>ACTION_MOVE</code> 事件。</font></li>\n<li>历史数据单点触控和多点触控均可以用。</li>\n</ul>\n<p>下面是官方文档给出的一个简单使用示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printSamples</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> historySize = ev.getHistorySize();</span><br><span class=\"line\">     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> pointerCount = ev.getPointerCount();</span><br><span class=\"line\">     <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> h = <span class=\"number\">0</span>; h &lt; historySize; h++) &#123;</span><br><span class=\"line\">         System.out.printf(<span class=\"string\">\"At time %d:\"</span>, ev.getHistoricalEventTime(h));</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> p = <span class=\"number\">0</span>; p &lt; pointerCount; p++) &#123;</span><br><span class=\"line\">             System.out.printf(<span class=\"string\">\"  pointer %d: (%f,%f)\"</span>,</span><br><span class=\"line\">                 ev.getPointerId(p), ev.getHistoricalX(p, h), ev.getHistoricalY(p, h));</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     System.out.printf(<span class=\"string\">\"At time %d:\"</span>, ev.getEventTime());</span><br><span class=\"line\">     <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> p = <span class=\"number\">0</span>; p &lt; pointerCount; p++) &#123;</span><br><span class=\"line\">         System.out.printf(<span class=\"string\">\"  pointer %d: (%f,%f)\"</span>,</span><br><span class=\"line\">             ev.getPointerId(p), ev.getX(p), ev.getY(p));</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"获取事件发生的时间\"><a href=\"#获取事件发生的时间\" class=\"headerlink\" title=\"获取事件发生的时间\"></a>获取事件发生的时间</h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>getDownTime()</code></td>\n<td>获取手指按下时的时间。</td>\n</tr>\n<tr>\n<td><code>getEventTime()</code></td>\n<td>获取当前事件发生的时间。</td>\n</tr>\n<tr>\n<td><code>getHistoricalEventTime(int pos)</code></td>\n<td>获取历史事件发生的时间。</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>pos 表示历史数据中的第几个数据。( pos &lt; getHistorySize() )<br>返回值类型为 long，单位是毫秒。</p>\n</blockquote>\n<hr>\n<h3 id=\"获取压力-接触面积大小\"><a href=\"#获取压力-接触面积大小\" class=\"headerlink\" title=\"获取压力(接触面积大小)\"></a>获取压力(接触面积大小)</h3><p>MotionEvent支持获取某些输入设备(手指或触控笔)的与屏幕的接触面积和压力大小，主要有以下方法：</p>\n<blockquote>\n<p>描述中使用了手指，触控笔也是一样的。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>getSize ()</code></td>\n<td>获取第1个手指与屏幕接触面积的大小</td>\n</tr>\n<tr>\n<td><code>getSize (int pin)</code></td>\n<td>获取第pin个手指与屏幕接触面积的大小</td>\n</tr>\n<tr>\n<td><code>getHistoricalSize (int pos)</code></td>\n<td>获取历史数据中第1个手指在第pos次事件中的接触面积</td>\n</tr>\n<tr>\n<td><code>getHistoricalSize (int pin, int pos)</code></td>\n<td>获取历史数据中第pin个手指在第pos次事件中的接触面积</td>\n</tr>\n<tr>\n<td><code>getPressure ()</code></td>\n<td>获取第一个手指的压力大小</td>\n</tr>\n<tr>\n<td><code>getPressure (int pin)</code></td>\n<td>获取第pin个手指的压力大小</td>\n</tr>\n<tr>\n<td><code>getHistoricalPressure (int pos)</code></td>\n<td>获取历史数据中第1个手指在第pos次事件中的压力大小</td>\n</tr>\n<tr>\n<td><code>getHistoricalPressure (int pin, int pos)</code></td>\n<td>获取历史数据中第pin个手指在第pos次事件中的压力大小</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>pin 全称是 pointerIndex，表示第几个手指。<code>(pin &lt; getPointerCount() )</code><br>pos 表示历史数据中的第几个数据。<code>( pos &lt; getHistorySize() )</code></p>\n</blockquote>\n<p>注意：</p>\n<ol>\n<li>获取接触面积大小和获取压力大小是需要硬件支持的。</li>\n<li>非常不幸的是<font color=\"red\"><strong>大部分设备所使用的电容屏不支持压力检测</strong></font>，但能够大致检测出接触面积。</li>\n<li><font color=\"red\">大部分设备的 <code>getPressure()</code> 是使用接触面积来模拟的</font>。</li>\n<li>由于某些未知的原因(可能系统版本和硬件问题)，某些设备不支持 <code>getPressure()</code>。</li>\n<li>系统问题造成<font color=\"blue\"><strong>有的设备上只有<code>getSize()</code>能用，有的设备上只有 <code>getPressure()</code> 能用，而有的则两个都不能用</strong></font>。</li>\n</ol>\n<p>由于获取接触面积和获取压力大小受系统和硬件影响，使用的时候一定要进行数据检测，以防因为设备问题而导致程序出错。</p>\n<hr>\n<h3 id=\"鼠标事件\"><a href=\"#鼠标事件\" class=\"headerlink\" title=\"鼠标事件\"></a>鼠标事件</h3><p>由于触控笔事件和手指事件处理流程大致相同，与鼠标相关的几个事件：</p>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>ACTION_HOVER_ENTER</code></td>\n<td>指针移入到窗口或者View区域，但没有按下。</td>\n</tr>\n<tr>\n<td><code>ACTION_HOVER_MOVE</code></td>\n<td>指针在窗口或者View区域移动，但没有按下。</td>\n</tr>\n<tr>\n<td><code>ACTION_HOVER_EXIT</code></td>\n<td>指针移出到窗口或者View区域，但没有按下。</td>\n</tr>\n<tr>\n<td><code>ACTION_SCROLL</code></td>\n<td>滚轮滚动，可以触发水平滚动(<code>AXIS_HSCROLL</code>)或者垂直滚动(<code>AXIS_VSCROLL</code>)</td>\n</tr>\n</tbody>\n</table>\n<p>注意：</p>\n<ol>\n<li>这些事件类型是 安卓4.0 (API 14) 才添加的。</li>\n<li>使用 <code>getActionMasked()</code> 获得这些事件类型。</li>\n<li>这些事件不会传递到 <code>onTouchEvent(MotionEvent)</code> 而是传递到 <code>onGenericMotionEvent(MotionEvent)</code> 。</li>\n</ol>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"MotionEvent\"><a href=\"#MotionEvent\" class=\"headerlink\" title=\"MotionEvent\"></a>MotionEvent</h1><pre><code>1. 不常用事件;\n2. 多点触控事件;\n3. 历史数据(事件批处理);\n4. 获取事件发生的时间;\n5. 获取压力(接触面积大小);\n6. 鼠标事件;\n参考自: http://www.gcssloop.com/customview/motionevent\n</code></pre><hr>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>ACTION_DOWN</code></td>\n<td>手指 初次接触到屏幕 时触发。</td>\n</tr>\n<tr>\n<td><code>ACTION_MOVE</code></td>\n<td>手指 在屏幕上滑动 时触发，会多次触发。</td>\n</tr>\n<tr>\n<td><code>ACTION_UP</code></td>\n<td>手指 离开屏幕 时触发。</td>\n</tr>\n<tr>\n<td><code>ACTION_CANCEL</code></td>\n<td>事件 <strong>被上层拦截</strong> 时触发。</td>\n</tr>\n<tr>\n<td><code>ACTION_OUTSIDE</code></td>\n<td>手指 <strong>不在控件区域</strong> 时触发。</td>\n</tr>\n<tr>\n<td><code>ACTION_POINTER_DOWN</code></td>\n<td>有<strong>非主要</strong>的手指<strong>按下</strong>(即按下之前已经有手指在屏幕上)。</td>\n</tr>\n<tr>\n<td><code>ACTION_POINTER_UP</code></td>\n<td>有<strong>非主要</strong>的手指<strong>抬起</strong>(即抬起之后仍然有手指在屏幕上)。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"不常用事件之ACTION-CANCEL\"><a href=\"#不常用事件之ACTION-CANCEL\" class=\"headerlink\" title=\"不常用事件之ACTION_CANCEL\"></a>不常用事件之<code>ACTION_CANCEL</code></h3><p><strong>父容器在判断了事件之后对事件处理权的收回,<code>childView</code>收到<code>ACTION_CANCEL</code>不会收到后续事件。</strong></p>\n<blockquote>\n<p><code>RecyclerView</code>：儿砸，这里有一个 <code>ACTION_DOWN</code> 你看你要不要。<br><code>ItemView</code> ：好嘞，我看看。<br><code>RecyclerView</code>：噫？居然是移动事件 <code>ACTION_MOVE</code>，我要滚起来了，儿砸，我可能要把你送去你姑父家(缓存区)了，在这之前给你一个 <code>ACTION_CANCEL</code>，你要收好啊。<br><code>ItemView</code> ：……</p>\n</blockquote>\n<hr>\n<h3 id=\"不常用事件之ACTION-OUTSIDE\"><a href=\"#不常用事件之ACTION-OUTSIDE\" class=\"headerlink\" title=\"不常用事件之ACTION_OUTSIDE\"></a>不常用事件之<code>ACTION_OUTSIDE</code></h3><p>视图所在的<code>WindowManager</code>设置了<code>FLAG_WATCH_OUTSIDE_TOUCH</code>的<code>flag</code>后才能收到的动作。</p>\n<hr>\n<h3 id=\"多点触控\"><a href=\"#多点触控\" class=\"headerlink\" title=\"多点触控\"></a>多点触控</h3><p><strong>通过多点编号完成指针判断。第一次按下的手指特殊处理作为主指针，之后按下的手指作为辅助指针。</strong></p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>ev.getActionMasked()</code></td>\n<td>与 <code>getAction()</code> 类似，<strong>多点触控必须使用这个方法获取事件类型</strong>。</td>\n</tr>\n<tr>\n<td><del><code>ev.getActionIndex()</code></del></td>\n<td><del>获取该事件是哪个指针(手指)产生的。</del></td>\n</tr>\n<tr>\n<td><code>ev.getPointerCount()</code></td>\n<td>获取在屏幕上手指的个数。</td>\n</tr>\n<tr>\n<td><code>ev.getPointerId(int pointerIndex)</code></td>\n<td>获取一个指针(手指)的唯一标识符ID，在手指按下和抬起之间ID始终不变。</td>\n</tr>\n<tr>\n<td><code>ev.findPointerIndex(int pointerId)</code></td>\n<td>通过<code>PointerId</code>获取到当前状态下<code>PointIndex</code>，之后通过<code>PointIndex</code>获取其他内容。</td>\n</tr>\n<tr>\n<td><code>ev.getX(int pointerIndex )</code></td>\n<td>获取某一个指针(手指)的X坐标</td>\n</tr>\n<tr>\n<td><code>ev.getY(int pointerIndex )</code></td>\n<td>获取某一个指针(手指)的Y坐标</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>当多个手指在屏幕上按下的时候，会产生大量的事件，如何在获取事件类型的同时区分这些事件就是一个大问题了。一般来说我们可以通过为事件添加一个int类型的index属性来区分，但是谷歌工程师是有洁癖的，<font color=\"blue\"><strong>为了添加一个通常数值不会超过10的index属性就浪费一个int大小的空间简直是不能忍受的</strong></font>，于是工程师们将这个index属性和事件类型直接合并了。int类型共32位(0x00000000)，他们用最低8位(0x000000<strong>ff</strong>)表示事件类型，再往前的8位(0x0000<strong>ff</strong>00)表示事件编号。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>手指按下</th>\n<th>触发事件(数值)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>第1个手指按下</td>\n<td><code>ACTION_DOWN</code> (0x0000<strong>00</strong>00)</td>\n</tr>\n<tr>\n<td>—</td>\n<td><code>ACTION_POINTER_DOWN</code>(0x0000<strong>00</strong>05)</td>\n</tr>\n<tr>\n<td>第2个手指按下</td>\n<td><code>ACTION_POINTER_2_DOWN</code> (0x0000<strong>01</strong>05)</td>\n</tr>\n<tr>\n<td>第3个手指按下</td>\n<td><code>ACTION_POINTER_3_DOWN</code> (0x0000<strong>02</strong>05)</td>\n</tr>\n<tr>\n<td>第4个手指按下</td>\n<td><code>ACTION_POINTER_4_DOWN</code> (0x0000<strong>03</strong>05)</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>注意：<br>上面表格中用粗体标示出的数值，可以看到随着按下手指数量的增加，这个数值也是一直变化的，进而导致我们使用 <code>getAction()</code> 获取到的数值无法与标准的事件类型进行对比，为了解决这个问题，他们创建了一个 <code>getActionMasked()</code> 方法，这个方法可以清除index数值，让其变成一个标准的事件类型。<br><strong><font color=\"black\"> 1、多点触控时必须使用 <code>getActionMasked()</code> 来获取事件类型。<br>2、单点触控时由于事件数值不变，使用 <code>getAction()</code> 和 <code>getActionMasked()</code> 两个方法都可以。<br>3、使用 <code>getActionIndex()</code> 可以获取到这个index数值。不过请注意，<code>getActionIndex()</code> 只在 down 和 up 时有效，move 时是无效的。</font></strong></p>\n</blockquote>\n<blockquote>\n<p>目前来说获取事件类型使用 <code>getActionMasked()</code> 就行了，但是如果一定要编译时兼容古董版本的话，可以考虑使用这样的写法:</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> action = (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.FROYO)</span><br><span class=\"line\">                ? event.getActionMasked()</span><br><span class=\"line\">                : event.getAction();</span><br><span class=\"line\"><span class=\"keyword\">switch</span> (action)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> MotionEvent.ACTION_DOWN:</span><br><span class=\"line\">        <span class=\"comment\">// TODO</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"历史数据-事件批处理\"><a href=\"#历史数据-事件批处理\" class=\"headerlink\" title=\"历史数据(事件批处理)\"></a>历史数据(事件批处理)</h3><p>由于我们的设备非常灵敏，手指稍微移动一下就会产生一个移动事件，所以移动事件会产生的特别频繁，为了提高效率，<font color=\"red\"><strong>系统会将近期的多个移动事件(move)按照事件发生的顺序进行排序打包放在同一个 MotionEvent 中</strong></font>，与之对应的产生了以下方法：</p>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>ev.getHistorySize()</code></td>\n<td>获取历史事件集合大小</td>\n</tr>\n<tr>\n<td><code>ev.getHistoricalX(int pos)</code></td>\n<td>获取第pos个历史事件x坐标 <br><code>(pos &lt; getHistorySize())</code></td>\n</tr>\n<tr>\n<td><code>ev.getHistoricalY(int pos)</code></td>\n<td>获取第pos个历史事件y坐标 <br><code>(pos &lt; getHistorySize())</code></td>\n</tr>\n<tr>\n<td><code>ev.getHistoricalX (int pin, int pos)</code></td>\n<td>获取第pin个手指的第pos个历史事件x坐标 <br><code>(pin &lt; getPointerCount(), pos &lt; getHistorySize() )</code></td>\n</tr>\n<tr>\n<td><code>ev.getHistoricalY (int pin, int pos)</code></td>\n<td>获取第pin个手指的第pos个历史事件y坐标 <br><code>(pin &lt; getPointerCount(), pos &lt; getHistorySize() )</code></td>\n</tr>\n</tbody>\n</table>\n<p>注意：</p>\n<ul>\n<li>pin 全称是 <code>pointerIndex</code>，表示第几个手指，此处为了节省空间使用了缩写。</li>\n<li><font color=\"red\"> 历史数据只有 <code>ACTION_MOVE</code> 事件。</font></li>\n<li>历史数据单点触控和多点触控均可以用。</li>\n</ul>\n<p>下面是官方文档给出的一个简单使用示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printSamples</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> historySize = ev.getHistorySize();</span><br><span class=\"line\">     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> pointerCount = ev.getPointerCount();</span><br><span class=\"line\">     <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> h = <span class=\"number\">0</span>; h &lt; historySize; h++) &#123;</span><br><span class=\"line\">         System.out.printf(<span class=\"string\">\"At time %d:\"</span>, ev.getHistoricalEventTime(h));</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> p = <span class=\"number\">0</span>; p &lt; pointerCount; p++) &#123;</span><br><span class=\"line\">             System.out.printf(<span class=\"string\">\"  pointer %d: (%f,%f)\"</span>,</span><br><span class=\"line\">                 ev.getPointerId(p), ev.getHistoricalX(p, h), ev.getHistoricalY(p, h));</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     System.out.printf(<span class=\"string\">\"At time %d:\"</span>, ev.getEventTime());</span><br><span class=\"line\">     <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> p = <span class=\"number\">0</span>; p &lt; pointerCount; p++) &#123;</span><br><span class=\"line\">         System.out.printf(<span class=\"string\">\"  pointer %d: (%f,%f)\"</span>,</span><br><span class=\"line\">             ev.getPointerId(p), ev.getX(p), ev.getY(p));</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"获取事件发生的时间\"><a href=\"#获取事件发生的时间\" class=\"headerlink\" title=\"获取事件发生的时间\"></a>获取事件发生的时间</h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>getDownTime()</code></td>\n<td>获取手指按下时的时间。</td>\n</tr>\n<tr>\n<td><code>getEventTime()</code></td>\n<td>获取当前事件发生的时间。</td>\n</tr>\n<tr>\n<td><code>getHistoricalEventTime(int pos)</code></td>\n<td>获取历史事件发生的时间。</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>pos 表示历史数据中的第几个数据。( pos &lt; getHistorySize() )<br>返回值类型为 long，单位是毫秒。</p>\n</blockquote>\n<hr>\n<h3 id=\"获取压力-接触面积大小\"><a href=\"#获取压力-接触面积大小\" class=\"headerlink\" title=\"获取压力(接触面积大小)\"></a>获取压力(接触面积大小)</h3><p>MotionEvent支持获取某些输入设备(手指或触控笔)的与屏幕的接触面积和压力大小，主要有以下方法：</p>\n<blockquote>\n<p>描述中使用了手指，触控笔也是一样的。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>getSize ()</code></td>\n<td>获取第1个手指与屏幕接触面积的大小</td>\n</tr>\n<tr>\n<td><code>getSize (int pin)</code></td>\n<td>获取第pin个手指与屏幕接触面积的大小</td>\n</tr>\n<tr>\n<td><code>getHistoricalSize (int pos)</code></td>\n<td>获取历史数据中第1个手指在第pos次事件中的接触面积</td>\n</tr>\n<tr>\n<td><code>getHistoricalSize (int pin, int pos)</code></td>\n<td>获取历史数据中第pin个手指在第pos次事件中的接触面积</td>\n</tr>\n<tr>\n<td><code>getPressure ()</code></td>\n<td>获取第一个手指的压力大小</td>\n</tr>\n<tr>\n<td><code>getPressure (int pin)</code></td>\n<td>获取第pin个手指的压力大小</td>\n</tr>\n<tr>\n<td><code>getHistoricalPressure (int pos)</code></td>\n<td>获取历史数据中第1个手指在第pos次事件中的压力大小</td>\n</tr>\n<tr>\n<td><code>getHistoricalPressure (int pin, int pos)</code></td>\n<td>获取历史数据中第pin个手指在第pos次事件中的压力大小</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>pin 全称是 pointerIndex，表示第几个手指。<code>(pin &lt; getPointerCount() )</code><br>pos 表示历史数据中的第几个数据。<code>( pos &lt; getHistorySize() )</code></p>\n</blockquote>\n<p>注意：</p>\n<ol>\n<li>获取接触面积大小和获取压力大小是需要硬件支持的。</li>\n<li>非常不幸的是<font color=\"red\"><strong>大部分设备所使用的电容屏不支持压力检测</strong></font>，但能够大致检测出接触面积。</li>\n<li><font color=\"red\">大部分设备的 <code>getPressure()</code> 是使用接触面积来模拟的</font>。</li>\n<li>由于某些未知的原因(可能系统版本和硬件问题)，某些设备不支持 <code>getPressure()</code>。</li>\n<li>系统问题造成<font color=\"blue\"><strong>有的设备上只有<code>getSize()</code>能用，有的设备上只有 <code>getPressure()</code> 能用，而有的则两个都不能用</strong></font>。</li>\n</ol>\n<p>由于获取接触面积和获取压力大小受系统和硬件影响，使用的时候一定要进行数据检测，以防因为设备问题而导致程序出错。</p>\n<hr>\n<h3 id=\"鼠标事件\"><a href=\"#鼠标事件\" class=\"headerlink\" title=\"鼠标事件\"></a>鼠标事件</h3><p>由于触控笔事件和手指事件处理流程大致相同，与鼠标相关的几个事件：</p>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>ACTION_HOVER_ENTER</code></td>\n<td>指针移入到窗口或者View区域，但没有按下。</td>\n</tr>\n<tr>\n<td><code>ACTION_HOVER_MOVE</code></td>\n<td>指针在窗口或者View区域移动，但没有按下。</td>\n</tr>\n<tr>\n<td><code>ACTION_HOVER_EXIT</code></td>\n<td>指针移出到窗口或者View区域，但没有按下。</td>\n</tr>\n<tr>\n<td><code>ACTION_SCROLL</code></td>\n<td>滚轮滚动，可以触发水平滚动(<code>AXIS_HSCROLL</code>)或者垂直滚动(<code>AXIS_VSCROLL</code>)</td>\n</tr>\n</tbody>\n</table>\n<p>注意：</p>\n<ol>\n<li>这些事件类型是 安卓4.0 (API 14) 才添加的。</li>\n<li>使用 <code>getActionMasked()</code> 获得这些事件类型。</li>\n<li>这些事件不会传递到 <code>onTouchEvent(MotionEvent)</code> 而是传递到 <code>onGenericMotionEvent(MotionEvent)</code> 。</li>\n</ol>\n<hr>\n"},{"title":"Android 事件分发机制表现与实现原理","_content":"# 事件分发机制表现与实现原理 #\n\n\thttp://blog.csdn.net/qq_23547831/article/details/51530671\n\t表现图片来源: http://blog.csdn.net/chunqiuwei/article/details/41084921\n\n- 事件拦截表现\n![事件拦截1](http://img.blog.csdn.net/20141113191428406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2h1bnFpdXdlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\t- 不拦截不处理时\n\t![事件拦截2](http://img.blog.csdn.net/20141113192118648?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2h1bnFpdXdlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\t- C拦截但不处理时\n\t![事件拦截3](http://img.blog.csdn.net/20141113193108593?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2h1bnFpdXdlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\t- D处理时\n\t![事件拦截4](http://img.blog.csdn.net/20141113193349703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2h1bnFpdXdlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n- 事件拦截原理\n![Android 事件分发机制](https://i.imgur.com/S49ezlo.png)\n\n### `ViewGroup # dispatchTouchEvent()` ###\n\n```\n\t\t\t// Handle an initial down.\n            if (actionMasked == MotionEvent.ACTION_DOWN) {\n                // Throw away all previous state when starting a new touch gesture.\n                // The framework may have dropped the up or cancel event for the previous gesture\n                // due to an app switch, ANR, or some other state change.\n                cancelAndClearTouchTargets(ev);//清除之前的所有其他动作,使mFirstTouchTarget=null\n                resetTouchState();//重置Touch状态标识。\n            }\n\n\t\t\t// Check for interception.\n            final boolean intercepted;\n            if (actionMasked == MotionEvent.ACTION_DOWN\n                    || mFirstTouchTarget != null) {\n                final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;\n                if (!disallowIntercept) {\n                    intercepted = onInterceptTouchEvent(ev);//默认不拦截\n                    ev.setAction(action); // restore action in case it was changed\n                } else {\n                    intercepted = false;\n                }\n            } else {\n                // There are no touch targets and this action is not an initial down\n                // so this view group continues to intercept touches.\n                intercepted = true;\n            }\n\n```\n1. 每个`MotionEvent.ACTION_DOWN`发生时会清除之前所有连续的动作并作为一系列动作的开端；\n2. 当`MotionEvent.ACTION_DOWN`或存在动作接收对象时,默认不拦截动作；否则拦截动作；\n\n----\n### `View # dispatchTouchEvent(event)`  ###\n`ViewGroup # dispatchTouchEvent(event)` **倒序循环判断当前从上方到下方的`直接子View/ViewGroup`**, 判断当前事件是否存在消费对象,**递归判断**,最终调用的是已经定义过的`child # dispatchTouchEvent()`或者是`View # dispatchTouchEvent(event)`\n\n- `View # dispatchTouchEvent(event)` 返回`true`的情况\n\t- 处理内部滚动事件\n\t- `View # isEnabled()==true`,添加`View $ OnTouchListener`并在`OnTouchListener # onTouch()`返回true;\n\t- `View # onTouchEvent()`返回true;\n\n如果控件（View）是enable且onTouch返回true情况下，dispatchTouchEvent直接返回true，不会调用onTouchEvent方法。\n\n完整代码如下:\n\n```java\n\t/**\n     * View # dispatchTouchEvent(event)\n     * \n     * Pass the touch screen motion event down to the target view, or this\n     * view if it is the target.\n     *\n     * @param event The motion event to be dispatched.\n     * @return True if the event was handled by the view, false otherwise.\n     */\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        // If the event should be handled by accessibility focus first.\n        if (event.isTargetAccessibilityFocus()) {\n            // We don't have focus or no virtual descendant has it, do not handle the event.\n            if (!isAccessibilityFocusedViewOrHost()) {\n                return false;\n            }\n            // We have focus and got the event, then use normal event dispatch.\n            event.setTargetAccessibilityFocus(false);\n        }\n\n        boolean result = false;\n\n        if (mInputEventConsistencyVerifier != null) {\n            mInputEventConsistencyVerifier.onTouchEvent(event, 0);\n        }\n\n        final int actionMasked = event.getActionMasked();\n        if (actionMasked == MotionEvent.ACTION_DOWN) {\n            // Defensive cleanup for new gesture\n            stopNestedScroll();\n        }\n\n        if (onFilterTouchEventForSecurity(event)) {\n            if ((mViewFlags & ENABLED_MASK) == ENABLED && handleScrollBarDragging(event)) {\n                result = true;\n            }\n            //noinspection SimplifiableIfStatement\n            ListenerInfo li = mListenerInfo;\n            if (li != null && li.mOnTouchListener != null\n                    && (mViewFlags & ENABLED_MASK) == ENABLED\n                    && li.mOnTouchListener.onTouch(this, event)) {\n                result = true;\n            }\n\n            if (!result && onTouchEvent(event)) {\n                result = true;\n            }\n        }\n\n        if (!result && mInputEventConsistencyVerifier != null) {\n            mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);\n        }\n\n        // Clean up after nested scrolls if this is the end of a gesture;\n        // also cancel it if we tried an ACTION_DOWN but we didn't want the rest\n        // of the gesture.\n        if (actionMasked == MotionEvent.ACTION_UP ||\n                actionMasked == MotionEvent.ACTION_CANCEL ||\n                (actionMasked == MotionEvent.ACTION_DOWN && !result)) {\n            stopNestedScroll();\n        }\n\n        return result;\n    }\n\n\n```\n----\n### `View # onTouchEvent(event) ` ###\n\n- 点击和长按事件都会消耗当前事件返回true\n\n\n全部代码如下:\n```java\n    /**\n     * Implement this method to handle touch screen motion events.\n     * <p>\n     * If this method is used to detect click actions, it is recommended that\n     * the actions be performed by implementing and calling\n     * {@link #performClick()}. This will ensure consistent system behavior,\n     * including:\n     * <ul>\n     * <li>obeying click sound preferences\n     * <li>dispatching OnClickListener calls\n     * <li>handling {@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK} when\n     * accessibility features are enabled\n     * </ul>\n     *\n     * @param event The motion event.\n     * @return True if the event was handled, false otherwise.\n     */\n    public boolean onTouchEvent(MotionEvent event) {\n        final float x = event.getX();\n        final float y = event.getY();\n        final int viewFlags = mViewFlags;\n        final int action = event.getAction();\n\n    >>>    final boolean clickable = ((viewFlags & CLICKABLE) == CLICKABLE\n                || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)\n                || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;\n\n        if ((viewFlags & ENABLED_MASK) == DISABLED) {\n            if (action == MotionEvent.ACTION_UP && (mPrivateFlags & PFLAG_PRESSED) != 0) {\n                setPressed(false);\n            }\n            mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;\n            // A disabled view that is clickable still consumes the touch\n            // events, it just doesn't respond to them.\n    >>>     return clickable;\n        }\n        if (mTouchDelegate != null) {\n            if (mTouchDelegate.onTouchEvent(event)) {\n                return true;\n            }\n        }\n\n        if (clickable || (viewFlags & TOOLTIP) == TOOLTIP) {\n            switch (action) {\n                case MotionEvent.ACTION_UP:\n                    mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;\n                    if ((viewFlags & TOOLTIP) == TOOLTIP) {\n                        handleTooltipUp();\n                    }\n                    if (!clickable) {\n                        removeTapCallback();\n                        removeLongPressCallback();\n                        mInContextButtonPress = false;\n                        mHasPerformedLongPress = false;\n                        mIgnoreNextUpEvent = false;\n                        break;\n                    }\n                    boolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0;\n                    if ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) {\n                        // take focus if we don't have it already and we should in\n                        // touch mode.\n                        boolean focusTaken = false;\n                        if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {\n                            focusTaken = requestFocus();\n                        }\n\n                        if (prepressed) {\n                            // The button is being released before we actually\n                            // showed it as pressed.  Make it show the pressed\n                            // state now (before scheduling the click) to ensure\n                            // the user sees it.\n                            setPressed(true, x, y);\n                        }\n\n                        if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {\n                            // This is a tap, so remove the longpress check\n                            removeLongPressCallback();\n\n                            // Only perform take click actions if we were in the pressed state\n                            if (!focusTaken) {\n                                // Use a Runnable and post this rather than calling\n                                // performClick directly. This lets other visual state\n                                // of the view update before click actions start.\n                                if (mPerformClick == null) {\n                                    mPerformClick = new PerformClick();\n                                }\n                                if (!post(mPerformClick)) {\n                                    performClick();\n                                }\n                            }\n                        }\n\n                        if (mUnsetPressedState == null) {\n                            mUnsetPressedState = new UnsetPressedState();\n                        }\n\n                        if (prepressed) {\n                            postDelayed(mUnsetPressedState,\n                                    ViewConfiguration.getPressedStateDuration());\n                        } else if (!post(mUnsetPressedState)) {\n                            // If the post failed, unpress right now\n                            mUnsetPressedState.run();\n                        }\n\n                        removeTapCallback();\n                    }\n                    mIgnoreNextUpEvent = false;\n                    break;\n\n                case MotionEvent.ACTION_DOWN:\n                    if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) {\n                        mPrivateFlags3 |= PFLAG3_FINGER_DOWN;\n                    }\n                    mHasPerformedLongPress = false;\n\n                    if (!clickable) {\n                        checkForLongClick(0, x, y);\n                        break;\n                    }\n\n                    if (performButtonActionOnTouchDown(event)) {\n                        break;\n                    }\n\n                    // Walk up the hierarchy to determine if we're inside a scrolling container.\n                    boolean isInScrollingContainer = isInScrollingContainer();\n\n                    // For views inside a scrolling container, delay the pressed feedback for\n                    // a short period in case this is a scroll.\n                    if (isInScrollingContainer) {\n                        mPrivateFlags |= PFLAG_PREPRESSED;\n                        if (mPendingCheckForTap == null) {\n                            mPendingCheckForTap = new CheckForTap();\n                        }\n                        mPendingCheckForTap.x = event.getX();\n                        mPendingCheckForTap.y = event.getY();\n                        postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());\n                    } else {\n                        // Not inside a scrolling container, so show the feedback right away\n                        setPressed(true, x, y);\n                        checkForLongClick(0, x, y);\n                    }\n                    break;\n\n                case MotionEvent.ACTION_CANCEL:\n                    if (clickable) {\n                        setPressed(false);\n                    }\n                    removeTapCallback();\n                    removeLongPressCallback();\n                    mInContextButtonPress = false;\n                    mHasPerformedLongPress = false;\n                    mIgnoreNextUpEvent = false;\n                    mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;\n                    break;\n\n                case MotionEvent.ACTION_MOVE:\n                    if (clickable) {\n                        drawableHotspotChanged(x, y);\n                    }\n\n                    // Be lenient about moving outside of buttons\n                    if (!pointInView(x, y, mTouchSlop)) {\n                        // Outside button\n                        // Remove any future long press/tap checks\n                        removeTapCallback();\n                        removeLongPressCallback();\n                        if ((mPrivateFlags & PFLAG_PRESSED) != 0) {\n                            setPressed(false);\n                        }\n                        mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;\n                    }\n                    break;\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n\n\n```\n----\n","source":"_posts/Android之自定义控件——事件分发,拦截,处理.md","raw":"---\n\ntitle: Android 事件分发机制表现与实现原理\ncategories: \"android 总结\"\ntags: \n     - android\n     - 分发\n     - 原理\n \n---\n# 事件分发机制表现与实现原理 #\n\n\thttp://blog.csdn.net/qq_23547831/article/details/51530671\n\t表现图片来源: http://blog.csdn.net/chunqiuwei/article/details/41084921\n\n- 事件拦截表现\n![事件拦截1](http://img.blog.csdn.net/20141113191428406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2h1bnFpdXdlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\t- 不拦截不处理时\n\t![事件拦截2](http://img.blog.csdn.net/20141113192118648?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2h1bnFpdXdlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\t- C拦截但不处理时\n\t![事件拦截3](http://img.blog.csdn.net/20141113193108593?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2h1bnFpdXdlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\t- D处理时\n\t![事件拦截4](http://img.blog.csdn.net/20141113193349703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2h1bnFpdXdlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n- 事件拦截原理\n![Android 事件分发机制](https://i.imgur.com/S49ezlo.png)\n\n### `ViewGroup # dispatchTouchEvent()` ###\n\n```\n\t\t\t// Handle an initial down.\n            if (actionMasked == MotionEvent.ACTION_DOWN) {\n                // Throw away all previous state when starting a new touch gesture.\n                // The framework may have dropped the up or cancel event for the previous gesture\n                // due to an app switch, ANR, or some other state change.\n                cancelAndClearTouchTargets(ev);//清除之前的所有其他动作,使mFirstTouchTarget=null\n                resetTouchState();//重置Touch状态标识。\n            }\n\n\t\t\t// Check for interception.\n            final boolean intercepted;\n            if (actionMasked == MotionEvent.ACTION_DOWN\n                    || mFirstTouchTarget != null) {\n                final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;\n                if (!disallowIntercept) {\n                    intercepted = onInterceptTouchEvent(ev);//默认不拦截\n                    ev.setAction(action); // restore action in case it was changed\n                } else {\n                    intercepted = false;\n                }\n            } else {\n                // There are no touch targets and this action is not an initial down\n                // so this view group continues to intercept touches.\n                intercepted = true;\n            }\n\n```\n1. 每个`MotionEvent.ACTION_DOWN`发生时会清除之前所有连续的动作并作为一系列动作的开端；\n2. 当`MotionEvent.ACTION_DOWN`或存在动作接收对象时,默认不拦截动作；否则拦截动作；\n\n----\n### `View # dispatchTouchEvent(event)`  ###\n`ViewGroup # dispatchTouchEvent(event)` **倒序循环判断当前从上方到下方的`直接子View/ViewGroup`**, 判断当前事件是否存在消费对象,**递归判断**,最终调用的是已经定义过的`child # dispatchTouchEvent()`或者是`View # dispatchTouchEvent(event)`\n\n- `View # dispatchTouchEvent(event)` 返回`true`的情况\n\t- 处理内部滚动事件\n\t- `View # isEnabled()==true`,添加`View $ OnTouchListener`并在`OnTouchListener # onTouch()`返回true;\n\t- `View # onTouchEvent()`返回true;\n\n如果控件（View）是enable且onTouch返回true情况下，dispatchTouchEvent直接返回true，不会调用onTouchEvent方法。\n\n完整代码如下:\n\n```java\n\t/**\n     * View # dispatchTouchEvent(event)\n     * \n     * Pass the touch screen motion event down to the target view, or this\n     * view if it is the target.\n     *\n     * @param event The motion event to be dispatched.\n     * @return True if the event was handled by the view, false otherwise.\n     */\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        // If the event should be handled by accessibility focus first.\n        if (event.isTargetAccessibilityFocus()) {\n            // We don't have focus or no virtual descendant has it, do not handle the event.\n            if (!isAccessibilityFocusedViewOrHost()) {\n                return false;\n            }\n            // We have focus and got the event, then use normal event dispatch.\n            event.setTargetAccessibilityFocus(false);\n        }\n\n        boolean result = false;\n\n        if (mInputEventConsistencyVerifier != null) {\n            mInputEventConsistencyVerifier.onTouchEvent(event, 0);\n        }\n\n        final int actionMasked = event.getActionMasked();\n        if (actionMasked == MotionEvent.ACTION_DOWN) {\n            // Defensive cleanup for new gesture\n            stopNestedScroll();\n        }\n\n        if (onFilterTouchEventForSecurity(event)) {\n            if ((mViewFlags & ENABLED_MASK) == ENABLED && handleScrollBarDragging(event)) {\n                result = true;\n            }\n            //noinspection SimplifiableIfStatement\n            ListenerInfo li = mListenerInfo;\n            if (li != null && li.mOnTouchListener != null\n                    && (mViewFlags & ENABLED_MASK) == ENABLED\n                    && li.mOnTouchListener.onTouch(this, event)) {\n                result = true;\n            }\n\n            if (!result && onTouchEvent(event)) {\n                result = true;\n            }\n        }\n\n        if (!result && mInputEventConsistencyVerifier != null) {\n            mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);\n        }\n\n        // Clean up after nested scrolls if this is the end of a gesture;\n        // also cancel it if we tried an ACTION_DOWN but we didn't want the rest\n        // of the gesture.\n        if (actionMasked == MotionEvent.ACTION_UP ||\n                actionMasked == MotionEvent.ACTION_CANCEL ||\n                (actionMasked == MotionEvent.ACTION_DOWN && !result)) {\n            stopNestedScroll();\n        }\n\n        return result;\n    }\n\n\n```\n----\n### `View # onTouchEvent(event) ` ###\n\n- 点击和长按事件都会消耗当前事件返回true\n\n\n全部代码如下:\n```java\n    /**\n     * Implement this method to handle touch screen motion events.\n     * <p>\n     * If this method is used to detect click actions, it is recommended that\n     * the actions be performed by implementing and calling\n     * {@link #performClick()}. This will ensure consistent system behavior,\n     * including:\n     * <ul>\n     * <li>obeying click sound preferences\n     * <li>dispatching OnClickListener calls\n     * <li>handling {@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK} when\n     * accessibility features are enabled\n     * </ul>\n     *\n     * @param event The motion event.\n     * @return True if the event was handled, false otherwise.\n     */\n    public boolean onTouchEvent(MotionEvent event) {\n        final float x = event.getX();\n        final float y = event.getY();\n        final int viewFlags = mViewFlags;\n        final int action = event.getAction();\n\n    >>>    final boolean clickable = ((viewFlags & CLICKABLE) == CLICKABLE\n                || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)\n                || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;\n\n        if ((viewFlags & ENABLED_MASK) == DISABLED) {\n            if (action == MotionEvent.ACTION_UP && (mPrivateFlags & PFLAG_PRESSED) != 0) {\n                setPressed(false);\n            }\n            mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;\n            // A disabled view that is clickable still consumes the touch\n            // events, it just doesn't respond to them.\n    >>>     return clickable;\n        }\n        if (mTouchDelegate != null) {\n            if (mTouchDelegate.onTouchEvent(event)) {\n                return true;\n            }\n        }\n\n        if (clickable || (viewFlags & TOOLTIP) == TOOLTIP) {\n            switch (action) {\n                case MotionEvent.ACTION_UP:\n                    mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;\n                    if ((viewFlags & TOOLTIP) == TOOLTIP) {\n                        handleTooltipUp();\n                    }\n                    if (!clickable) {\n                        removeTapCallback();\n                        removeLongPressCallback();\n                        mInContextButtonPress = false;\n                        mHasPerformedLongPress = false;\n                        mIgnoreNextUpEvent = false;\n                        break;\n                    }\n                    boolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0;\n                    if ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) {\n                        // take focus if we don't have it already and we should in\n                        // touch mode.\n                        boolean focusTaken = false;\n                        if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {\n                            focusTaken = requestFocus();\n                        }\n\n                        if (prepressed) {\n                            // The button is being released before we actually\n                            // showed it as pressed.  Make it show the pressed\n                            // state now (before scheduling the click) to ensure\n                            // the user sees it.\n                            setPressed(true, x, y);\n                        }\n\n                        if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {\n                            // This is a tap, so remove the longpress check\n                            removeLongPressCallback();\n\n                            // Only perform take click actions if we were in the pressed state\n                            if (!focusTaken) {\n                                // Use a Runnable and post this rather than calling\n                                // performClick directly. This lets other visual state\n                                // of the view update before click actions start.\n                                if (mPerformClick == null) {\n                                    mPerformClick = new PerformClick();\n                                }\n                                if (!post(mPerformClick)) {\n                                    performClick();\n                                }\n                            }\n                        }\n\n                        if (mUnsetPressedState == null) {\n                            mUnsetPressedState = new UnsetPressedState();\n                        }\n\n                        if (prepressed) {\n                            postDelayed(mUnsetPressedState,\n                                    ViewConfiguration.getPressedStateDuration());\n                        } else if (!post(mUnsetPressedState)) {\n                            // If the post failed, unpress right now\n                            mUnsetPressedState.run();\n                        }\n\n                        removeTapCallback();\n                    }\n                    mIgnoreNextUpEvent = false;\n                    break;\n\n                case MotionEvent.ACTION_DOWN:\n                    if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) {\n                        mPrivateFlags3 |= PFLAG3_FINGER_DOWN;\n                    }\n                    mHasPerformedLongPress = false;\n\n                    if (!clickable) {\n                        checkForLongClick(0, x, y);\n                        break;\n                    }\n\n                    if (performButtonActionOnTouchDown(event)) {\n                        break;\n                    }\n\n                    // Walk up the hierarchy to determine if we're inside a scrolling container.\n                    boolean isInScrollingContainer = isInScrollingContainer();\n\n                    // For views inside a scrolling container, delay the pressed feedback for\n                    // a short period in case this is a scroll.\n                    if (isInScrollingContainer) {\n                        mPrivateFlags |= PFLAG_PREPRESSED;\n                        if (mPendingCheckForTap == null) {\n                            mPendingCheckForTap = new CheckForTap();\n                        }\n                        mPendingCheckForTap.x = event.getX();\n                        mPendingCheckForTap.y = event.getY();\n                        postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());\n                    } else {\n                        // Not inside a scrolling container, so show the feedback right away\n                        setPressed(true, x, y);\n                        checkForLongClick(0, x, y);\n                    }\n                    break;\n\n                case MotionEvent.ACTION_CANCEL:\n                    if (clickable) {\n                        setPressed(false);\n                    }\n                    removeTapCallback();\n                    removeLongPressCallback();\n                    mInContextButtonPress = false;\n                    mHasPerformedLongPress = false;\n                    mIgnoreNextUpEvent = false;\n                    mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;\n                    break;\n\n                case MotionEvent.ACTION_MOVE:\n                    if (clickable) {\n                        drawableHotspotChanged(x, y);\n                    }\n\n                    // Be lenient about moving outside of buttons\n                    if (!pointInView(x, y, mTouchSlop)) {\n                        // Outside button\n                        // Remove any future long press/tap checks\n                        removeTapCallback();\n                        removeLongPressCallback();\n                        if ((mPrivateFlags & PFLAG_PRESSED) != 0) {\n                            setPressed(false);\n                        }\n                        mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;\n                    }\n                    break;\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n\n\n```\n----\n","slug":"Android之自定义控件——事件分发,拦截,处理","published":1,"date":"2018-03-21T05:35:40.027Z","updated":"2018-03-21T05:24:46.984Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0otqpe0002so4lq1ca8irz","content":"<h1 id=\"事件分发机制表现与实现原理\"><a href=\"#事件分发机制表现与实现原理\" class=\"headerlink\" title=\"事件分发机制表现与实现原理\"></a>事件分发机制表现与实现原理</h1><pre><code>http://blog.csdn.net/qq_23547831/article/details/51530671\n表现图片来源: http://blog.csdn.net/chunqiuwei/article/details/41084921\n</code></pre><ul>\n<li><p>事件拦截表现<br><img src=\"http://img.blog.csdn.net/20141113191428406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2h1bnFpdXdlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"事件拦截1\"></p>\n<ul>\n<li>不拦截不处理时<br><img src=\"http://img.blog.csdn.net/20141113192118648?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2h1bnFpdXdlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"事件拦截2\"></li>\n<li>C拦截但不处理时<br><img src=\"http://img.blog.csdn.net/20141113193108593?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2h1bnFpdXdlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"事件拦截3\"></li>\n<li>D处理时<br><img src=\"http://img.blog.csdn.net/20141113193349703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2h1bnFpdXdlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"事件拦截4\"></li>\n</ul>\n</li>\n<li><p>事件拦截原理<br><img src=\"https://i.imgur.com/S49ezlo.png\" alt=\"Android 事件分发机制\"></p>\n</li>\n</ul>\n<h3 id=\"ViewGroup-dispatchTouchEvent\"><a href=\"#ViewGroup-dispatchTouchEvent\" class=\"headerlink\" title=\"ViewGroup # dispatchTouchEvent()\"></a><code>ViewGroup # dispatchTouchEvent()</code></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Handle an initial down.</span><br><span class=\"line\">         if (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class=\"line\">             // Throw away all previous state when starting a new touch gesture.</span><br><span class=\"line\">             // The framework may have dropped the up or cancel event for the previous gesture</span><br><span class=\"line\">             // due to an app switch, ANR, or some other state change.</span><br><span class=\"line\">             cancelAndClearTouchTargets(ev);//清除之前的所有其他动作,使mFirstTouchTarget=null</span><br><span class=\"line\">             resetTouchState();//重置Touch状态标识。</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Check for interception.</span><br><span class=\"line\">         final boolean intercepted;</span><br><span class=\"line\">         if (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class=\"line\">                 || mFirstTouchTarget != null) &#123;</span><br><span class=\"line\">             final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</span><br><span class=\"line\">             if (!disallowIntercept) &#123;</span><br><span class=\"line\">                 intercepted = onInterceptTouchEvent(ev);//默认不拦截</span><br><span class=\"line\">                 ev.setAction(action); // restore action in case it was changed</span><br><span class=\"line\">             &#125; else &#123;</span><br><span class=\"line\">                 intercepted = false;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125; else &#123;</span><br><span class=\"line\">             // There are no touch targets and this action is not an initial down</span><br><span class=\"line\">             // so this view group continues to intercept touches.</span><br><span class=\"line\">             intercepted = true;</span><br><span class=\"line\">         &#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>每个<code>MotionEvent.ACTION_DOWN</code>发生时会清除之前所有连续的动作并作为一系列动作的开端；</li>\n<li>当<code>MotionEvent.ACTION_DOWN</code>或存在动作接收对象时,默认不拦截动作；否则拦截动作；</li>\n</ol>\n<hr>\n<h3 id=\"View-dispatchTouchEvent-event\"><a href=\"#View-dispatchTouchEvent-event\" class=\"headerlink\" title=\"View # dispatchTouchEvent(event)\"></a><code>View # dispatchTouchEvent(event)</code></h3><p><code>ViewGroup # dispatchTouchEvent(event)</code> <strong>倒序循环判断当前从上方到下方的<code>直接子View/ViewGroup</code></strong>, 判断当前事件是否存在消费对象,<strong>递归判断</strong>,最终调用的是已经定义过的<code>child # dispatchTouchEvent()</code>或者是<code>View # dispatchTouchEvent(event)</code></p>\n<ul>\n<li><code>View # dispatchTouchEvent(event)</code> 返回<code>true</code>的情况<ul>\n<li>处理内部滚动事件</li>\n<li><code>View # isEnabled()==true</code>,添加<code>View $ OnTouchListener</code>并在<code>OnTouchListener # onTouch()</code>返回true;</li>\n<li><code>View # onTouchEvent()</code>返回true;</li>\n</ul>\n</li>\n</ul>\n<p>如果控件（View）是enable且onTouch返回true情况下，dispatchTouchEvent直接返回true，不会调用onTouchEvent方法。</p>\n<p>完整代码如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * View # dispatchTouchEvent(event)</span></span><br><span class=\"line\"><span class=\"comment\">    * </span></span><br><span class=\"line\"><span class=\"comment\">    * Pass the touch screen motion event down to the target view, or this</span></span><br><span class=\"line\"><span class=\"comment\">    * view if it is the target.</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> event The motion event to be dispatched.</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span> True if the event was handled by the view, false otherwise.</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">// If the event should be handled by accessibility focus first.</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (event.isTargetAccessibilityFocus()) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// We don't have focus or no virtual descendant has it, do not handle the event.</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (!isAccessibilityFocusedViewOrHost()) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"comment\">// We have focus and got the event, then use normal event dispatch.</span></span><br><span class=\"line\">           event.setTargetAccessibilityFocus(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">boolean</span> result = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (mInputEventConsistencyVerifier != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           mInputEventConsistencyVerifier.onTouchEvent(event, <span class=\"number\">0</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> actionMasked = event.getActionMasked();</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// Defensive cleanup for new gesture</span></span><br><span class=\"line\">           stopNestedScroll();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class=\"line\">               result = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"comment\">//noinspection SimplifiableIfStatement</span></span><br><span class=\"line\">           ListenerInfo li = mListenerInfo;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (li != <span class=\"keyword\">null</span> &amp;&amp; li.mOnTouchListener != <span class=\"keyword\">null</span></span><br><span class=\"line\">                   &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class=\"line\">                   &amp;&amp; li.mOnTouchListener.onTouch(<span class=\"keyword\">this</span>, event)) &#123;</span><br><span class=\"line\">               result = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class=\"line\">               result = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (!result &amp;&amp; mInputEventConsistencyVerifier != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           mInputEventConsistencyVerifier.onUnhandledEvent(event, <span class=\"number\">0</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// Clean up after nested scrolls if this is the end of a gesture;</span></span><br><span class=\"line\">       <span class=\"comment\">// also cancel it if we tried an ACTION_DOWN but we didn't want the rest</span></span><br><span class=\"line\">       <span class=\"comment\">// of the gesture.</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (actionMasked == MotionEvent.ACTION_UP ||</span><br><span class=\"line\">               actionMasked == MotionEvent.ACTION_CANCEL ||</span><br><span class=\"line\">               (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123;</span><br><span class=\"line\">           stopNestedScroll();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"View-onTouchEvent-event\"><a href=\"#View-onTouchEvent-event\" class=\"headerlink\" title=\"View # onTouchEvent(event)\"></a><code>View # onTouchEvent(event)</code></h3><ul>\n<li>点击和长按事件都会消耗当前事件返回true</li>\n</ul>\n<p>全部代码如下:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Implement this method to handle touch screen motion events.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * If this method is used to detect click actions, it is recommended that</span></span><br><span class=\"line\"><span class=\"comment\"> * the actions be performed by implementing and calling</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> #performClick()&#125;. This will ensure consistent system behavior,</span></span><br><span class=\"line\"><span class=\"comment\"> * including:</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;ul&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;li&gt;obeying click sound preferences</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;li&gt;dispatching OnClickListener calls</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;li&gt;handling &#123;<span class=\"doctag\">@link</span> AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK&#125; when</span></span><br><span class=\"line\"><span class=\"comment\"> * accessibility features are enabled</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> event The motion event.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> True if the event was handled, false otherwise.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> x = event.getX();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> y = event.getY();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> viewFlags = mViewFlags;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> action = event.getAction();</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt;    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class=\"line\">            || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class=\"line\">            || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            setPressed(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class=\"line\">        <span class=\"comment\">// A disabled view that is clickable still consumes the touch</span></span><br><span class=\"line\">        <span class=\"comment\">// events, it just doesn't respond to them.</span></span><br><span class=\"line\">&gt;&gt;&gt;     <span class=\"keyword\">return</span> clickable;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mTouchDelegate != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (action) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_UP:</span><br><span class=\"line\">                mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class=\"line\">                    handleTooltipUp();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!clickable) &#123;</span><br><span class=\"line\">                    removeTapCallback();</span><br><span class=\"line\">                    removeLongPressCallback();</span><br><span class=\"line\">                    mInContextButtonPress = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    mHasPerformedLongPress = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    mIgnoreNextUpEvent = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class=\"number\">0</span> || prepressed) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// take focus if we don't have it already and we should in</span></span><br><span class=\"line\">                    <span class=\"comment\">// touch mode.</span></span><br><span class=\"line\">                    <span class=\"keyword\">boolean</span> focusTaken = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</span><br><span class=\"line\">                        focusTaken = requestFocus();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prepressed) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// The button is being released before we actually</span></span><br><span class=\"line\">                        <span class=\"comment\">// showed it as pressed.  Make it show the pressed</span></span><br><span class=\"line\">                        <span class=\"comment\">// state now (before scheduling the click) to ensure</span></span><br><span class=\"line\">                        <span class=\"comment\">// the user sees it.</span></span><br><span class=\"line\">                        setPressed(<span class=\"keyword\">true</span>, x, y);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// This is a tap, so remove the longpress check</span></span><br><span class=\"line\">                        removeLongPressCallback();</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"comment\">// Only perform take click actions if we were in the pressed state</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (!focusTaken) &#123;</span><br><span class=\"line\">                            <span class=\"comment\">// Use a Runnable and post this rather than calling</span></span><br><span class=\"line\">                            <span class=\"comment\">// performClick directly. This lets other visual state</span></span><br><span class=\"line\">                            <span class=\"comment\">// of the view update before click actions start.</span></span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (mPerformClick == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                mPerformClick = <span class=\"keyword\">new</span> PerformClick();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (!post(mPerformClick)) &#123;</span><br><span class=\"line\">                                performClick();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (mUnsetPressedState == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        mUnsetPressedState = <span class=\"keyword\">new</span> UnsetPressedState();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prepressed) &#123;</span><br><span class=\"line\">                        postDelayed(mUnsetPressedState,</span><br><span class=\"line\">                                ViewConfiguration.getPressedStateDuration());</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!post(mUnsetPressedState)) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// If the post failed, unpress right now</span></span><br><span class=\"line\">                        mUnsetPressedState.run();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    removeTapCallback();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                mIgnoreNextUpEvent = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_DOWN:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) &#123;</span><br><span class=\"line\">                    mPrivateFlags3 |= PFLAG3_FINGER_DOWN;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                mHasPerformedLongPress = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!clickable) &#123;</span><br><span class=\"line\">                    checkForLongClick(<span class=\"number\">0</span>, x, y);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (performButtonActionOnTouchDown(event)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Walk up the hierarchy to determine if we're inside a scrolling container.</span></span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> isInScrollingContainer = isInScrollingContainer();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// For views inside a scrolling container, delay the pressed feedback for</span></span><br><span class=\"line\">                <span class=\"comment\">// a short period in case this is a scroll.</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isInScrollingContainer) &#123;</span><br><span class=\"line\">                    mPrivateFlags |= PFLAG_PREPRESSED;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (mPendingCheckForTap == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        mPendingCheckForTap = <span class=\"keyword\">new</span> CheckForTap();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    mPendingCheckForTap.x = event.getX();</span><br><span class=\"line\">                    mPendingCheckForTap.y = event.getY();</span><br><span class=\"line\">                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Not inside a scrolling container, so show the feedback right away</span></span><br><span class=\"line\">                    setPressed(<span class=\"keyword\">true</span>, x, y);</span><br><span class=\"line\">                    checkForLongClick(<span class=\"number\">0</span>, x, y);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (clickable) &#123;</span><br><span class=\"line\">                    setPressed(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                removeTapCallback();</span><br><span class=\"line\">                removeLongPressCallback();</span><br><span class=\"line\">                mInContextButtonPress = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                mHasPerformedLongPress = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                mIgnoreNextUpEvent = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_MOVE:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (clickable) &#123;</span><br><span class=\"line\">                    drawableHotspotChanged(x, y);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Be lenient about moving outside of buttons</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!pointInView(x, y, mTouchSlop)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Outside button</span></span><br><span class=\"line\">                    <span class=\"comment\">// Remove any future long press/tap checks</span></span><br><span class=\"line\">                    removeTapCallback();</span><br><span class=\"line\">                    removeLongPressCallback();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        setPressed(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"事件分发机制表现与实现原理\"><a href=\"#事件分发机制表现与实现原理\" class=\"headerlink\" title=\"事件分发机制表现与实现原理\"></a>事件分发机制表现与实现原理</h1><pre><code>http://blog.csdn.net/qq_23547831/article/details/51530671\n表现图片来源: http://blog.csdn.net/chunqiuwei/article/details/41084921\n</code></pre><ul>\n<li><p>事件拦截表现<br><img src=\"http://img.blog.csdn.net/20141113191428406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2h1bnFpdXdlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"事件拦截1\"></p>\n<ul>\n<li>不拦截不处理时<br><img src=\"http://img.blog.csdn.net/20141113192118648?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2h1bnFpdXdlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"事件拦截2\"></li>\n<li>C拦截但不处理时<br><img src=\"http://img.blog.csdn.net/20141113193108593?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2h1bnFpdXdlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"事件拦截3\"></li>\n<li>D处理时<br><img src=\"http://img.blog.csdn.net/20141113193349703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2h1bnFpdXdlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"事件拦截4\"></li>\n</ul>\n</li>\n<li><p>事件拦截原理<br><img src=\"https://i.imgur.com/S49ezlo.png\" alt=\"Android 事件分发机制\"></p>\n</li>\n</ul>\n<h3 id=\"ViewGroup-dispatchTouchEvent\"><a href=\"#ViewGroup-dispatchTouchEvent\" class=\"headerlink\" title=\"ViewGroup # dispatchTouchEvent()\"></a><code>ViewGroup # dispatchTouchEvent()</code></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Handle an initial down.</span><br><span class=\"line\">         if (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class=\"line\">             // Throw away all previous state when starting a new touch gesture.</span><br><span class=\"line\">             // The framework may have dropped the up or cancel event for the previous gesture</span><br><span class=\"line\">             // due to an app switch, ANR, or some other state change.</span><br><span class=\"line\">             cancelAndClearTouchTargets(ev);//清除之前的所有其他动作,使mFirstTouchTarget=null</span><br><span class=\"line\">             resetTouchState();//重置Touch状态标识。</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Check for interception.</span><br><span class=\"line\">         final boolean intercepted;</span><br><span class=\"line\">         if (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class=\"line\">                 || mFirstTouchTarget != null) &#123;</span><br><span class=\"line\">             final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</span><br><span class=\"line\">             if (!disallowIntercept) &#123;</span><br><span class=\"line\">                 intercepted = onInterceptTouchEvent(ev);//默认不拦截</span><br><span class=\"line\">                 ev.setAction(action); // restore action in case it was changed</span><br><span class=\"line\">             &#125; else &#123;</span><br><span class=\"line\">                 intercepted = false;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125; else &#123;</span><br><span class=\"line\">             // There are no touch targets and this action is not an initial down</span><br><span class=\"line\">             // so this view group continues to intercept touches.</span><br><span class=\"line\">             intercepted = true;</span><br><span class=\"line\">         &#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>每个<code>MotionEvent.ACTION_DOWN</code>发生时会清除之前所有连续的动作并作为一系列动作的开端；</li>\n<li>当<code>MotionEvent.ACTION_DOWN</code>或存在动作接收对象时,默认不拦截动作；否则拦截动作；</li>\n</ol>\n<hr>\n<h3 id=\"View-dispatchTouchEvent-event\"><a href=\"#View-dispatchTouchEvent-event\" class=\"headerlink\" title=\"View # dispatchTouchEvent(event)\"></a><code>View # dispatchTouchEvent(event)</code></h3><p><code>ViewGroup # dispatchTouchEvent(event)</code> <strong>倒序循环判断当前从上方到下方的<code>直接子View/ViewGroup</code></strong>, 判断当前事件是否存在消费对象,<strong>递归判断</strong>,最终调用的是已经定义过的<code>child # dispatchTouchEvent()</code>或者是<code>View # dispatchTouchEvent(event)</code></p>\n<ul>\n<li><code>View # dispatchTouchEvent(event)</code> 返回<code>true</code>的情况<ul>\n<li>处理内部滚动事件</li>\n<li><code>View # isEnabled()==true</code>,添加<code>View $ OnTouchListener</code>并在<code>OnTouchListener # onTouch()</code>返回true;</li>\n<li><code>View # onTouchEvent()</code>返回true;</li>\n</ul>\n</li>\n</ul>\n<p>如果控件（View）是enable且onTouch返回true情况下，dispatchTouchEvent直接返回true，不会调用onTouchEvent方法。</p>\n<p>完整代码如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * View # dispatchTouchEvent(event)</span></span><br><span class=\"line\"><span class=\"comment\">    * </span></span><br><span class=\"line\"><span class=\"comment\">    * Pass the touch screen motion event down to the target view, or this</span></span><br><span class=\"line\"><span class=\"comment\">    * view if it is the target.</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> event The motion event to be dispatched.</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span> True if the event was handled by the view, false otherwise.</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">// If the event should be handled by accessibility focus first.</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (event.isTargetAccessibilityFocus()) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// We don't have focus or no virtual descendant has it, do not handle the event.</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (!isAccessibilityFocusedViewOrHost()) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"comment\">// We have focus and got the event, then use normal event dispatch.</span></span><br><span class=\"line\">           event.setTargetAccessibilityFocus(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">boolean</span> result = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (mInputEventConsistencyVerifier != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           mInputEventConsistencyVerifier.onTouchEvent(event, <span class=\"number\">0</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> actionMasked = event.getActionMasked();</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// Defensive cleanup for new gesture</span></span><br><span class=\"line\">           stopNestedScroll();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class=\"line\">               result = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"comment\">//noinspection SimplifiableIfStatement</span></span><br><span class=\"line\">           ListenerInfo li = mListenerInfo;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (li != <span class=\"keyword\">null</span> &amp;&amp; li.mOnTouchListener != <span class=\"keyword\">null</span></span><br><span class=\"line\">                   &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class=\"line\">                   &amp;&amp; li.mOnTouchListener.onTouch(<span class=\"keyword\">this</span>, event)) &#123;</span><br><span class=\"line\">               result = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class=\"line\">               result = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (!result &amp;&amp; mInputEventConsistencyVerifier != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           mInputEventConsistencyVerifier.onUnhandledEvent(event, <span class=\"number\">0</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// Clean up after nested scrolls if this is the end of a gesture;</span></span><br><span class=\"line\">       <span class=\"comment\">// also cancel it if we tried an ACTION_DOWN but we didn't want the rest</span></span><br><span class=\"line\">       <span class=\"comment\">// of the gesture.</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (actionMasked == MotionEvent.ACTION_UP ||</span><br><span class=\"line\">               actionMasked == MotionEvent.ACTION_CANCEL ||</span><br><span class=\"line\">               (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123;</span><br><span class=\"line\">           stopNestedScroll();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"View-onTouchEvent-event\"><a href=\"#View-onTouchEvent-event\" class=\"headerlink\" title=\"View # onTouchEvent(event)\"></a><code>View # onTouchEvent(event)</code></h3><ul>\n<li>点击和长按事件都会消耗当前事件返回true</li>\n</ul>\n<p>全部代码如下:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Implement this method to handle touch screen motion events.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * If this method is used to detect click actions, it is recommended that</span></span><br><span class=\"line\"><span class=\"comment\"> * the actions be performed by implementing and calling</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> #performClick()&#125;. This will ensure consistent system behavior,</span></span><br><span class=\"line\"><span class=\"comment\"> * including:</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;ul&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;li&gt;obeying click sound preferences</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;li&gt;dispatching OnClickListener calls</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;li&gt;handling &#123;<span class=\"doctag\">@link</span> AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK&#125; when</span></span><br><span class=\"line\"><span class=\"comment\"> * accessibility features are enabled</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> event The motion event.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> True if the event was handled, false otherwise.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> x = event.getX();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> y = event.getY();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> viewFlags = mViewFlags;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> action = event.getAction();</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt;    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class=\"line\">            || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class=\"line\">            || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            setPressed(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class=\"line\">        <span class=\"comment\">// A disabled view that is clickable still consumes the touch</span></span><br><span class=\"line\">        <span class=\"comment\">// events, it just doesn't respond to them.</span></span><br><span class=\"line\">&gt;&gt;&gt;     <span class=\"keyword\">return</span> clickable;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mTouchDelegate != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (action) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_UP:</span><br><span class=\"line\">                mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class=\"line\">                    handleTooltipUp();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!clickable) &#123;</span><br><span class=\"line\">                    removeTapCallback();</span><br><span class=\"line\">                    removeLongPressCallback();</span><br><span class=\"line\">                    mInContextButtonPress = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    mHasPerformedLongPress = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    mIgnoreNextUpEvent = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class=\"number\">0</span> || prepressed) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// take focus if we don't have it already and we should in</span></span><br><span class=\"line\">                    <span class=\"comment\">// touch mode.</span></span><br><span class=\"line\">                    <span class=\"keyword\">boolean</span> focusTaken = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</span><br><span class=\"line\">                        focusTaken = requestFocus();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prepressed) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// The button is being released before we actually</span></span><br><span class=\"line\">                        <span class=\"comment\">// showed it as pressed.  Make it show the pressed</span></span><br><span class=\"line\">                        <span class=\"comment\">// state now (before scheduling the click) to ensure</span></span><br><span class=\"line\">                        <span class=\"comment\">// the user sees it.</span></span><br><span class=\"line\">                        setPressed(<span class=\"keyword\">true</span>, x, y);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// This is a tap, so remove the longpress check</span></span><br><span class=\"line\">                        removeLongPressCallback();</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"comment\">// Only perform take click actions if we were in the pressed state</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (!focusTaken) &#123;</span><br><span class=\"line\">                            <span class=\"comment\">// Use a Runnable and post this rather than calling</span></span><br><span class=\"line\">                            <span class=\"comment\">// performClick directly. This lets other visual state</span></span><br><span class=\"line\">                            <span class=\"comment\">// of the view update before click actions start.</span></span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (mPerformClick == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                mPerformClick = <span class=\"keyword\">new</span> PerformClick();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (!post(mPerformClick)) &#123;</span><br><span class=\"line\">                                performClick();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (mUnsetPressedState == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        mUnsetPressedState = <span class=\"keyword\">new</span> UnsetPressedState();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prepressed) &#123;</span><br><span class=\"line\">                        postDelayed(mUnsetPressedState,</span><br><span class=\"line\">                                ViewConfiguration.getPressedStateDuration());</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!post(mUnsetPressedState)) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// If the post failed, unpress right now</span></span><br><span class=\"line\">                        mUnsetPressedState.run();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    removeTapCallback();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                mIgnoreNextUpEvent = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_DOWN:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) &#123;</span><br><span class=\"line\">                    mPrivateFlags3 |= PFLAG3_FINGER_DOWN;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                mHasPerformedLongPress = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!clickable) &#123;</span><br><span class=\"line\">                    checkForLongClick(<span class=\"number\">0</span>, x, y);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (performButtonActionOnTouchDown(event)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Walk up the hierarchy to determine if we're inside a scrolling container.</span></span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> isInScrollingContainer = isInScrollingContainer();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// For views inside a scrolling container, delay the pressed feedback for</span></span><br><span class=\"line\">                <span class=\"comment\">// a short period in case this is a scroll.</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isInScrollingContainer) &#123;</span><br><span class=\"line\">                    mPrivateFlags |= PFLAG_PREPRESSED;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (mPendingCheckForTap == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        mPendingCheckForTap = <span class=\"keyword\">new</span> CheckForTap();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    mPendingCheckForTap.x = event.getX();</span><br><span class=\"line\">                    mPendingCheckForTap.y = event.getY();</span><br><span class=\"line\">                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Not inside a scrolling container, so show the feedback right away</span></span><br><span class=\"line\">                    setPressed(<span class=\"keyword\">true</span>, x, y);</span><br><span class=\"line\">                    checkForLongClick(<span class=\"number\">0</span>, x, y);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (clickable) &#123;</span><br><span class=\"line\">                    setPressed(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                removeTapCallback();</span><br><span class=\"line\">                removeLongPressCallback();</span><br><span class=\"line\">                mInContextButtonPress = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                mHasPerformedLongPress = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                mIgnoreNextUpEvent = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_MOVE:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (clickable) &#123;</span><br><span class=\"line\">                    drawableHotspotChanged(x, y);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Be lenient about moving outside of buttons</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!pointInView(x, y, mTouchSlop)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Outside button</span></span><br><span class=\"line\">                    <span class=\"comment\">// Remove any future long press/tap checks</span></span><br><span class=\"line\">                    removeTapCallback();</span><br><span class=\"line\">                    removeLongPressCallback();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        setPressed(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n"},{"title":"Android 滑动 & 滚动","_content":"# 滑动 & 滚动\n\n```\n\t滑动:\n\n\t\t- translationX / translationY : 动画更改原位置的相对位置的虚假效果;\n\n\t\t- 布局参数动态更改\n\n\t\t\t- left/right/top/bottom:\n\n\t\t\t\t- layout(getLeft()+offsetX,...);\n\n\t\t\t\t- offsetLeftAndRight(offsetX),offsetTopAndBottom(offsetY);\n\n\t\t\t- (Margin)LayoutParams 对View本身的动态增加的真实效果;\n\n\t\t\t\t- setMargins(offsetX,...),效果等同于offsetLeftAndRight()...;\n\n\t\t\t\t- lp.leftMargin = getLeft()+offsetX...,效果等同于layout();\n\n\t滚动:\n\t\t- scrollTo()/scrollBy() : 对View内部的滚动位置的更改;\n\t\t\t触发OnScrollChangeListener#onScrollChange\n\t\t\t(View v, int scrollX, int scrollY, int oldScrollX, int oldScrollY);\n\t\t\t\n\n\t\t- Scroller\n\n```\n---\n\n### scrollTo()/scrollBy()  ###\n\n<font color=red>**`scrollTo(x,y)`理解为将内容`(x,y)`的坐标移动到左上角;\n`scrollBy(offsetX,offsetY)`理解为向左移动`offsetX`个单位,向上移动`offsetY`个单位。 **</font>\n\n\n---\n### Scroller ###\n`Scroller`通过调用`Scroller # startScroll(startX,startY,offsetX,offsetY,duration)`存储滚动数据,`View # invalidate()`重绘,在`onDraw()`中调用`View # computeScroll()`获取当前的`scrollX`,`scrollY`,使用scrollTo()完成滑动,重绘进行重复操作,直到完成整个滑动.\n\n```\n\t//设置滚动信息\n\tScroller scroller = new Scroller(getContext());\n    scroller.startScroll(startX,startY,offsetX,offsetY,duration);\n    invalidate();\n\n\t/* 完成滚动并重绘直到完成滑动整个过程 */\n\t@Override\n    public void computeScroll() {\n        super.computeScroll();\n        if (scroller.computeScrollOffset()){\n            scrollTo(scroller.getCurrX(),scroller.getCurrY());\n            postInvalidate();\n        }\n    }\n```\n\n---","source":"_posts/Android之自定义控件——滑动,滚动.md","raw":"---\n\ntitle: Android 滑动 & 滚动\ncategories: \"android 总结\"\ntags: \n     - android\n     - 滑动\n     - 滚动\n \n---\n# 滑动 & 滚动\n\n```\n\t滑动:\n\n\t\t- translationX / translationY : 动画更改原位置的相对位置的虚假效果;\n\n\t\t- 布局参数动态更改\n\n\t\t\t- left/right/top/bottom:\n\n\t\t\t\t- layout(getLeft()+offsetX,...);\n\n\t\t\t\t- offsetLeftAndRight(offsetX),offsetTopAndBottom(offsetY);\n\n\t\t\t- (Margin)LayoutParams 对View本身的动态增加的真实效果;\n\n\t\t\t\t- setMargins(offsetX,...),效果等同于offsetLeftAndRight()...;\n\n\t\t\t\t- lp.leftMargin = getLeft()+offsetX...,效果等同于layout();\n\n\t滚动:\n\t\t- scrollTo()/scrollBy() : 对View内部的滚动位置的更改;\n\t\t\t触发OnScrollChangeListener#onScrollChange\n\t\t\t(View v, int scrollX, int scrollY, int oldScrollX, int oldScrollY);\n\t\t\t\n\n\t\t- Scroller\n\n```\n---\n\n### scrollTo()/scrollBy()  ###\n\n<font color=red>**`scrollTo(x,y)`理解为将内容`(x,y)`的坐标移动到左上角;\n`scrollBy(offsetX,offsetY)`理解为向左移动`offsetX`个单位,向上移动`offsetY`个单位。 **</font>\n\n\n---\n### Scroller ###\n`Scroller`通过调用`Scroller # startScroll(startX,startY,offsetX,offsetY,duration)`存储滚动数据,`View # invalidate()`重绘,在`onDraw()`中调用`View # computeScroll()`获取当前的`scrollX`,`scrollY`,使用scrollTo()完成滑动,重绘进行重复操作,直到完成整个滑动.\n\n```\n\t//设置滚动信息\n\tScroller scroller = new Scroller(getContext());\n    scroller.startScroll(startX,startY,offsetX,offsetY,duration);\n    invalidate();\n\n\t/* 完成滚动并重绘直到完成滑动整个过程 */\n\t@Override\n    public void computeScroll() {\n        super.computeScroll();\n        if (scroller.computeScrollOffset()){\n            scrollTo(scroller.getCurrX(),scroller.getCurrY());\n            postInvalidate();\n        }\n    }\n```\n\n---","slug":"Android之自定义控件——滑动,滚动","published":1,"date":"2018-03-21T05:35:40.027Z","updated":"2018-03-21T05:25:11.279Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjf0otqpe0004so4l89sqfgti","content":"<h1 id=\"滑动-amp-滚动\"><a href=\"#滑动-amp-滚动\" class=\"headerlink\" title=\"滑动 &amp; 滚动\"></a>滑动 &amp; 滚动</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">滑动:</span><br><span class=\"line\"></span><br><span class=\"line\">\t- translationX / translationY : 动画更改原位置的相对位置的虚假效果;</span><br><span class=\"line\"></span><br><span class=\"line\">\t- 布局参数动态更改</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t- left/right/top/bottom:</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t- layout(getLeft()+offsetX,...);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t- offsetLeftAndRight(offsetX),offsetTopAndBottom(offsetY);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t- (Margin)LayoutParams 对View本身的动态增加的真实效果;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t- setMargins(offsetX,...),效果等同于offsetLeftAndRight()...;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t- lp.leftMargin = getLeft()+offsetX...,效果等同于layout();</span><br><span class=\"line\"></span><br><span class=\"line\">滚动:</span><br><span class=\"line\">\t- scrollTo()/scrollBy() : 对View内部的滚动位置的更改;</span><br><span class=\"line\">\t\t触发OnScrollChangeListener#onScrollChange</span><br><span class=\"line\">\t\t(View v, int scrollX, int scrollY, int oldScrollX, int oldScrollY);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t- Scroller</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"scrollTo-scrollBy\"><a href=\"#scrollTo-scrollBy\" class=\"headerlink\" title=\"scrollTo()/scrollBy()\"></a>scrollTo()/scrollBy()</h3><font color=\"red\"><strong><code>scrollTo(x,y)</code>理解为将内容<code>(x,y)</code>的坐标移动到左上角;<br><code>scrollBy(offsetX,offsetY)</code>理解为向左移动<code>offsetX</code>个单位,向上移动<code>offsetY</code>个单位。 </strong></font>\n\n\n<hr>\n<h3 id=\"Scroller\"><a href=\"#Scroller\" class=\"headerlink\" title=\"Scroller\"></a>Scroller</h3><p><code>Scroller</code>通过调用<code>Scroller # startScroll(startX,startY,offsetX,offsetY,duration)</code>存储滚动数据,<code>View # invalidate()</code>重绘,在<code>onDraw()</code>中调用<code>View # computeScroll()</code>获取当前的<code>scrollX</code>,<code>scrollY</code>,使用scrollTo()完成滑动,重绘进行重复操作,直到完成整个滑动.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//设置滚动信息</span><br><span class=\"line\">Scroller scroller = new Scroller(getContext());</span><br><span class=\"line\">   scroller.startScroll(startX,startY,offsetX,offsetY,duration);</span><br><span class=\"line\">   invalidate();</span><br><span class=\"line\"></span><br><span class=\"line\">/* 完成滚动并重绘直到完成滑动整个过程 */</span><br><span class=\"line\">@Override</span><br><span class=\"line\">   public void computeScroll() &#123;</span><br><span class=\"line\">       super.computeScroll();</span><br><span class=\"line\">       if (scroller.computeScrollOffset())&#123;</span><br><span class=\"line\">           scrollTo(scroller.getCurrX(),scroller.getCurrY());</span><br><span class=\"line\">           postInvalidate();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"滑动-amp-滚动\"><a href=\"#滑动-amp-滚动\" class=\"headerlink\" title=\"滑动 &amp; 滚动\"></a>滑动 &amp; 滚动</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">滑动:</span><br><span class=\"line\"></span><br><span class=\"line\">\t- translationX / translationY : 动画更改原位置的相对位置的虚假效果;</span><br><span class=\"line\"></span><br><span class=\"line\">\t- 布局参数动态更改</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t- left/right/top/bottom:</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t- layout(getLeft()+offsetX,...);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t- offsetLeftAndRight(offsetX),offsetTopAndBottom(offsetY);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t- (Margin)LayoutParams 对View本身的动态增加的真实效果;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t- setMargins(offsetX,...),效果等同于offsetLeftAndRight()...;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t- lp.leftMargin = getLeft()+offsetX...,效果等同于layout();</span><br><span class=\"line\"></span><br><span class=\"line\">滚动:</span><br><span class=\"line\">\t- scrollTo()/scrollBy() : 对View内部的滚动位置的更改;</span><br><span class=\"line\">\t\t触发OnScrollChangeListener#onScrollChange</span><br><span class=\"line\">\t\t(View v, int scrollX, int scrollY, int oldScrollX, int oldScrollY);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t- Scroller</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"scrollTo-scrollBy\"><a href=\"#scrollTo-scrollBy\" class=\"headerlink\" title=\"scrollTo()/scrollBy()\"></a>scrollTo()/scrollBy()</h3><font color=\"red\"><strong><code>scrollTo(x,y)</code>理解为将内容<code>(x,y)</code>的坐标移动到左上角;<br><code>scrollBy(offsetX,offsetY)</code>理解为向左移动<code>offsetX</code>个单位,向上移动<code>offsetY</code>个单位。 </strong></font>\n\n\n<hr>\n<h3 id=\"Scroller\"><a href=\"#Scroller\" class=\"headerlink\" title=\"Scroller\"></a>Scroller</h3><p><code>Scroller</code>通过调用<code>Scroller # startScroll(startX,startY,offsetX,offsetY,duration)</code>存储滚动数据,<code>View # invalidate()</code>重绘,在<code>onDraw()</code>中调用<code>View # computeScroll()</code>获取当前的<code>scrollX</code>,<code>scrollY</code>,使用scrollTo()完成滑动,重绘进行重复操作,直到完成整个滑动.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//设置滚动信息</span><br><span class=\"line\">Scroller scroller = new Scroller(getContext());</span><br><span class=\"line\">   scroller.startScroll(startX,startY,offsetX,offsetY,duration);</span><br><span class=\"line\">   invalidate();</span><br><span class=\"line\"></span><br><span class=\"line\">/* 完成滚动并重绘直到完成滑动整个过程 */</span><br><span class=\"line\">@Override</span><br><span class=\"line\">   public void computeScroll() &#123;</span><br><span class=\"line\">       super.computeScroll();</span><br><span class=\"line\">       if (scroller.computeScrollOffset())&#123;</span><br><span class=\"line\">           scrollTo(scroller.getCurrX(),scroller.getCurrY());</span><br><span class=\"line\">           postInvalidate();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<hr>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjf0kjqjh000m0s4ltrktmbgo","category_id":"cjf0n0uc50015to4ld5pnrgyo","_id":"cjf0n0uc70018to4lw04durw1"},{"post_id":"cjf0otqoj0000so4l5qqz87x0","category_id":"cjf0n0uc50015to4ld5pnrgyo","_id":"cjf0otqpe0003so4lb6jgl4ly"},{"post_id":"cjf0kjqjd000i0s4lwr54y1r1","category_id":"cjf0n0uc50015to4ld5pnrgyo","_id":"cjf0otqpe0005so4laetadmr8"},{"post_id":"cjf0otqpe0002so4lq1ca8irz","category_id":"cjf0n0uc50015to4ld5pnrgyo","_id":"cjf0otqpe0009so4liynu6yc7"},{"post_id":"cjf0otqpe0004so4l89sqfgti","category_id":"cjf0n0uc50015to4ld5pnrgyo","_id":"cjf0otqpe000cso4ldumz4qud"},{"post_id":"cjf0kjqjg000l0s4ltz86p57i","category_id":"cjf0n0uc50015to4ld5pnrgyo","_id":"cjf0otqq9000rso4l2a89f4pi"}],"PostTag":[{"post_id":"cjf0kjqjh000m0s4ltrktmbgo","tag_id":"cjf0n0uc60016to4lfdt14jmq","_id":"cjf0n0uc8001ato4lx0o9llxj"},{"post_id":"cjf0kjqjh000m0s4ltrktmbgo","tag_id":"cjf0n0uc70017to4ljvzi9389","_id":"cjf0n0uc8001bto4l6esrwqmx"},{"post_id":"cjf0kjqjh000m0s4ltrktmbgo","tag_id":"cjf0n0uc70019to4l2ycckxex","_id":"cjf0n0uc8001cto4lutl90zsb"},{"post_id":"cjf0otqoj0000so4l5qqz87x0","tag_id":"cjf0n0uc60016to4lfdt14jmq","_id":"cjf0otqpe0007so4lgfr33wzq"},{"post_id":"cjf0otqoj0000so4l5qqz87x0","tag_id":"cjf0otqoz0001so4lmt588ktg","_id":"cjf0otqpe000aso4l302wfcpo"},{"post_id":"cjf0kjqjd000i0s4lwr54y1r1","tag_id":"cjf0n0uc60016to4lfdt14jmq","_id":"cjf0otqpe000eso4lb1gctjkr"},{"post_id":"cjf0kjqjd000i0s4lwr54y1r1","tag_id":"cjf0otqpe0006so4l5jbitcif","_id":"cjf0otqpe000fso4lx05v12it"},{"post_id":"cjf0kjqjd000i0s4lwr54y1r1","tag_id":"cjf0otqpe000bso4lpaoaeygq","_id":"cjf0otqpe000hso4lgefughk8"},{"post_id":"cjf0otqpe0002so4lq1ca8irz","tag_id":"cjf0n0uc60016to4lfdt14jmq","_id":"cjf0otqpe000jso4l4l4m89b9"},{"post_id":"cjf0otqpe0002so4lq1ca8irz","tag_id":"cjf0otqpe000dso4lzt57xhkn","_id":"cjf0otqpe000kso4l86zwxbpk"},{"post_id":"cjf0otqpe0002so4lq1ca8irz","tag_id":"cjf0otqpe000gso4luf010uh1","_id":"cjf0otqpe000mso4lb3oa6y44"},{"post_id":"cjf0otqpe0004so4l89sqfgti","tag_id":"cjf0n0uc60016to4lfdt14jmq","_id":"cjf0otqpe000nso4lduomps51"},{"post_id":"cjf0otqpe0004so4l89sqfgti","tag_id":"cjf0otqpe000iso4l9yssb7fh","_id":"cjf0otqpe000oso4lulmxsuag"},{"post_id":"cjf0otqpe0004so4l89sqfgti","tag_id":"cjf0otqpe000lso4lvphikng5","_id":"cjf0otqpe000pso4l14xp95zv"},{"post_id":"cjf0kjqjg000l0s4ltz86p57i","tag_id":"cjf0n0uc60016to4lfdt14jmq","_id":"cjf0otqq9000tso4lugukdu73"},{"post_id":"cjf0kjqjg000l0s4ltz86p57i","tag_id":"cjf0otqq9000qso4lqntj5wgk","_id":"cjf0otqq9000uso4ls7onf2lj"},{"post_id":"cjf0kjqjg000l0s4ltz86p57i","tag_id":"cjf0otqq9000sso4l2il39n6j","_id":"cjf0otqq9000vso4lhesseo8n"}],"Tag":[{"name":"android","_id":"cjf0n0uc60016to4lfdt14jmq"},{"name":"代码规范","_id":"cjf0n0uc70017to4ljvzi9389"},{"name":"屏幕适配","_id":"cjf0n0uc70019to4l2ycckxex"},{"name":"MotionEvent","_id":"cjf0otqoz0001so4lmt588ktg"},{"name":"View坐标","_id":"cjf0otqpe0006so4l5jbitcif"},{"name":"参数/对应函数","_id":"cjf0otqpe000bso4lpaoaeygq"},{"name":"分发","_id":"cjf0otqpe000dso4lzt57xhkn"},{"name":"原理","_id":"cjf0otqpe000gso4luf010uh1"},{"name":"滑动","_id":"cjf0otqpe000iso4l9yssb7fh"},{"name":"滚动","_id":"cjf0otqpe000lso4lvphikng5"},{"name":"崩溃","_id":"cjf0otqq9000qso4lqntj5wgk"},{"name":"错误","_id":"cjf0otqq9000sso4l2il39n6j"}]}}